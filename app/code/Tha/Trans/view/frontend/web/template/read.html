
Hướng dẫn tạo Module trong Magento 2
Nếu bạn nào đã từng làm việc với Magento chắc hẳn không còn xa lạ gì với khái niệm module nữa phải không nào. Vì toàn bộ hệ thống Magento được xây dựng dựa trên các module. 
Nếu bạn muốn customize, tùy chỉnh một chức năng mặc định nào đó của Magento hoặc bạn muốn phát triển chức năng của riêng mình thì việc đầu tiên bạn phải làm đó là tạo một module. 
Trong bài viết này, tôi sẽ hướng dẫn các bạn tạo một module có tên là ViMagento_HelloWorld một cách chi tiết và dễ hiểu nhất. Đ
ể tạo một module trong Magento 2 các bạn thực hiện theo các bước sau:

Bước 1: Cấu trúc thư mục để tạo module trong Magento 2
Tên module trong Magento 2 được chia làm hai phần đó là tên vendor và tên module. Nói cách khác thì các module được nhóm thành các vendor. 
Vì thế bạn cần xác định 2 phần trên để tạo một module. Ở đây tôi tạo module có tên là ViMagento_HelloWorld, ViMagento là tên vendor và HelloWorld là tên module và được nối với 
nhau bằng dấu ‘_’. Để tạo module ViMagento_HelloWorld các bạn tạo lần lượt các thư mục sau: 
app/code/ViMagento
app/code/ViMagento/HelloWorld
Nếu các bạn không có thư mục code hãy tự tạo nó nhé. Và để thuận tiện cho quá trình làm việc mình khuyên bạn nên đặt Magento về chế độ developer để đảm bảo bạn có thể thấy tất cả lỗi mà Magento ném ra cho bạn.
Để làm được việc này các bạn cần mở terminal và đi đến thư mục project của bạn sau đó chạy câu lệnh bên dưới:
php bin/magento deploy:mode:set developer
Để tạo module trong Magento 2 các bạn nhớ cho mình là phải tạo 2 file đó là: module.xml và registration.php sau đó chạy câu lệnh php bin/magento setup:upgrade . 
Sau đây chúng ta sẽ tạo các file theo từng bước một.

Bước 2: Tạo module.xml trong Magento 2
Tiếp theo các bạn tạo file module.xml nằm trong thư mục etc của module. File này là bắt buộc để đăng ký module của bạn.

Tạo file: ViMagento/HelloWorld/etc/module.xml
Với nội dung sau:
 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Module/etc/module.xsd">
    <module name="ViMagento_HelloWorld" setup_version="1.0.0">
        <sequence>
            <module name="Magento_Catalog"/>
        </sequence>
    </module>
</config>
 
▪	Module name: Được định nghĩa bởi các thư mục mà chúng ta đã tạo ở bước thứ nhất. Ở đây là ViMagento_HelloWorld vì trong Magento, tên class phải tuân theo cấu trúc thư mục. Vì chúng ta đã tạo module có tên là ViMagento_HelloWorld nên bất cứ class nào nằm bên trong module này thì namespace phải bắt đầu với ViMagento\HelloWorld. Ví dụ: ViMagento\HelloWorld\Model\Post.
▪	Module version: Là phiên bản hiện tại của module được lưu trong cơ sở dữ liệu và được sử dụng trong quá trình nâng cấp module. Khi quá trình nâng cấp module xảy ra Magento sẽ so sánh version được lưu trong database và version trong module.xml nếu không khớp Magento sẽ thực hiện việc nâng cấp cho bạn. Khi các bạn học đến các bài liên quan đến setup script các bạn sẽ hiểu hơn về phần này.
▪	Sequence: Nếu module của bạn phụ thuộc vào một module khác module.xml sẽ có một khai báo đặc biệt định nghĩa danh sách các module mà module hiện tại phụ thuộc vào. Có nghĩa là module hiện tại có sử dụng class, model của module khác vì thế nó không thể hoạt động đúng nếu không phụ thuộc vào các module này. Ví dụ trên là module hiện tại đang phụ thuộc vào module Magento_Catalog vì thế module hiện tại sẽ được load sau khi module Magento_Catalog được load.
▪	Bước 3: Tạo file registration.php để đăng ký module
▪	Mỗi module đều bắt buộc phải có file này để đăng ký module cho Magento biết cách định vị module. Tiếp theo chúng ta sẽ tạo ViMagento/HelloWorld/registration.php với nội dung sau:
▪	
	 
<?php
\Magento\Framework\Component\ComponentRegistrar::register(
    \Magento\Framework\Component\ComponentRegistrar::MODULE,
    'ViMagento_HelloWorld',
    __DIR__
);
 
▪	Nội dung file này đã được chuẩn hóa cho tất cả module vì thế bạn chỉ cần thay đổi tên module cho phù hợp với module của bạn.
▪	Bước 4: Kích hoạt module vừa tạo
▪	Chay câu lệnh bên dưới để kích hoạt module, thông báo cho Magento biết về sự hiện diện module của bạn.
▪	php bin/magento setup:upgrade
Bước 5: Kiểm tra xem module đã được kích hoạt hay chưa
▪	Xem bảng setup_module trong cơ sở dữ liệu của bạn.
 Hướng dẫn tạo Module trong Magento 2
▪	Xem trong file app/etc/config.php
 Hướng dẫn tạo Module trong Magento 2
Các câu lệnh bên dưới lần lượt dùng để xem trạng thái module, kích hoạt hoặc tắt module nào bạn muốn.
▪	php bin/magento module:status (xem trạng thái của tất cả module trong hệ thống bao gồm danh sách các module đang được kích hoạt và đang bị tắt)
▪	php bin/magento module:enable ViMagento_HelloWorld (kích hoạt module ViMagento_HelloWorld)
▪	php bin/magento module:disable ViMagento_HelloWorld (dùng để tắt module ViMagento_HelloWorld)
Sau khi thực hiện xong các bước trên các bạn đã tạo thành công module trong magento 2. Mình tin rằng đây sẽ là bước đầu tốt đẹp để các bạn có thể trở thành một nhà phát triển magento tương lại.
Các bạn cũng có thể tham khảo bài viết devdocs của Magento 2 để biết thêm chi tiết: https://devdocs.magento.com/videos/fundamentals/create-a-new-module/
Kết luận
Đây là bài đầu tiên trong loạt bài hướng dẫn về Magento 2 cơ bản. Và mình vừa hướng dẫn xong cho các bạn về các tạo module trong Magento 2. Hy vọng bài viết có thể giúp ích được phần nào cho các bạn. Bài tiếp theo tôi sẽ hướng dẫn các bạn tạo một controller trong Magento 2. Thanks.
 
Tạo Controller trong Magento 2 chi tiết nhất
Controller là một phần quan trọng trong module nói riêng và mô hình MVC nói chung. Nhiệm vụ của controller là nhận request, xử lý và render page. Có thể có một hoặc nhiều file trong thư mục controller của module. Có hai loại controller là frontend controller và backend controller. Về bản chất thì 2 loại này giống nhau chỉ khác là ở backend controller sẽ có thêm một method để kiểm tra quyền truy cập. Trong bài viết này chúng ta sẽ cùng nhau tìm hiểu cách để tạo Controller trong Magento 2:
Bước 1: Tạo file routes.xml
Bước đầu tiên trước khi tạo controller, các bạn phải tạo file routes.xml nằm trong module ViMagento_HelloWorld đã tạo ở bài trước
▪	Đối với frontend controller
Bạn tạo một file ViMagento/HelloWorld/etc/frontend/routes.xml và thêm nội dung bên dưới:

 
<?xml version="1.0" ?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:App/etc/routes.xsd">
    <router id="standard">
        <route frontName="helloworld" id="helloworld">
            <module name="ViMagento_HelloWorld"/>
        </route>
    </router>
</config>
 
▪	Đối với backend controller
Bạn tạo file ViMagento/HelloWorld/etc/adminhtml/routes.xml và thêm nội dung bên dưới:
	 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:App/etc/routes.xsd">
    <router id="admin">
        <route id="helloworld" frontName="helloworld">
            <module name="ViMagento_HelloWorld"/>
        </route>
    </router>
</config>
 
Bước 2: Tạo Controller
▪	Tạo Controller frontend
Bạn tạo file ViMagento/HelloWorld/Controller/Post/Index.php và thêm nội dung sau:

	 
<?php
 
namespace ViMagento\HelloWorld\Controller\Post;
 
class Index extends \Magento\Framework\App\Action\Action
{
    protected $_pageFactory;
 
    public function __construct(
        \Magento\Framework\App\Action\Context $context,
        \Magento\Framework\View\Result\PageFactory $pageFactory)
    {
        $this->_pageFactory = $pageFactory;
        return parent::__construct($context);
    }
 
    public function execute()
    {
        return $this->_pageFactory->create();
    }
}
 
▪	Đối với backend controller
Bạn tạo file ViMagento/HelloWorld/Controller/Adminhtml/Post/Index.php và thêm nội dung sau:

	 
<?php
 
namespace ViMagento\HelloWorld\Controller\Adminhtml\Post;
 
use Magento\Framework\View\Result\PageFactory;
use Magento\Backend\App\Action;
 
class Index extends \Magento\Backend\App\Action
{
    protected $_pageFactory;
 
    public function __construct(Action\Context $context, PageFactory $pageFactory)
    {
        parent::__construct($context);
    }
 
    public function execute()
    {
        return $this->_pageFactory->create();
    }
}
 
Như ở trên các bạn có thể thấy frontend controller extends class Magento\Framework\App\Action\Action và nằm trực tiếp ở trong thư mục Controller. Còn backend controller thì extends class Magento\Backend\App\Action và bắt buộc phải nằm trong thư mục Controller/Adminhtml nhé. Ở đây thì cả hai class để sử dụng Magento\Framework\View\Result\PageFactory để render ra trang cơ bản mà magento đã xây dựng sẵn. Và tất cả logic sẽ được thực hiện trong execute() method.
Sau khi thực hiện xong hai bước trên các bạn clear cache để Magento cập nhật những thay đổi của bạn và triển khai chúng.
php bin/magento cache:clean
Bước 3: Kiểm tra xem đã tạo Controller thành công chưa
Đầu tiên các bạn phải xác định URL của controller của bạn. URL trong magento 2 được chia làm ba phần: http://domain.com/frontName/ControllerName/ActionName trong đó:
▪	frontName: được xác định trong file routes.xml
▪	ControllerName: là thư mục phía trong thư mục Controller
▪	ActionName: chính là class chứa method execute() bạn vừa viết.
Trong bài viết này tôi sử dụng:
▪	https://example.com/helloworld/post/index
▪	https://example.com/admin/helloworld/post/index
Bây giờ hãy mở trình duyệt của bạn và truy cập theo URL đã xác định ở trên nếu thành công sẽ hiển thị trang web mặc định của Magento như bên dưới:
 Tạo Controller trong Magento 2 (Frontend) Tạo Controller trong Magento 2 (Backend)
Kết luận
Vừa rồi tôi đã hướng dẫn các bạn tạo controller trong Magento 2. Trong bài viết tiếp theo chúng ta sẽ tìm hiểu cách thêm một layout cho từng controller bạn muốn nhé.
Các bạn có thể tham khảo thêm trên devdocs của magento 2: https://devdocs.magento.com/guides/v2.4/extension-dev-guide/routing.html
Layout trong Magento 2 – Hướng dẫn chi tiết
Trong Magento 2, layout được sử dụng để mô tả cấu trúc của một trang web. Bài viết này sẽ hướng dẫn về một số thành phần cơ bản và hay sử dụng mà bạn cần biết để tùy biến giao diện của bạn.
Tổng quan về layout trong Magento 2
Trong Magento 2 layout (1) dùng để mô tả cấu trúc của trang web. Container (2) dùng để tạo nên các thành phần của trang. Nó có thể chứa block và các container khác. Block (3) được dùng để render ra nội dung html của trang được chứa trong các file templates .phtml
 Layout trong Magento 2
block
Block là một đơn vị cấu thành nên trang web, bất cứ những thứ gì hữu hình mà người dùng nhìn thấy. Ví dụ như form đăng nhập, giỏ hàng…Nó liên kết giữa một block class (chứa logic) để lấy dữ liệu và một templates file (.phtml) để hiển thị nội dung. Một block có thể có block con hoặc cháu, chít…

	 
<block class="Magento\Catalog\Block\Product\ListProduct" name="category.products.list" as="product_list" template="Magento_Catalog::product/list.phtml"/>
 
▪	class: Tên của một block class thực hiện việc truy xuất dữ liệu cung cấp cho templates.
▪	name: Tên định danh cho block dùng để gọi khi cần. Lưu ý đặt tên không đươc trùng và nếu bạn bỏ trống Magento sẽ tự động tạo với tên ngẫu nhiên.
▪	template: Tên của một file .phtml dùng để hiển thị nội dung với định dạng: Vendor_Module::đường dẫn đến file template tính từ thư mục phía trong thư mục templates.
▪	display: định nghĩa liệu block có được hiển thị hay không (true/false).
▪	before: xác định block hiện tại đứng trước block nào trong cùng cấp. Ví dụ: before=”catalog” có nghĩa là block hiện tại sẽ đứng trước block có tên là catalog. Hoặc sử dụng (-) để block hiện tại đứng trước tất cả các block khác. Lưu ý là chỉ sắp xếp các khối cùng cấp nằm trong một phần tử cha thôi nhé.
▪	after: tương tự như before nhưng ngược lại.
▪	as: đóng vai trò định danh cho block sử dụng trong phần tử cha.
▪	cacheable: Xác đinhj liệu block có lưu cache hay không.
▪	ifconfig: làm cho việc hiển thị của block phụ thuộc vào một field cấu hình hệ thống. Ví dụ: ifconfig=”contact/contact/enabled” có nghĩa là block hiện tại chỉ hiển thị khi field contact/contact/enabled trong configuration có giá trị là true.
Bạn có thể sử dụng <argument></argument> để truyền tham số vào một biến của class.

	 
<referenceBlock name="footer_links">
      <block class="Magento\Framework\View\Element\Html\Link\Current" name="helloworld-link">
          <arguments>
              <argument name="label" translate="true" xsi:type="string">Helloworld landing</argument>
              <argument name="path" xsi:type="string">helloworld/index/index</argument>
          </arguments>
      </block>
</referenceBlock>
 
Ở trên tôi đã truyền hai tham số là label và path có giá trị tương ứng vào class Current để tạo một đường dẫn ở footer.
container
Container có thể hiểu như là một vùng chứa, vỏ bao bọc bên ngoài hoặc có thể bọc các phần tử con vào trong một thẻ html. Nó không chứa bất kì nội dung nào. Nó được sử dụng như là một cái thùng để chứa các container hoặc block. Nếu không có block con nào thì nó sẽ không được hiển thị ngoài frontend.

 
<container name="div.sidebar.additional" htmlTag="div" htmlClass="sidebar sidebar-additional" after="div.sidebar.main">
    <container name="sidebar.additional" as="sidebar_additional" label="Sidebar Additional"/>
</container>
 
▪	name: định nghĩa tên của container.
▪	label: dùng để mô tả mục đích của container.
▪	before và before: tương tự như block.
▪	htmlTag: thêm thẻ HTML cho container. Ví dụ: div, span, img, table…
▪	htmlClass: thêm class cho container.
▪	htmlId: thêm một id cho container.
referenceBlock and referenceContainer
Hiểu đơn giản hai thằng này cũng tương tự nhau về mặt bản chất là cùng cập nhật một block hoặc container tương ứng. Ví dụ: <referenceContainer name=”content”> có nghĩa là tôi muốn cập nhật lại <container name=”content”>. Tức là những gì bạn viết sẽ ghi đè lên phần tử gốc.

	 
<referenceBlock name="block.name" remove="true" />
 
Cập nhật ? Cụ thể chúng ta có thể làm được những gì nhỉ:
▪	Thêm block hoặc container.
▪	Sửa container hoặc block.
▪	Xóa block hoặc container.
move
Di chuyển block hoặc container đến một phần tử khác mà bạn chỉ định. Sẽ bị bỏ qua nếu phần tử không được xác định

	 
<move element="name.of.an.element" destination="name.of.destination.element" as="new_alias" after="name.of.element.after" before="name.of.element.before"/>
 
▪	element: tên của phần tử cần xóa.
▪	destination: tên của phần tử cha bạn muốn di chuyển đến.
▪	after và before: tương tự như block và container.
▪	as: tên định danh cho phần tử ở vị trí mới.
remove
Được sử dụng để xóa các file tĩnh như css, js được liên kết đến trang web nằm trong thẻ <head>.

	 
<head>
    <remove src="css/styles-m.css" />
    <remove src="my-js.js"/>
    <remove src="Magento_Catalog::js/compare.js" />
    <remove src="http://fonts.googleapis.com/css?family=Montserrat" />
</head>
 
Kết luận
Vừa rồi tôi đã giới thiệu các khái niệm hay được sử dụng để tùy biến layout trong Magento 2. Các bạn có thể xem lại bài viết về Layout, block, template trong Magento 2 để biết cách sử dụng chúng.
Trong bài viết tiếp theo tôi sẽ hướng dẫn các bạn cách sử dụng Plugin trong Magento 2.
Tài liệu để các bạn tham khảo: https://devdocs.magento.com/guides/v2.4/frontend-dev-guide/layouts/layout-overview.html
 
Layout, Block, Template trong Magento 2
Ở bài viết trước chúng ta đã tìm hiểu cách tạo một Controller trong Magento 2. Hôm nay chúng ta sẽ cùng nhau tìm hiểu về một phần cũng không kém phần quan trọng trong Magento 2 đó là View. Như bạn biết View sẽ hiển thị ở frontend (UI) mà người dùng có thể nhìn thấy được. Trong Magento 2 view được chia làm ba phần: layout, block và template. Trong bài viết này tôi sẽ hướng dẫn các bạn tạo view và hiển thị HelloWorld ra ngoài trình duyệt bằng cách sử dụng lại module ViMagento_HelloWorld và controller đã tạo ở bài viết trước. Nếu bạn nào chưa có thì có thể tham khảo bài viết sau:
▪	Tạo module ViMagento_HelloWorld trong Magento 2
▪	Tạo controller trong Magento 2
Trong thư mục view sẽ có các thư mục con:
▪	frontend: chứa mã nguồn phía frontend
▪	layout: chứa các file định nghĩa layout
▪	template: chứa các file templates .phtml dùng để render mã html
▪	web: chứa các file js, css, less…
▪	adminhtml: cũng chứa các folder layout, templates, web như trên nhưng sử dụng bên phía backend
▪	base: cũng có các thư mục như trên nhưng được sử dụng cho cả frontend và backend.
Bước 1: Tạo layout trong Magento 2
Layout được chia làm hai loại:
▪	default.xml: sử dụng file này nếu bạn muốn layout của bạn được áp dụng trên tất cả trang của website.
▪	routeId_controllerName_actionName.xml: sử dụng file này nếu bạn chỉ muốn áp dụng layout của mình cho một trang mong muốn. Trong đó tên file được chia làm ba phần tương tự như cách xác định URL ở bài trước. Chỉ khác là phần đầu tiên sẽ là route ID được xác định trong routes.xml của bạn. Ví dụ trong bài viết này là helloworld_post_index.xml
Tạo file ViMagento/HelloWorld/view/frontend/layout/helloworld_post_index.xml với nội dung sau:

	 
<?xml version="1.0"?>
<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
    <head>
        <title>HelloWorld</title>
    </head>
    <body>
        <referenceContainer name="content">
            <block class="ViMagento\HelloWorld\Block\Index" name="helloworld_index" template="ViMagento_HelloWorld::helloworld.phtml" />
        </referenceContainer>
    </body>
</page>
 
Layout sử dụng file templates để kết xuất nội dung html để hiển thị ra frontend. Ở đây là file helloworld.phtml, nghe tên bạn cũng có thể đoán được rồi đúng không nào, file này có thể viết được mã PHP và HTML nhé thậm chí CSS và Javascript. Và nó kết nối đến một file block dùng để cung cấp dữ liệu cho templates, Ví dụ như lấy 10 sản phẩm mới nhất để show ra frontend chẳng hạn…Hoàn toàn có thể làm được nhé. Ngoài ra layout còn có nhiều tác dụng nữa sẽ được trình bày chi tiết trong bài viết sau.
Bước 2: Tạo Block trong Magento 2
Tạo file ViMagento/HelloWorld/Block/Index.php

	 
<?php
 
namespace ViMagento\HelloWorld\Block;
 
use Magento\Framework\View\Element\Template;
 
class Index extends \Magento\Framework\View\Element\Template
{
    public function __construct(Template\Context $context, array $data = [])
    {
        parent::__construct($context, $data);
    }
 
    public function getTitle()
    {
        return __('HelloWorld!');
    }
}
 
File này sử dụng function getTitle để trả về dòng chữ HelloWorld!, đây chỉ là ví dụ thôi nhé. Bạn có thể viết bất cứ logic nào của bạn để lấy dữ liệu cung cấp cho templates file.
Bước 3: Tạo template trong Magento 2
Tạo file ViMagento/HelloWorld/view/templates/helloworld_post_index.xml

	 
<?= $block->getTitle(); ?>
 
Ở đây chúng ta sử dụng $block->getTitle() để lấy dữ liệu được trả về từ function getTitle đã được tạo ở bước trên. Bạn có thể viết thêm HTML vào file này.
Tiếp theo xóa cache của Magento để áp dụng các thay đổi bạn đã thực hiện:
php bin/magento cache:clean
Bước 4: Kiểm tra layout đã được hiển thị chưa
Truy cập vào controller của bạn trên trình duyệt. Trong bài viết này là https://example.com/helloworld/post/index. Nếu dòng chữ HelloWorld! được hiển thị thì chúc mừng bạn đã thành công rồi đấy.
 Sử dụng layout, block, templates trong Magento 2
Kết luận
Như vậy chúng ta đã tạo thành công layout sử dụng để in ra dòng chữ HelloWorld!, việc tạo layout ở backend cũng tương tự nhé, chỉ khác thư mục thôi. Và qua bài viết này chắc hẳn các bạn đã hiểu và biết cách sử dụng layout, block, template trong Magento 2 rồi phải không nào. Ở bài viết sau, tôi sẽ trình bày chi tiết hơn về layout trong Magento 2.
Xem thêm về view trong Magento 2 để biết thêm chi tiết: https://devdocs.magento.com/guides/v2.4/extension-dev-guide/view-models.html
 
Translate trong Magento 2
Magento 2 cho phép bạn bản địa hóa cửa hàng của mình bằng cách sử dụng các file .csv để dịch ngôn ngữ của cửa hàng sang các ngôn ngữ khác nhau. Trong bài viết này tôi sẽ hướng dẫn các bạn tìm hiểu về translate trong Magento 2.
Tạo file .csv
Phần này khá là đơn giản, bạn chỉ cần tạo một file .csv nằm trong thư mục i18n và khai báo các chuỗi bạn muốn dịch là xong. Điều các bạn cần chú ý ở đây là tên của file .csv chính là ngôn ngữ hiện tại của Magento.
VendorName/ModuleName/i18n/<locale_code>.csv
Muốn biết locale_code của các ngôn ngữ hiện tại bạn có thể vào Stores > Configuration > General > Locale Options. Sau đó nhấn chuột phải vào input select Locale và chọn Inspect. Bạn sẽ thấy mã HTML các options có value bằng local code như bên dưới:
 Locale code trong configuration (Translate trong Magento 2)
Ví dụ cửa hàng Magento của tôi ngôn ngữ đang là tiếng anh, và tôi muốn dịch chúng sang tiếng việt thì tôi sẽ tạo file en_US.csv trong module của tôi:
ViMagento/HelloWorld/i18n/en_US.csv

	 
'Translate', 'Dịch'
'Hello ViMagento', 'Xin chào ViMagento'
'Language', 'Ngôn ngữ'
 
Sử dụng Translate trong Magento 2
Để dịch được các chuỗi mà bạn sử dụng trong module của mình thì bắt buộc bạn phải sử dụng hàm dịch. Ví dụ trong file template của tôi có một vài chuỗi như sau:

	 
<p><?= __('Translate') ?></p>
<p><?= __('Hello ViMagento'); ?></p>
<p><?= 'Language' ?></p>
 
Và kết quả hiển thị trên trình duyệt sẽ là:
 Không sử dụng hàm dịch thì chuỗi sẽ không được dịch
Như bạn có thể thấy trong file template tôi đã sử dụng __() để dịch các chuỗi từ tiếng anh sang tiếng việt. Chuỗi Language không được sử dụng hàm __() nên sẽ không được dịch.
Translate làm việc như thế nào?
Khi gọi hàm __(‘Translate string’) Magento sẽ tìm bản dịch cho chuỗi Translate string bằng ngôn ngữ hiện tại. Ví dụ ngôn ngữ hiện tại đang là tiếng anh thì Magento sẽ tìm trong các file en_US.csv . Magento sẽ tìm bản dịch trong file .csv theo thứ tự sau:
▪	Bảng translation trong cơ sở dữ liệu
▪	Trong theme ( app/code/design/<Package>/<theme>/i18n/<locale_code>.csv)
▪	Trong module (app/code/<Vendor>/<Module>/i18n/<locale_code>.csv)
Khi một chuỗi phù hợp được tìm thấy thì Magento sẽ không tìm kiếm các chuỗi phù hợp khác nữa. Ngược lại nếu không tìm thấy chuỗi phù hợp nó sẽ lấy ngôn ngữ hiện tại. Chức năng translate đã được Magento làm rất tốt. Hàm __() là một hàm toàn cục và bạn có thể gọi nó ở bất cứ đâu mà không cần phải nhờ đến một class nào trợ giúp.
Kết luận
Trong bài viết tôi đã hướng dẫn các bạn sử dụng chức năng translate trong Magento 2. Phần này thì đơn giản nên các bạn chỉ cần thực hành là sẽ hiểu ngay. Cám ơn các bạn đã đọc bài.
 
Plugin trong Magento 2 – Hướng dẫn chi tiết
Trong quá trình làm việc với Magento 2, chắc chắn có lúc bạn sẽ muốn thay đổi hoặc mở rộng một chức năng có sẵn của Magento phải không nào. Vậy có cách nào để bạn có thể làm được điều đó nhưng không ảnh hưởng đến phương thức gốc của Magento không nhỉ. Magento hỗ trợ nhiều cách để làm được điều này, trong bài viết này tôi sẽ hướng dẫn các bạn một cách đó là sử dụng Plugin trong Magento 2.
Plugin là một class có thể sửa đổi hành vi của bất cứ một phương thức public nào bằng cách chặn lệnh gọi tới phương thức ban đầu và thực hiện logic của bạn. Điều này cho phép bạn mở rộng thậm chí là ghi đè lên phương thức public ban đầu mà không làm ảnh hưởng đến phương thức đó.
Hạn chế của Plugin
Plugin không thể sử dụng được với các trường hợp sau:
▪	Class hoặc phương thức Final
▪	Phương thức không phải public
▪	Virtual types
▪	__construct
▪	Class hoặc phương thức static
Khai báo một Plugin
Để khai báo một Plugin bạn phải tạo file di.xml trong module của bạn. Ở đây tôi sử dụng module ViMagento_HelloWorld. Nếu bạn chưa cài đặt module các bạn có thể xem lại bài viết này. Các bạn tạo file ViMagento/HelloWorld/etc/di.xml

	 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:ObjectManager/etc/config.xsd">
    <type name="{ObservedType}">
        <plugin name="{pluginName}" type="{PluginClassName}" sortOrder="1" disabled="false"/>
    </type>
</config>
 
Bạn phải xác định các thành phần sau:
▪	ObservedType: Một Class bạn muốn sửa đổi hoặc mở rộng
▪	pluginName: Tên của plugin của bạn nên đặt tên sao cho dễ hiểu, nói lên được chức năng plugin của bạn
▪	PluginClassName: Class plugin của bạn
▪	sortOrder: Thứ tự chạy của plugin. Số nhỏ sẽ chạy trước. Được sử dụng trong trường hợp có nhiều plugin tác động đến cùng một phương thức.
▪	disabled: Bật hoặc tắt plugin. True nếu bạn muốn tắt plugin. Mặc định là false
Quy ước đặt tên phương thức Plugin
Đầu tiên bạn cần xác định phương thức bạn muốn chỉnh sửa. Ví dụ ở đây tôi muốn chỉnh sửa phương thức getTitle()

 
    ...
    public function getTitle($title)
    {
        ...
    }
    ...
 
Để chỉnh sửa phương thức getTitle, bạn cần tạo các phương thức sau:
▪	beforeGetTitle
▪	aroundGetTitle
▪	afterGetTitle
Cũng đơn giản đúng không nào. Việc bạn cần làm đó là viết hoa chữ cái đầu của tên phương thức mà bạn muốn sửa đổi. Trường hợp phương thức có ‘_’ như _getTitle chẳng hạn thì bạn không cần viết hoa chữ cái đầu nữa. Ví dụ:
▪	before_getTitle
▪	around_getTitle
▪	after_getTitle
Phương thức before
Nghe tên thì các bạn cũng có thể đoán được cách nó hoạt động rồi đúng không nào. Phương thức before sẽ chạy trước phương thức mà nó sẽ tác động đến. Tên của nó phải trùng với tên của phương thức gốc và có tiền tố before ở phía trước. Ví dụ: beforeGetTitle
Bạn có thể sử dụng phương thức before đế thay đổi đối số đầu vào của phương thức gốc bằng cách trả về đối số đã sửa đổi. Nếu có nhiều hơn một đối số thì phương thức sẽ trả về một mảng các đối số. Còn nếu không có sửa đổi gì hãy trả về một giá trị null.

	 
<?php
namespace ViMagento\HelloWorld\Plugin;
 
class UpdateProductName
{
    public function beforeSetName(\Magento\Catalog\Model\Product $subject, $name)
    {
        $name = "HelloWorld";
        return [$name];
    }
}
 
Ở ví dụ trên tôi đã sửa đổi đối số $name thành dòng chữ HelloWorld và trả về cho phương thức gốc xử lý bằng phương thức before.
Phương thức after
Ngược lại với before phương thức after sẽ được chạy sau khi phương thức gốc đã chạy xong. Phương thức này bắt buộc phải có giá trị trả về và phải có tên trùng với phương thức gốc với tiền tố là after. Chúng ta có thể sử dụng phương thức after để thay đổi kết quả trả về của phương thức ban đầu bằng cách thay đổi nó và trả về giá trị đã thay đổi ở cuối phương thức.

	 
<?php
 
namespace ViMagento\HelloWorld\Plugin;
 
class UpdateProductName
{
    public function afterGetName(\Magento\Catalog\Model\Product $subject, $result)
    {
        $result = "HelloWorld";
        return $result;
    }
}
 
Ở ví dụ trên tôi đã thay đổi kết quả trả về bằng dòng chữ HelloWorld. Sau khi phương thức getName thực hiện xong nó sẽ truyền kết quả trả về ($result) và các đối số cho phương thức tiếp theo xử lý, ở đây là phương thức afterGetName của chúng ta.
Phương thức around
Phương thức around sẽ chạy trước và sau phương thức ban đầu. Nó cho phép bạn có thể sửa đối số đầu vào, kết quả trả về và thậm chí ghi đè lên phương thức ban đầu. Phương thức around phải có tên trùng với phương thức ban đầu và có tiền tố around.
Phương thức around có một điểm đặc biệt đó là callable. Nó sẽ nhận một callable có thể gọi đến phương thức tiếp theo trong chuỗi hoặc phương thức ban đầu. Nếu callable không được gọi thì tất cả các phương thức tiếp theo trong chuỗi sẽ không chạy.

 
<?php
 
namespace My\Module\Plugin;
 
class ProductAttributesUpdater
{
    public function aroundSave(\Magento\Catalog\Model\Product $subject, callable $proceed)
    {
        $someValue = $this->doSmthBeforeProductIsSaved();
        $returnValue = null;
 
        if ($this->canCallProceedCallable($someValue)) {
            $returnValue = $proceed();
        }
 
        if ($returnValue) {
            $this->postProductToFacebook();
        }
 
        return $returnValue;
    }
}
 
Ở ví dụ trên các bạn để ý sẽ thấy $returnValue = $proceed() đoạn này sẽ gọi đến phương thức tiếp theo trong chuỗi. Ví dụ có nhiều plugin cùng tác động đến phương thức save ở trên thì các plugin có thuộc tính sortOrder nhỏ sẽ chạy trước. Khi nó gọi đến callable $proceed đồng nghĩa với việc gọi đến plugin tiếp theo trong chuỗi. Còn nếu bạn không gọi $proceed thì tất cả phương thức phía sau sẽ không được chạy.
Kết luận
Tóm lại plugin có thể thay đổi hành vi của các function public. Cả ba phương thức đều có đối số đầu tiên là $subject để cung cấp quyền truy cập vào tất cả các phương thức public có trong $subject. Và plugin có ba loại:
▪	before: Thay đổi đối số đầu vào
▪	after: Thay đổi kết quả trả về
▪	around: có thể thay đổi đối số đầu vào, kết quả trả về và ghi đè lên phương thức gốc.
Trường hợp có nhiều plugin cùng tác động lên một phương thức thì thứ tự của plugin chạy theo thuộc tính sortOrder. Nhưng nếu không có thuộc tính sortOrder thì nó sẽ chạy theo thứ tự load của module nhé. Để xem thứ tự load của module các bạn có thể xem trong file app/etc/config.php
Bài viết này chúng ta đã cùng nhau tìm hiểu cách sử dụng plugin cơ bản trong Magento 2, trong bài tiếp theo tôi sẽ hướng dẫn các bạn cách thay đổi tên của sản phẩm sử dụng plugin để các bạn có được cái nhìn tổng quan hơn về plugin trong Magento 2 hoạt động như thế nào nhé !
Tài liệu để các bạn tham khảo thêm: https://devdocs.magento.com/guides/v2.4/extension-dev-guide/plugins.html
 
Magento 2 thay đổi tên product sử dụng Plugin
bởi Admin 16/08/2020 0 Bình luận 157 xem
Để các bạn có một cái nhìn nhìn tổng quan hơn về cách Plugin hoạt động trong Magento 2. Hôm nay mình sẽ hướng dẫn các bạn sử dụng Plugin để thay đổi tất cả tên của sản phẩm trong Magento 2. Bài viết này chỉ phù hợp với các bạn đang tìm hiểu về Magento thôi nhé.
Bước 1: Tạo một plugin
Đầu tiên các bạn phải xác định phương thức mà bạn muốn thay đổi. Ở đây tôi muốn thay đổi tên của sản phẩm sẽ hiển thị ở frontend. Và tôi tìm thấy phương thức getName trong class Magento\Catalog\Model\Product sẽ chịu trách nhiệm lấy tên sản phẩm và hiển thị nên tôi sẽ sử dụng plugin để thay đổi kết quả trả về của phương thức getName và thay đổi thành dòng chữ Vi-Magento HelloWorld. Tôi sẽ sử dụng lại module ViMagento_HelloWorld, các bạn có thể xem tại đây. Hiện tại project của tôi có ba sản phẩm như hình bên dưới:
 
ViMagento/HelloWorld/etc/di.xml
	 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:ObjectManager/etc/config.xsd">
    <type name="Magento\Catalog\Model\Product">
        <plugin name="vimagento_helloworld_update_product_name" type="ViMagento\HelloWorld\Plugin\UpdateProductName" />
    </type>
</config>
 
Bước 2: Tạo Plugin để xử lý
Các bạn tạo file ViMagento/HelloWorld/Plugin/UpdateProductName.php mình sẽ thay đổi kết quả trả về thành dòng chữ Vi-Magento HelloWorld .
	 
<?php
 
namespace ViMagento\HelloWorld\Plugin;
 
class UpdateProductName
{
    public function afterGetName(\Magento\Catalog\Model\Product $subject, $result)
    {
        $result = "Vi-Magento HelloWorld";
        return $result;
    }
}
 
Và kết quả là tất cả sản phẩm đều sẽ hiển thị với tên Vi-Magento HelloWorld ở frontend
 
Nếu bạn muốn tìm hiểu thêm về plugin có thể xem lại bài viết trước về before, around và after nhé.
 
Tạo bảng trong Magento 2 với Setup script
Trong một vài trường hợp có lẽ bạn sẽ muốn cập nhật cơ sở dữ liệu, thêm một bảng mới hoặc thêm một vài field trong product form… Để làm được điều này, setup script có thể giúp được bạn. Trong bài viết này chúng ta sẽ tìm hiểu cách làm việc với các tập lệnh install và upgrade cũng như cách để tạo bảng trong Magento 2 với các tập lệnh setup script.
Tổng quan
▪	InstallSchema: Tập lệnh này sẽ chạy khi lần đầu cài đặt module được dùng để thiết lập cấu trúc database
▪	InstallData: Tập lệnh này sẽ chạy khi lần đầu cài đặt module được dùng để khởi tạo dữ liệu cho một bảng trong database
▪	UpgradeSchema: Tập lệnh này sẽ chạy khi nâng cấp module được dùng để thiết lập cấu trúc database
▪	UpgradeData: Tập lệnh này sẽ chạy khi nâng cấp module được dùng để khởi tạo dữ liệu cho một bảng trong database
▪	Recurring
▪	Uninstall
Trong bài viết này tôi sẽ hướng dẫn các bạn tạo table mới trong cơ sở dữ liệu và tôi sử dụng module ViMagento_HelloWorld để làm việc
Chúng sẽ được đặt trong thư mục ViMagento/HelloWorld/Setup. Cả bốn file này đều cần phải chạy câu lệnh sau để có thể chạy php bin/magento setup:upgrade
Install Script: InstallSchema & InstallData
Tập lệnh InstallSchema & InstallData được chạy trong quá trình cài đặt module. Tập lệnh bên dưới dùng để tạo table vimagento_helloworld_post
File: ViMagento/HelloWorld/Setup/InstallSchema.php
 
<?php
 
namespace ViMagento\HelloWorld\Setup;
 
class InstallSchema implements \Magento\Framework\Setup\InstallSchemaInterface
{
    public function install(\Magento\Framework\Setup\SchemaSetupInterface $setup, \Magento\Framework\Setup\ModuleContextInterface $context)
    {
        $installer = $setup;
        $installer->startSetup();
        if (!$installer->tableExists('vimagento_helloworld_post')) {
            $table = $installer->getConnection()->newTable(
                $installer->getTable('vimagento_helloworld_post')
            )
                ->addColumn(
                    'post_id',
                    \Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
                    null,
                    [
                        'identity' => true,
                        'nullable' => false,
                        'primary' => true,
                        'unsigned' => true,
                    ],
                    'Post ID'
                )
                ->addColumn(
                    'name',
                    \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
                    255,
                    ['nullable => false'],
                    'Post Name'
                )
                ->addColumn(
                    'post_content',
                    \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
                    '64k',
                    [],
                    'Post Post Content'
                )
                ->addColumn(
                    'status',
                    \Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
                    1,
                    [],
                    'Post Status'
                )
 
                ->addColumn(
                    'created_at',
                    \Magento\Framework\DB\Ddl\Table::TYPE_TIMESTAMP,
                    null,
                    ['nullable' => false, 'default' => \Magento\Framework\DB\Ddl\Table::TIMESTAMP_INIT],
                    'Created At'
                )
                ->setComment('Post Table');
            $installer->getConnection()->createTable($table);
 
            $installer->getConnection()->addIndex(
                $installer->getTable('vimagento_helloworld_post'),
                $setup->getIdxName(
                    $installer->getTable('vimagento_helloworld_post'),
                    ['name', 'post_content'],
                    \Magento\Framework\DB\Adapter\AdapterInterface::INDEX_TYPE_FULLTEXT
                ),
                ['name', 'post_content'],
                \Magento\Framework\DB\Adapter\AdapterInterface::INDEX_TYPE_FULLTEXT
            );
        }
        $installer->endSetup();
    }
}
 
Class trên tôi đã tạo table vimagento_helloworld_post với các column post_id, name, post_content, status, created_at
InstallData sẽ chạy sau InstallSchema để thêm dữ liệu vào database table
ViMagento/HelloWorld/Setup/InstallData.php
	 
<?php
 
namespace ViMagento\HelloWorld\Setup;
 
use Magento\Framework\Setup\InstallDataInterface;
use Magento\Framework\Setup\ModuleContextInterface;
use Magento\Framework\Setup\ModuleDataSetupInterface;
 
class InstallData implements InstallDataInterface
{
    protected $_postFactory;
 
    public function __construct(\ViMagento\HelloWorld\Model\PostFactory $postFactory)
    {
        $this->_postFactory = $postFactory;
    }
 
    public function install(ModuleDataSetupInterface $setup, ModuleContextInterface $context)
    {
        $data = [
            'name'         => "Magento 2 thêm dữ liệu vào bảng vimagento_helloworld_post",
            'post_content' => "Content.",
            'status'       => 1
        ];
        $post = $this->_postFactory->create();
        $post->addData($data)->save();
    }
}
 
Lưu ý Install Script chỉ chạy khi lần đầu cài đặt module vì thế module của bạn đã được cài đặt rồi thì các bạn xóa module trong table setup_module đi nhé. Khi thực hiện xong các bạn chạy câu lệnh php bin/magento setup:upgrade để cài đặt và kết quả sẽ như hình bên dưới
 Thêm dữ liệu vào bảng với InstallData.php
Upgrade Script: UpgradeSchema & UpgradeData
Upgrade script sẽ được chạy khi cài đặt hoặc nâng cấp module. Nó khác với Install script đó là nó sẽ chạy mỗi khi nâng cấp module.Vì vậy chúng ta cần phải kiểm tra thuộc tính setup_version trong module.xml
	 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Module/etc/module.xsd">
    <module name="ViMagento_HelloWorld" setup_version="1.0.0">
        <sequence>
            <module name="Magento_Catalog"/>
        </sequence>
    </module>
</config>
 
 
▪	UpgradeSchema: ViMagento/HelloWorld/Setup/UpgradeSchema.php

	 
<?php
 
namespace ViMagento\HelloWorld\Setup;
 
use Magento\Framework\Setup\UpgradeSchemaInterface;
use Magento\Framework\Setup\SchemaSetupInterface;
use Magento\Framework\Setup\ModuleContextInterface;
 
class UpgradeSchema implements UpgradeSchemaInterface
{
    public function upgrade( SchemaSetupInterface $setup, ModuleContextInterface $context ) {
        $installer = $setup;
 
        $installer->startSetup();
 
        if(version_compare($context->getVersion(), '1.0.1', '<')) {
            $installer->getConnection()->addColumn(
                $installer->getTable( 'vimagento_helloworld_post' ),
                'add_column',
                [
                    'type' => \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
                    'nullable' => true,
                    'comment' => 'Add a column',
                    'after' => 'name'
                ]
            );
        }
        $installer->endSetup();
    }
}
 
Tập lệnh trên sẽ thêm một column vào table vimagento_helloworld_post vào sau column có tên là name
▪	Upgrade Data: ViMagento/HelloWorld/Setup/UpgradeData.php
	 
<?php
 
namespace ViMagento\HelloWorld\Setup;
 
use Magento\Framework\Setup\UpgradeSchemaInterface;
use Magento\Framework\Setup\SchemaSetupInterface;
use Magento\Framework\Setup\ModuleContextInterface;
 
class UpgradeSchema implements UpgradeSchemaInterface
{
    public function upgrade( SchemaSetupInterface $setup, ModuleContextInterface $context ) {
        $installer = $setup;
 
        $installer->startSetup();
 
        if(version_compare($context->getVersion(), '1.0.1', '<')) {
            $installer->getConnection()->addColumn(
                $installer->getTable( 'vimagento_helloworld_post' ),
                'add_column',
                [
                    'type' => \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
                    'nullable' => true,
                    'comment' => 'Add a column',
                    'after' => 'name'
                ]
            );
        }
        $installer->endSetup();
    }
}
 
Trong file Upgrade script sẽ có một function để so sánh version hiện tại của module. Các bạn phải nâng version trong module.xml lên. Hiện tại đang là 1.0.0 nên tôi nâng lên 1.0.1 nhé. Sau đó tiến hành chạy câu lệnh nâng cấp module và đây là kết quả.
 Thêm dữ liệu vào bảng với UpgradeData.php
Recurring Script
Recurring Script là một tập lệnh được chạy sau  setup script mỗi khi câu lệnh php bin/magento setup:upgrade được chạy. Tập lệnh này cũng tương tự như InstallSchema nhưng khác tên class. Ví dụ: ViMagento/HelloWorld/Setup/Recurring.php
Uninstall Script
Magento 2 cung cấp tính năng xóa bảng, dữ liệu. Ví dụ: ViMagento/HelloWorld/Setup/Uninstall.php

<?php
 
namespace ViMagento\HelloWorld\Setup;
 
use Magento\Framework\Setup\UninstallInterface;
use Magento\Framework\Setup\SchemaSetupInterface;
use Magento\Framework\Setup\ModuleContextInterface;
 
class Uninstall implements UninstallInterface
{
    public function uninstall(SchemaSetupInterface $setup, ModuleContextInterface $context)
    {
        $installer = $setup;
        $installer->startSetup();
 
        $installer->getConnection()->dropTable($installer->getTable('vimagento_helloworld_post'));
 
        $installer->endSetup();
    }
}
 
Tập lệnh trên sẽ xóa table vimagento_helloworld_post mà chúng ta đã tạo. Ngoài ra vẫn còn cách khác để tạo table trong magento 2.3 trở lên sẽ được giới thiệu trong các bài viết tiếp theo.
Kết luận
Tôi vừa hướng dẫn các bạn tạo bảng trong Magento 2 cũng như cách làm việc với các tập lệnh setup script cơ bản. Nếu có gì thắc các bạn đừng ngại cứ để lại bình luận bên dưới.
Bài viết để các bạn tham khảo: https://devdocs.magento.com/videos/fundamentals/add-a-new-table-to-database/
 
Tạo bảng với db_schema.xml trong Magento 2
Kể từ phiên bản Magento 2.3, có một tính năng rất hay và quan trọng trong việc cài đặt và nâng cấp database được gọi là Declarative Schema(db_schema.xml). Các phiên bản trước Magento 2.3 khi chúng ta muốn tạo mới một bảng hoặc cập nhật cấu trúc của bảng chúng ta phải làm việc thông qua PHP Script đã được giới thiệu ở bài trước. Ở bài viết này chúng ta sẽ cùng nhau tìm hiểu về cách tạo bảng với db_schema.xml
Cùng ôn lại bài trước một chút nhé:
▪	InstallData và InstallSchema: được thực thi lần đầu khi module được cài đặt
▪	UpgradeData và UpgradeSchema: cập nhật cấu trúc có sẵn, thực thi khi cài đặt và nâng cấp module
Trong quá trình cài đặt và nâng cấp, Upgrade script chỉ thực hiện những thay đổi chưa áp dụng. Nhược điểm của phương pháp này là Magento áp dụng nó một cách mù quáng. Ví dụ bạn có một cột trong bảng cơ sở dữ liệu và bạn muốn xóa nó thì bạn chỉ có thể thực hiện điều đó trong lần nâng cấp tiếp theo bằng cách nâng version của module và thực hiện lại. db_schema.xml trong Magento 2 sẽ loại bỏ công việc không cần thiết này.
db_schema.xml trong Magento 2 làm việc dựa trên cấu trúc cơ sở dữ liệu, Magento sẽ tự xác định sự khác nhau giữa cấu trúc hiện tại và trước đó và biết nên làm thế nào. Schema file được ưu tiên và thực thi trước setup scripts.
Đầu tiên muốn tạo một bảng trong database các bạn cần tạo một file vendor/module/etc/db_schema.xml . Bên dưới là ví dụ về db_schema.xml trong module catalog được dùng để tạo bảng catalog_product_entity
	 
<?xml version="1.0"?>
<!--
/**
 * Copyright © Magento, Inc. All rights reserved.
 * See COPYING.txt for license details.
 */
-->
<schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="urn:magento:framework:Setup/Declaration/Schema/etc/schema.xsd">
<table name="catalog_product_entity" resource="default" engine="innodb" comment="Catalog Product Table">
        <column xsi:type="int" name="entity_id" padding="10" unsigned="true" nullable="false" identity="true"
                comment="Entity ID"/>
        <column xsi:type="smallint" name="attribute_set_id" padding="5" unsigned="true" nullable="false"
                identity="false" default="0" comment="Attribute Set ID"/>
        <column xsi:type="varchar" name="type_id" nullable="false" length="32" default="simple" comment="Type ID"/>
        <column xsi:type="varchar" name="sku" nullable="true" length="64" comment="SKU"/>
        <column xsi:type="smallint" name="has_options" padding="6" unsigned="false" nullable="false" identity="false"
                default="0" comment="Has Options"/>
        <column xsi:type="smallint" name="required_options" padding="5" unsigned="true" nullable="false"
                identity="false" default="0" comment="Required Options"/>
        <column xsi:type="timestamp" name="created_at" on_update="false" nullable="false" default="CURRENT_TIMESTAMP"
                comment="Creation Time"/>
        <column xsi:type="timestamp" name="updated_at" on_update="true" nullable="false" default="CURRENT_TIMESTAMP"
                comment="Update Time"/>
        <constraint xsi:type="primary" referenceId="PRIMARY">
            <column name="entity_id"/>
        </constraint>
        <index referenceId="CATALOG_PRODUCT_ENTITY_ATTRIBUTE_SET_ID" indexType="btree">
            <column name="attribute_set_id"/>
        </index>
        <index referenceId="CATALOG_PRODUCT_ENTITY_SKU" indexType="btree">
            <column name="sku"/>
        </index>
    </table>
</schema>
Thẻ table
Mỗi file db_schema.xml chứa một hoặc nhiều thẻ table, mỗi thẻ table chịu trách nhiệm tạo một bảng trong database.
	 
<table name="catalog_product_entity" resource="default" engine="innodb" comment="Catalog Product Table">
      ...
 </table>
 
▪	name: Tên của bảng
▪	resource: Nên là default, checkout hoặc sales.
▪	engine: Nên là innodb hoặc memory.
▪	comment: Ghi chú
Thẻ column
Mỗi thẻ column sẽ định nghĩa một cột trong bảng và sẽ có các khai báo riêng.

 
<column xsi:type="int" name="entity_id" padding="10" unsigned="true" nullable="false" identity="true"
               comment="Entity ID"/>
 
 
▪	xsi:type : Loai dữ liệu của cột(varchar, varbinary, timestamp, text, int, smallint, real, float, decimal, datetime, date, boolean, blob)
▪	default: Khởi tạo column với giá trị mặc định, lưu ý giá trị mặc định phải có cùng kiểu dữ liệu với xsi:type
▪	disabled: Vô hiệu hóa hoặc xóa column đã khai báo.
▪	identity: Khởi tạo là true nếu bạn muốn giá trị của column tự động tăng, thường được dùng cho column là khóa chính
▪	length: Xác định độ dài của column. Thường được dùng cho các loại dữ liệu varchar, char, varbinary
▪	nullable: Xác định một column có thể null hay không
▪	onCreate: Di chuyển dữ liệu của column hiện tại sang column mới tạo. Chỉ hoạt động khi một column được tạo
▪	padding: Độ dài của column, sử dụng cho integer
▪	unsigned: Nếu là true thì chỉ cho phép giá trị dương, ngược lại thì cho phép cả dữ liệu âm và dương
Thẻ constraint
▪	Tạo khóa chính

 
<constraint xsi:type="primary" referenceId="PRIMARY">
            <column name="action_id"/>
 </constraint>
 
▪	Tạo khóa ngoại
	 
<constraint xsi:type="foreign" referenceId="CAT_PRD_FRONTEND_ACTION_CSTR_ID_CSTR_ENTT_ENTT_ID"
                    table="catalog_product_frontend_action" column="customer_id" referenceTable="customer_entity"
                    referenceColumn="entity_id" onDelete="CASCADE"/>
 
▪	Trong đó:
▪	xsi:type: primary, unique hoặc foreign
▪	referenceId: Tên của khóa
▪	table: Bảng hiện tại
▪	column: Column của bảng hiện tại
▪	referenceTable: Bảng được tham chiếu đến
▪	referenceColumn: Column của bảng được tham chiếu đến
▪	onDelete: Giá trị phải là CASCADE, SET NULL hoặc NO ACTION
Tạo một table
	 
<schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xsi:noNamespaceSchemaLocation="urn:magento:framework:Setup/Declaration/Schema/etc/schema.xsd">
+    <table name="declarative_table">
+        <column xsi:type="int" name="id_column" padding="10" unsigned="true" nullable="false" comment="Entity Id"/>
+        <column xsi:type="int" name="severity" padding="10" unsigned="true" nullable="false" comment="Severity code"/>
+        <column xsi:type="varchar" name="title" nullable="false" length="255" comment="Title"/>
+        <column xsi:type="timestamp" name="time_occurred" padding="10" comment="Time of event"/>
+        <constraint xsi:type="primary" referenceId="PRIMARY">
+            <column name="id_column"/>
+        </constraint>
+    </table>
</schema>
 
Xóa một table

 
<schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xsi:noNamespaceSchemaLocation="urn:magento:framework:Setup/Declaration/Schema/etc/schema.xsd">
-    <table name="declarative_table">
-        <column xsi:type="int" name="id_column" padding="10" unsigned="true" nullable="false" comment="Entity Id"/>
-        <column xsi:type="int" name="severity" padding="10" unsigned="true" nullable="false" comment="Severity code"/>
-        <column xsi:type="varchar" name="title" nullable="false" length="255" comment="Title"/>
-        <column xsi:type="timestamp" name="time_occurred" padding="10" comment="Time of event"/>
-        <constraint xsi:type="primary" referenceId="PRIMARY">
-            <column name="id_column"/>
-        </constraint>
-    </table>
</schema>
 
Đổi tên một table
	 
<schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xsi:noNamespaceSchemaLocation="urn:magento:framework:Setup/Declaration/Schema/etc/schema.xsd">
+    <table name="new_declarative_table" onCreate="migrateDataFromAnotherTable(declarative_table)">
-    <table name="declarative_table">
        <column xsi:type="int" name="id_column" padding="10" unsigned="true" nullable="false" comment="Entity Id"/>
        <column xsi:type="int" name="severity" padding="10" unsigned="true" nullable="false" comment="Severity code"/>
        <column xsi:type="varchar" name="title" nullable="false" length="255" comment="Title"/>
        <column xsi:type="timestamp" name="time_occurred" padding="10" comment="Time of event"/>
        <constraint xsi:type="primary" referenceId="PRIMARY">
            <column name="id_column"/>
        </constraint>
    </table>
</schema>
 
Thêm một column

	 
<schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xsi:noNamespaceSchemaLocation="urn:magento:framework:Setup/Declaration/Schema/etc/schema.xsd">
    <table name="declarative_table">
        <column xsi:type="int" name="id_column" padding="10" unsigned="true" nullable="false" comment="Entity Id"/>
        <column xsi:type="int" name="severity" padding="10" unsigned="true" nullable="false" comment="Severity code"/>
        <column xsi:type="varchar" name="title" nullable="false" length="255" comment="Title"/>
        <column xsi:type="timestamp" name="time_occurred" padding="10" comment="Time of event"/>
+       <column xsi:type="timestamp" name="date_closed" padding="10" comment="Time of event"/>
        <constraint xsi:type="primary" referenceId="PRIMARY">
            <column name="id_column"/>
        </constraint>
    </table>
</schema>
 
Xóa một column
	 
<schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xsi:noNamespaceSchemaLocation="urn:magento:framework:Setup/Declaration/Schema/etc/schema.xsd">
    <table name="declarative_table">
        <column xsi:type="int" name="id_column" padding="10" unsigned="true" nullable="false" comment="Entity Id"/>
        <column xsi:type="int" name="severity" padding="10" unsigned="true" nullable="false" comment="Severity code"/>
        <column xsi:type="varchar" name="title" nullable="false" length="255" comment="Title"/>
        <column xsi:type="timestamp" name="time_occurred" padding="10" comment="Time of event"/>
-       <column xsi:type="timestamp" name="date_closed" padding="10" comment="Time of event"/>
        <constraint xsi:type="primary" referenceId="PRIMARY">
            <column name="id_column"/>
        </constraint>
    </table>
</schema>
 
Thay đổi kiểu dữ liệu của một column
	 
<schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xsi:noNamespaceSchemaLocation="urn:magento:framework:Setup/Declaration/Schema/etc/schema.xsd">
    <table name="declarative_table">
        <column xsi:type="int" name="id_column" padding="10" unsigned="true" nullable="false" comment="Entity Id"/>
        <column xsi:type="int" name="severity" padding="10" unsigned="true" nullable="false" comment="Severity code"/>
-       <column xsi:type="varchar" name="title" nullable="false" length="255" comment="Title"/>
+       <column xsi:type="text" name="title" nullable="false" comment="Title"/>
        <column xsi:type="timestamp" name="time_occurred" padding="10" comment="Time of event"/>
        <constraint xsi:type="primary" referenceId="PRIMARY">
            <column name="id_column"/>
        </constraint>
    </table>
</schema>
 
Thêm một Index
	 
<schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xsi:noNamespaceSchemaLocation="urn:magento:framework:Setup/Declaration/Schema/etc/schema.xsd">
    <table name="declarative_table">
        <column xsi:type="int" name="id_column" padding="10" unsigned="true" nullable="false" comment="Entity Id"/>
        <column xsi:type="int" name="severity" padding="10" unsigned="true" nullable="false" comment="Severity code"/>
        <column xsi:type="text" name="title" nullable="false" length="255" comment="Title"/>
        <column xsi:type="timestamp" name="time_occurred" padding="10" comment="Time of event"/>
        <constraint xsi:type="primary" referenceId="PRIMARY">
            <column name="id_column"/>
        </constraint>
+       <index referenceId="INDEX_SEVERITY" indexType="btree">
+           <column name="severity"/>
+       </index>
    </table>
</schema>
 
 
Cuối cùng chạy câu lệnh bên dưới để tạo file db_schema_whitelist.json
	 
php bin/magento setup:db-declaration:generate-whitelist --module-name=Vendor_Module
php bin/magento setup:upgrade
 
File này sẽ cung cấp lịch sử tất cả table, column được thêm bằng declarative schema trong module.
Kết luận
Vậy là chúng ta đã cùng nhau tìm hiểu cách tạo bảng với db_schema.xml trong Magento 2. Để tìm hiểu chi tiết hơn các bạn có thể đọc thêm devdocs của Magento: https://devdocs.magento.com/guides/v2.4/extension-dev-guide/declarative-schema/db-schema.html
 
Hướng dẫn cài đặt xdebug cho phpstorm trên ubuntu
Những ai đang làm việc với magento chắc chắn đã hiểu được tầm quan trọng của việc debug trong quá trình xây dựng và phát triển ứng dụng rồi phải không nào. Mình đã làm việc với magento 2 và mình cảm thấy mình chẳng thể làm việc được với nó nếu không có debug, còn ai mà làm được thì người đó đã ở 1 cái trình khác rồi nhé. Trong bài viết này mình sẽ hướng dẫn các bạn cài đặt và sử dụng xdebug cho phpstorm. Ở đây mình cài đặt trên Ubuntu 18.04 nhé !
Cài đặt Xdebug
Bạn cũng có thể truy cập vào trang chủ của xdebug và làm theo hướng dẫn nhé.
Đầu tiên các bạn kiểm tra phpinfo bằng câu lệnh php -v xem xdebug đã được cài đặt chưa.
 Hướng dẫn cài đặt xdebug cho phpstorm trên ubuntu
Nếu chưa cài đặt xdebug các bạn chạy câu lệnh sau:
	 
sudo apt-get install php-xdebug
 
Sau khi đã cài đặt thành công xdebug các bạn thêm vào file /etc/php/7.x/mods-available/xdebug.ini như bên dưới.
	 
zend_extension=xdebug.so
xdebug.remote_enable=1
xdebug.remote_handler=dbgp
xdebug.remote_mode=req
xdebug.remote_host=localhost
xdebug.remote_port=9000
xdebug.var_display_max_depth = -1
xdebug.var_display_max_children = -1
xdebug.var_display_max_data = -1
xdebug.idekey = "PHPSTORM"
 
Chú ý: Option xdebug.remote_port là port sẽ lắng nghe, mặc định là 9000, nếu port 9000 đã được sử dụng thì hay bằng 10000. Sau đó các bạn lưu thay đổi, khởi động lại webserver của mình và kiểm tra xem phpinfo xem xdebug đã được cài đặt thành công chưa nhé.
Cấu hình phpstorm sử dụng Xdebug
Cài đặt phpstorm tại đây hoặc chạy câu lệnh bên dưới:
	 
sudo snap install phpstorm --classic phpstorm
 
Mở phpstorm vừa cài đặt Chọn File -> Settings -> Languages & Frameworks -> PHP -> Debug. Trong mục Xdebug, điền đúng Xdebug port đã cấu hình ở file xdebug.ini và lưu lại.
 Hướng dẫn cài đặt xdebug cho phpstorm trên ubuntu
Cài đặt xdebug helper extension trên browser
Tùy theo trình duyệt chrome hay firefox sẽ có extension khác nhau. Đối với trình duyệt chrome các bạn có thể download tại đây.
 Cài đặt xdebug extension trên browser
Tiến hành debug
Sau khi tất cả đã cài đặt thành công, bước cuối cùng sẽ là tiến hành debug. Để debug được vào phpstorm các bạn phải bật xdebug bằng cách nhấn vào biểu tượng của debug ở góc trên cùng bên phải trong phpstorm như hình bên dưới.
 Bật xdebug trên phpstorm
Và bật xdebug ở trình duyệt mà ban nãy bạn vừa cài đặt:
 Bật xdebug extension trên browser
Và cuối cùng là tiến hành tick chọn dòng code mà bạn muốn debug.
 Tick chọn dòng code mà bạn muốn debug
Và kết quả như mong đợi.
 cài đặt xdebug cho phpstorm thành công
Kết luận
Vừa rồi tôi vừa hướng dẫn các bạn cài đặt xdebug cho phpstorm trên ubuntu. Hy vọng bài viết có thể giúp ích cho các bạn trong việc cài đặt xdebug phục vụ cho việc debug vào Magento 2 trong các bài sau.
 
Model, Resource Model và Collection trong Magento 2
Models là một phần quan trọng trong mô hình MVC. Trong Magento 2 Models sẽ chịu trách nhiệm làm việc với database, và được chia thành ba phần là Model, Resource Model và Collection. Được sử dụng để làm việc với các hoạt động CRUD(create, read, update, delete), bạn không cần phải viết bất kỳ một dòng code SQL nào nữa.
Trước khi đi vào nội dung chính của bài viết, tôi sẽ tạo một bảng có tên helloworld_post nằm trong module ViMagento_HelloWorld với các column như sau:
▪	post_id: khóa chính và tự động tăng
▪	name
▪	status
▪	content
▪	created_at
Đầu tiên tạo file ViMagento/HelloWorld/etc/db_schema.xml
 
<?xml version="1.0"?>
<!--
/**
 * Copyright © Magento, Inc. All rights reserved.
 * See COPYING.txt for license details.
 */
-->
<schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Setup/Declaration/Schema/etc/schema.xsd">
    <table name="helloworld_post" resource="default" engine="innodb" comment="Post Table">
        <column xsi:type="int" name="post_id" padding="10" unsigned="true" nullable="false" identity="true" comment="Post ID"/>
        <column xsi:type="varchar" name="name" nullable="false" length="255" default="simple" comment="Post Name"/>
        <column xsi:type="int" name="status" nullable="false" padding="10" comment="Post Status"/>
        <column xsi:type="text" name="content" nullable="false" comment="Post Content"/>
        <column xsi:type="timestamp" name="created_at" on_update="true" nullable="false" default="CURRENT_TIMESTAMP" comment="Created Time"/>
        <constraint xsi:type="primary" referenceId="PRIMARY"><column name="post_id"/>
        </constraint>
        <index referenceId="POST_HELLOWORLD_ATTRIBUTE_SET_ID" indexType="btree">
            <column name="post_id"/>
        </index>
    </table>
</schema>
 
Sau đó chạy câu lệnh php bin/magento setup:upgrade để tạo bảng
Tạo Model trong Magento 2
Tạo file: ViMagento/HelloWorld/Model/Post.php
	 
<?php
 
namespace ViMagento\HelloWorld\Model;
 
class Post extends \Magento\Framework\Model\AbstractModel
{
    protected function _construct()
    {
        $this->_init('ViMagento\HelloWorld\Model\ResourceModel\Post');
    }
}
 
Một Model thì sẽ extends class AbstractModel và nó gọi phương thức _init và truyền vào một Resource Model như là một đối số để lấy thông tin từ cơ sở dữ liệu. Model sẽ làm việc với cơ sở dữ liệu thông qua resource model.
Tạo Resource Model trong Magento 2
Tạo file: ViMagento/HelloWorld/Model/ResourceModel/Post.php
	 
<?php
 
namespace ViMagento\HelloWorld\Model\ResourceModel;
 
class Post extends \Magento\Framework\Model\ResourceModel\Db\AbstractDb
{
    protected function _construct()
    {
        $this->_init('helloworld_post', 'post_id');
    }
}
 
Resource Model sẽ extends class AbstractDb, gọi phương thức _init và truyền vào hai đối số là tên bảng của bạn và khóa chính của bảng. Model sẽ chứa logic tổng thể làm việc với database, nó không thực thi bất kì câu lệnh truy vấn SQL nào cả mà Resource Model sẽ làm điều đó. Resource Model sẽ làm việc trực tiếp với database CRUD(create, read, update, delete).
Tạo Collection trong Magento 2
Tạo file: ViMagento/HelloWorld/Model/ResourceModel/Post/Collection.php
	 
<?php
 
namespace ViMagento\HelloWorld\Model\ResourceModel\Post;
 
class Collection extends \Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection
{
    protected $_idFieldName = 'post_id';
 
    protected function _construct()
    {
        $this->_init('ViMagento\HelloWorld\Model\Post', 'ViMagento\HelloWorld\Model\ResourceModel\Post');
    }
}
 
Collection phải extends class AbstractCollection và truyền vào phương thức _init hai đối số là model và resource model chúng ta vừa tạo.
Cách sử dụng Model
Vừa rồi chúng ta đã cùng nhau tạo model, resource model và collection cho bảng helloworld_post. Vậy làm sao để sử dụng chúng nhỉ. Trong PHP hướng đối tượng phương thức Factory sẽ khởi tạo đối tượng thì trong Magento cũng tương tự như vậy. Để sử dụng model chúng ta thêm Factory vào sau tên class. Ví dụ: PostFactory. Bạn không cần phải tạo class PostFactory nhé vì Magento sẽ tự động tạo nó cho bạn và được đặt trong thư mục generated. Trông như Magento đã tạo ra một bản nháp để làm việc ấy.
Để lấy một ví dụ thực tế mình sẽ tạo một controller và show dữ liệu ra ngoài màn hình nhé.
Tạo file: ViMagento/HelloWorld/Controller/Post/Index.php
 
<?php
 
namespace ViMagento\HelloWorld\Controller\Post;
 
class Index extends \Magento\Framework\App\Action\Action
{
    protected $postFactory;
 
    public function __construct(
        \Magento\Framework\App\Action\Context $context,
        \ViMagento\HelloWorld\Model\PostFactory $postFactory
    )
    {
        $this->postFactory = $postFactory;
        return parent::__construct($context);
    }
 
    public function execute()
    {
        $data = $this->postFactory->create()->getCollection();
        foreach ($data as $value) {
            echo "<pre>";
            print_r($value->getData());
            echo "</pre>";
        }
    }
}
 
Đây là dữ liệu trong bảng helloworld_post
 Sử dụng model, resource model và collection để thao tác với dữ liệu trong Magento 2
Và khi truy cập vào đường dẫn đến controller vừa tạo ta sẽ lấy được dữ liệu có trong bảng helloworld_post. Cũng đơn giản phải không nào. example.com/helloworld/post/index
 Sử dụng model, resource model và collection để thao tác với dữ liệu trong Magento 2
Kết luận
▪	Model: Chứa logic tổng thể làm việc với database thông qua resource model
▪	Resource model: Làm việc trực tiếp với database (CRUD)
▪	Collection: Có thể get một tập hợp model. được sử dụng khi bạn muốn lấy nhiều dòng dữ liệu. Model chỉ có thể load 1 record thôi nhé.
▪	Factory: Magento sẽ tự động tạo một class trong generated, các bạn cứ hiểu là Magento sẽ tạo một bản nháp và làm việc với nó. Ví dụ: PostFactory, CollectionFactory…
 
Data Patch trong Magento 2 – Hướng dẫn chi tiết
bởi Admin 19/08/2020 0 Bình luận 176 xem
Kể từ phiên bản 2.3, Magento giới thiệu Data Patch để sửa đổi dữ liệu như là một thay thế cho InstallData và UpgradeData. Một Data Patch được đặt trong Vendor/Module_Name/Setup/Patch/Data/Patch_Name.php và implements \Magento\Framework\Setup\Patch\DataPatchInterface. Trong bài viết này chúng ta sẽ cùng nhau đi tìm hiểu về cách sử dụng Data Patch trong Magento 2.
Không giống như declarative schema, Patch chỉ được áp dụng một lần và được lưu trữ trong bảng patch_list trong cơ sở dữ liệu. Những Patch chưa được áp dụng sẽ được áp dụng khi chạy câu lệnh php bin/magento setup:upgrade.
Tạo Data Patch trong Magento 2
Để tạo một Data Patch trong Magento 2 đầu tiên chúng ta phải tạo một file bên trong thư mục Setup/Patch
Tạo file: ViMagento/HelloWorld/Setup/Patch/Data/AddProductAttribute.php

 
<?php
 
namespace ViMagento\HelloWorld\Setup\Patch\Data;
 
use Magento\Eav\Model\Entity\Attribute\ScopedAttributeInterface;
use Magento\Eav\Setup\EavSetup;
use Magento\Eav\Setup\EavSetupFactory;
use Magento\Framework\Setup\ModuleDataSetupInterface;
use Magento\Framework\Setup\Patch\DataPatchInterface;
 
class AddProductAttribute implements DataPatchInterface
{
    /**
     * ModuleDataSetupInterface
     *
     * @var ModuleDataSetupInterface
     */
    private $moduleDataSetup;
 
    /**
     * EavSetupFactory
     *
     * @var EavSetupFactory
     */
    private $eavSetupFactory;
 
    /**
     * AddProductAttribute constructor.
     *
     * @param ModuleDataSetupInterface  $moduleDataSetup
     * @param EavSetupFactory           $eavSetupFactory
     */
    public function __construct(
        ModuleDataSetupInterface $moduleDataSetup,
        EavSetupFactory $eavSetupFactory
    ) {
        $this->moduleDataSetup = $moduleDataSetup;
        $this->eavSetupFactory = $eavSetupFactory;
    }
 
    /**
     * {@inheritdoc}
     */
    public function apply()
    {
        /** @var EavSetup $eavSetup */
        $eavSetup = $this->eavSetupFactory->create(['setup' => $this->moduleDataSetup]);
 
        $eavSetup->addAttribute('catalog_product', 'helloworld', [
            'type' => 'int',
            'label' => 'HelloWorld ViMagento',
            'input' => 'select',
            'source' => 'Magento\Eav\Model\Entity\Attribute\Source\Boolean',
            'default' => 0,
            'global' => ScopedAttributeInterface::SCOPE_STORE,
            'visible' => true,
            'used_in_product_listing' => true,
            'user_defined' => true,
            'required' => false,
            'group' => 'General',
            'sort_order' => 80,
        ]);
    }
 
    /**
     * {@inheritdoc}
     */
    public static function getDependencies()
    {
        return [];
    }
 
    /**
     * {@inheritdoc}
     */
    public function getAliases()
    {
        return [];
    }
}
 
Vừa rồi tôi dùng Data Patch để thêm một product attribute. Trong đó:
▪	apply() là function chính, mọi sửa đổi bạn muốn sẽ được viết ở đây
▪	getDependencies() định nghĩa những phụ thuộc của patch. Ví dụ:

	 
public static function getDependencies()
{
    return [
        \SomeVendor\SomeModule\Setup\Patch\Data\SomePatch::class
    ];
}
 
▪	getAliases() tên định danh cho patch
Kích hoạt Data Patch
Chạy câu lệnh php bin/magento setup:upgrade sau đó truy cập trang admin của bạn vào Catalog > Product > Add Product
 Thêm Product Attribute trong Magento 2
Và đây là table patch_list sẽ lưu tất cả các patch đã áp dụng
 Bảng patch_list chứa danh sách các Patch đã được cài đặt trong Magento 2
Lưu ý patch chỉ chạy một lần, Nếu bạn muốn sửa đổi dữ liệu thì bạn có thể tạo một file mới hoặc xóa record vừa tạo trong bảng patch_list và chạy setup:upgrade lại
Kết luận
Sau khi học xong bài này các bạn hãy sử dụng Data Patch để thay cho Setup Script nhé. Các bạn có thể tham khảo bài viết này để biết thêm chi tiết: https://devdocs.magento.com/guides/v2.4/extension-dev-guide/declarative-schema/data-patches.html
 
Thêm Product Attribute Trong Magento 2
Trong quá trình làm việc với Magento 2, chắc chắn sẽ có lúc bạn muốn thêm vào Product form một field phải không nào. Và Magento có hỗ trợ bạn làm điều đó. Trong bài viết này tôi sẽ hướng dẫn các bạn thêm product attribute trong Magento 2 với hai cách:
Cách 1: Thêm Product Attribute trong Magento 2 với Setup Script
Đầu tiên các bạn tạo file ViMagento/HelloWorld/Setup/InstallData.php nằm trong module ViMagento_HelloWorld với nội dung sau:

 
<?php
 
namespace ViMagento\HelloWorld\Setup;
 
use Magento\Framework\Setup\UpgradeDataInterface;
use Magento\Framework\Setup\ModuleDataSetupInterface;
use Magento\Framework\Setup\ModuleContextInterface;
use Magento\Eav\Setup\EavSetup;
use Magento\Eav\Setup\EavSetupFactory;
 
class UpgradeData implements UpgradeDataInterface
{
    private $eavSetupFactory;
 
    public function __construct(EavSetupFactory $eavSetupFactory)
    {
        $this->eavSetupFactory = $eavSetupFactory;
    }
 
    public function upgrade(ModuleDataSetupInterface $setup, ModuleContextInterface $context)
    {
        if (version_compare($context->getVersion(), '1.0.2', '<')) {
            $eavSetup = $this->eavSetupFactory->create(['setup' => $setup]);
 
            $eavSetup->addAttribute(\Magento\Catalog\Model\Product::ENTITY, 'use_setup_script',
                [
                    'group' => 'General',
                    'attribute_set_id' => 'Bag',
                    'type' => 'varchar',
                    'backend' => '',
                    'frontend' => '',
                    'label' => 'Use Setup Script',
                    'input' => 'text',
                    'class' => '',
                    'source' => '',
                    'global' => \Magento\Eav\Model\Entity\Attribute\ScopedAttributeInterface::SCOPE_GLOBAL,
                    'visible' => true,
                    'required' => false,
                    'user_defined' => true,
                    'default' => 0,
                    'searchable' => true,
                    'filterable' => true,
                    'comparable' => true,
                    'visible_on_front' => true,
                    'sort_order' => 50,
                    'option' => [
                        'values' => [],
                    ]
                ]
            );
        }
    }
}
 
 
Các attribute:
▪	group: các attribute được nhóm thành các group, giá trị này cho biết attribute sẽ thuộc về group cha nào.
▪	type: xác định attribute này sẽ được lưu vào bảng nào trong cơ sở dữ liệu.
▪	backend: xác định class sẽ thực hiện 1 số hành động cụ thể khi load hoặc save attribute.
▪	frontend: xác định cách hiển thị attribute.
▪	label: giá trị sẽ hiển thị ở cả frontend và backend.
▪	input: xác định kiểu đầu vào như select, text…
▪	source: danh sách các options được sử dụng cho kiểu đầu vào dạng select, multi select..
▪	global: xác định phạm vi của attribute global, website hay store.
▪	required: xác định liệu có bắt buộc nhập hay không.
▪	visible: xác định liệu attribute có được hiển thị ở cả backend và frontend hay không.
▪	visible_on_front: xác định liệu attribute có được hiển thị ở tab “More Information” trong trang product detail hay không. Và nó cũng phụ thuộc vào thuộc tính visible ở trên.
▪	default: đặt một giá trị mặc định cho attribute.
▪	is_used_in_grid: xác định liệu attribute có được sử dụng trong grid hay không.
▪	is_visible_in_grid: xác định liệu attribute có được hiển thị trong grid hay không.
▪	is_filterable_in_grid: xác định liệu attribute có được filter trong grid hay không.
▪	user_defined: xác định liệu admin có quyền xóa hoặc thay đổi attribute hay không.
▪	searchable: xác định liệu có thể sử dụng attribute để search hay không.
▪	unique: có là giá trị duy nhất hay không.
▪	option: xác định danh sách các option được sử dụng cho select, multi select..
▪	sort_order: thứ tự sắp xếp của attribute.
▪	apply_to: áp dụng cho loại product nào. Ví dụ:  simple product, virtual product ….
Sau đó nâng version của module lên 1.0.2, chạy câu lệnh php bin/magento setup:upgrade và truy cập vào trang admin của bạn Catalog > Product > Add Product
 Thêm Attribute sử dụng Setup Script
Cách 2: Thêm Product Attribute trong Magento 2 với Data Patch
Bạn nào muốn tìm hiểu thêm về Data Patch trong Magento có tham khảo bài này. Sử dụng Data Patch trong Magento 2.
Tạo file: ViMagento/HelloWorld/Setup/Patch/Data/AddProductAttribute.php


<?php
 
namespace ViMagento\HelloWorld\Setup\Patch\Data;
 
use Magento\Eav\Model\Entity\Attribute\ScopedAttributeInterface;
use Magento\Eav\Setup\EavSetup;
use Magento\Eav\Setup\EavSetupFactory;
use Magento\Framework\Setup\ModuleDataSetupInterface;
use Magento\Framework\Setup\Patch\DataPatchInterface;
 
class AddProductAttribute implements DataPatchInterface
{
    /**
     * ModuleDataSetupInterface
     *
     * @var ModuleDataSetupInterface
     */
    private $moduleDataSetup;
 
    /**
     * EavSetupFactory
     *
     * @var EavSetupFactory
     */
    private $eavSetupFactory;
 
    /**
     * AddProductAttribute constructor.
     *
     * @param ModuleDataSetupInterface  $moduleDataSetup
     * @param EavSetupFactory           $eavSetupFactory
     */
    public function __construct(
        ModuleDataSetupInterface $moduleDataSetup,
        EavSetupFactory $eavSetupFactory
    ) {
        $this->moduleDataSetup = $moduleDataSetup;
        $this->eavSetupFactory = $eavSetupFactory;
    }
 
    /**
     * {@inheritdoc}
     */
    public function apply()
    {
        /** @var EavSetup $eavSetup */
        $eavSetup = $this->eavSetupFactory->create(['setup' => $this->moduleDataSetup]);
 
        $eavSetup->addAttribute('catalog_product', 'datapatch', [
            'type' => 'int',
            'label' => 'Use Data Patch',
            'input' => 'text',
            'default' => 0,
            'global' => ScopedAttributeInterface::SCOPE_STORE,
            'visible' => true,
            'used_in_product_listing' => true,
            'user_defined' => true,
            'required' => false,
            'group' => 'General',
            'sort_order' => 80,
        ]);
    }
 
    /**
     * {@inheritdoc}
     */
    public static function getDependencies()
    {
        return [];
    }
 
    /**
     * {@inheritdoc}
     */
    public function getAliases()
    {
        return [];
    }
 
    public static function getVersion()
    {
        return '1.0.1';
    }
}
 
Sau đó bạn cũng chạy php bin/magento setup:upgrade và truy cập vào trang admin của bạn Catalog > Product > Add Product
 Hướng dẫn thêm một product attribute trong Magento 2
Kết luận
Trong bài viết tôi đã hướng dẫn cho các bạn về cách tạo product attribute trong Magento 2. Cám ơn các bạn đã đọc bài viết.
 
ACL trong Magento 2 – Hướng dẫn tạo ACL
Access Control List (ACL) rules cho phép admin giới hạn quyền truy cập của users vào các mục như: Controller, menu, API hoặc một phần trong configuration. Điều này cho phép chủ cửa hàng thiết lập vai trò riêng cho từng nhân viên của họ. Trong bài viết này chúng ta sẽ cùng nhau tìm hiểu về ACL trong Magento 2 cũng như cách tạo ACL và thiết lập từng quyền cụ thể (phân quyền). Ví dụ như nhân viên sales chỉ được vào mục order và product chẳng hạn…
Tạo một ACL trong Magento 2
Ở bài viết này tôi sẽ sử dụng lại module ViMagento_HelloWorld đã được tạo ở bài Hướng dẫn tạo module trong Magento 2.
Tạo file: ViMagento/HelloWorld/etc/acl.xml và thêm vào nội dung như bên dưới:

 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Acl/etc/acl.xsd">
    <acl>
        <resources>
            <resource id="Magento_Backend::admin">
                <resource id="ViMagento_HelloWorld::vimagento" title="Use ACL" sortOrder="100">
                    <resource id="ViMagento_HelloWorld::post" title="Posts" sortOrder="10"/>
                    <resource id="ViMagento_HelloWorld::menu" title="Menu" sortOrder="20" />
                    <resource id="ViMagento_HelloWorld::Configuration" title="Configuration" sortOrder="30" />
                </resource>
            </resource>
        </resources>
    </acl>
</config>
 
▪	id: xác định id của resource là một chuỗi duy nhất được sử dụng để hạn chế quyền truy cập vào controller, menu hoặc configuration.. và nên đặt tên với định dạng Verdon_Module::resource_name
▪	title: tên sẽ hiển thỉ ở danh sách resource.
▪	sortOrder: xác định vị trí sắp xếp của resource.
Xóa cache
php bin/magento cache:clean
Cách sử dụng ACL
Đầu tiên các bạn vào System > Permissions > User Roles > Add New Role bấm vào tab Role Resources bạn sẽ thấy danh sách các resource mà chúng ta vừa tạo.
 Hướng dẫn tạo ACL trong Magento 2
Cách sử dụng cho Menu

	 
<add id="ViMagento_HelloWorld::helloworld" title="Hello World" module="ViMagento_HelloWorld" sortOrder="40" resource="ViMagento_HelloWorld::menu"/>
 
Cách sử dụng cho Controller

	 
protected function _isAllowed()
{
     return $this->_authorization->isAllowed('ViMagento_HelloWorld::post');
}
 
hoặc

 
const ADMIN_RESOURCE = "ViMagento_HelloWorld::post";
 
Cách sử dụng cho Store Configuration

 
<section id="helloworld" translate="label" sortOrder="130" showInDefault="1" showInWebsite="1" showInStore="1">
        ….
            <resource>ViMagento_HelloWorld::Configuration</resource>
        ….
</section>
 
Phân quyền cho User
Ví dụ ở đây tôi chỉ cho phép user truy cập vào phần sales và catalog thì tôi sẽ làm như sau:
Vào System > Permissions > User Roles > Add New Role ở tab Role Info nhập tên role và mật khẩu hiện tại của bạn
 Tạo Quyền có tên catalog
Tiếp theo vào tab Role Resources và tick chọn Sales và Catalog
 Cây ACL trong Magento 2
Sau đó nhấn Save Role và bạn đã có thêm một quyền ngoài Administrators là Catalog.
 Hướng dẫn thêm một ACL(Access Control List) trong Magento 2
Sau đó các bạn vào phần System > Permissions > All User > Add New User. Bạn tạo một user mới và chọn quyền Catalog chúng ta vừa tạo ở bước trên và Save User.
 Thiết lập quyền cho user
Cuối cùng các bạn đăng xuất tài khoản admin hiện tại và đăng nhập bằng tài khoản với quyền Catalog vừa tạo
 Các mục user không có quyền vào sẽ bị ẩn đi
Như bạn thấy thì tài khoản này chỉ có thể truy cập vào phần Sales và Catalog thôi. Ở đây chỉ là ví dụ còn các bạn muốn user vào được những phần nào thì chỉ cần tick chọn vào phần đó trong danh sách resource là được nhé.
Kết luận
ACL là một phần đơn giản nhưng không kém phần quan trọng trong Magento 2. Nó giúp cho người quản trị website có thể thiết lập quyền cụ thể cho từng user một cách đơn giản. Các bạn có thể đọc trên devdocs của Magento 2 để biết thêm chi tiết: https://devdocs.magento.com/guides/v2.4/ext-best-practices/tutorials/create-access-control-list-rule.html
 
Tạo Menu Admin trong Magento 2
bởi Admin 19/08/2020 0 Bình luận 211 xem
Trong bài viết này chúng ta sẽ tìm hiểu cách tạo menu admin trong Magento 2. Và thay đổi icon mặc định của nó.
 Menu admin trong Magento 2
Tạo menu admin trong Magento 2
Đầu tiên các bạn tạo file: ViMagento/HelloWorld/etc/adminhtml/menu.xml

	 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Backend:etc/menu.xsd">
    <menu>
        <add id="ViMagento_HelloWorld::vimagento" title="ViMagento" module="ViMagento_HelloWorld" sortOrder="41" resource="ViMagento_HelloWorld::menu"/>
        <add id="ViMagento_HelloWorld::parent" title="ViMagento Post" module="ViMagento_HelloWorld" sortOrder="10" resource="ViMagento_HelloWorld::menu" parent="ViMagento_HelloWorld::vimagento"/>
        <add id="ViMagento_HelloWorld::post" title="Manage Posts" module="ViMagento_HelloWorld" sortOrder="10" action="helloworld/post/index" resource="ViMagento_HelloWorld::post" parent="ViMagento_HelloWorld::parent"/>
        <add id="ViMagento_HelloWorld::configuration" title="Configuration" module="ViMagento_HelloWorld" sortOrder="20" parent="ViMagento_HelloWorld::parent" action="adminhtml/system_config" resource="ViMagento_HelloWorld::parent"/>
    </menu>
</config>
 
▪	id: Tên định danh là duy nhất không được trùng và nên đặt theo định dạng Vendor_Module::menu_name
▪	title: Tên sẽ hiển thị ở menu
▪	module: Tên module mà menu này phụ thuộc
▪	sortOrder: xác định vị trí sắp xếp của menu. Giá trị càng thấp thì menu càng được sắp xếp ở trên top
▪	parent: xác định id của menu cha
▪	action: đường dẫn khi nhấn vào menu
▪	resource: xác định ACL đã học ở bài trước
Sau đó các bạn chạy câu lệnh php bin/magento cache:clean để xóa cache của Magento
 Tạo menu admin sẽ có icon mặc định
Mặc định khi tạo một menu sẽ có một icon. Vậy muốn thay đổi thành icon khác thì phải làm như thế nào ?
Thay đổi icon mặc định
1. Vào trang icommon và download font mà bạn muốn.
 Chon font mà bạn thích
2. Giải nén icon
Giải nén file vừa tải về và copy vào thư mục ViMagento/HelloWorld/view/adminhtml/web/fonts
3. Tạo file _module.less
Các bạn tạo file ViMagento/HelloWorld/view/adminhtml/web/css/source/_module.less
Bạn copy nội file style.css vừa giải nén ở trên, paste vào file _module.less và thay đổi đường dẫn cũng như class css của menu của bạn ở đây của tôi là item-vimagento

	 
@font-face {
    font-family: 'icomoon';
    src:  url('../../fonts/fonts/icomoon.eot?ibcmtq');
    src:  url('../../fonts/fonts/icomoon.eot?ibcmtq#iefix') format('embedded-opentype'),
    url('../../fonts/fonts/icomoon.ttf?ibcmtq') format('truetype'),
    url('../../fonts/fonts/icomoon.woff?ibcmtq') format('woff'),
    url('../../fonts/fonts/icomoon.svg?ibcmtq#icomoon') format('svg');
    font-weight: normal;
    font-style: normal;
    font-display: block;
}
.admin__menu .item-vimagento.level-0 > a:before {
    font-family: 'icomoon';
    content: '\e91b';
}
 
Kiểm tra

 
rm -rf var/view_preprocessed/* pub/static/*
php bin/magento setup:static-content:deploy
 
 Tạo thành công Menu Admin
Kết luận
Bài tiếp theo tôi sẽ hướng dẫn các bạn tạo system.xml để tạo các thiết lập trong store configuration. Cám ơn các bạn đã theo dõi bài viết.
 
Tạo system.xml trong Magento 2
System.xml là một configuration file được sử dụng để tạo các field được sử dụng trong Store > Settings > Configuration. Bạn sẽ cần đến nó nếu admin có một vài cài đặt cần được thiết lập. Trong bài viết này tôi sẽ hướng dẫn các bạn tạo system.xml trong Magento 2 và xét giá trị mặc định cho nó.
Tạo system.xml trong Magento 2
Trong Magento 2 system configuration được chia thành các phần: tab (1), section (2), group (3), field (4) như hình bên dưới:
 Hướng dẫn tạo system.xml trong Magento 2
Một system.xml file được đặt ở thư mục etc/adminhtml của module. Trong hướng dẫn này tôi sử dụng module ViMagento_HelloWorld.
Tạo file: ViMagento/HelloWorld/etc/adminhtml/system.xml và thêm vào nội dung bên dưới:

 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Config:etc/system_file.xsd">
    <system>
        <tab id="vimagento" translate="label" sortOrder="10">
            <label>ViMagento</label>
        </tab>
        <section id="setting" translate="label" sortOrder="130" showInDefault="1" showInWebsite="1" showInStore="1">
            <class>vimagento-setting</class>
            <label>Setting</label>
            <tab>vimagento</tab>
            <resource>ViMagento_HelloWorld::Configuration</resource>
            <group id="post" translate="label" type="text" sortOrder="10" showInDefault="1" showInWebsite="1" showInStore="1">
                <label>Post Configuration</label>
                <field id="enable" translate="label" type="select" sortOrder="1" showInDefault="1" showInWebsite="1" showInStore="1">
                    <label>Module Enable</label>
                    <source_model>Magento\Config\Model\Config\Source\Yesno</source_model>
                </field>
                <field id="display_text" translate="label" type="text" sortOrder="1" showInDefault="1" showInWebsite="1" showInStore="1">
                    <label>Post Content</label>
                    <comment>This is post content.</comment>
                </field>
            </group>
        </section>
    </system>
</config>
 
 
Ở đoạn code trên tôi đã tạo tab, section, group và field, với các attribute sau:
tab
▪	id: Tên định danh của tab
▪	sortOrder: xác định vị trí sắp xếp của tab hiện tại với các tab khác
▪	translate: xác định attribute nào cần dịch
▪	title: Tên sẽ hiển thị của tab
section
Section cũng có các thuộc tính id, sortOrder… tương tự như tab. Và có showInDefault, showInWebsite, showInStore xác định thành phần hiện tại sẽ hiển thị ở phạm vi nào.
 Hướng dẫn thêm một system.xml Configuration file
▪	label: tiêu đề của thành phần
▪	tab: đây là id của tab. Sẽ cho Magento biết thành phần hiện tại là con của tab nào
▪	resource: là một ACL role
field
▪	type: loại input đầu vào như text, select…
▪	source_model: một class sẽ định nghĩa danh sách các option dùng cho select, multi select…(xem thêm bài viết về source model)
▪	frontend_model: dùng khi bạn muốn sửa đổi các thành phần html của field (xem thêm bài viết về frontend model tại đây)
▪	backend_model: dùng khi bạn muốn thực hiện một vài hành động khi save hoặc load thành phần
Thiết lập giá trị mặc định
Mặc định khi bạn tạo configuration sẽ không có giá trị nên nếu bạn lấy giá trị sẽ trả về kết quả là null. Để thiết lập giá trị mặc định cho chúng bạn phải tạo file: ViMagento/HelloWorld/etc/config.xml

 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Store:etc/config.xsd">
    <default>
        <setting>
            <post>
                <enable>1</enable>
                <display_text>ViMagento HelloWorld</display_text>
            </post>
        </setting>
    </default>
</config>
 
Bạn có thể đặt giá trị mặc định cho field với định dạng sau:

	 
<default>
    <section>
        <group>
            <field>value</field>
        </group>
    </section>
</default>
 
Xóa cache và kiểm tra
Chạy câu lệnh php bin/magento cache:clean để xóa cache của Magento.
 Hướng dẫn thêm system.xml trong Magento 2
Lấy giá trị của field
Tất cả giá trị của configuration được lưu trong bảng core_config_data. Chúng ta vừa tạo 2 field:
▪	setting/post/enable
▪	setting/post/display_text
Tạo Controller ViMagento/HelloWorld/Controller/Adminhtml/Config/Index.php

 
<?php
 
namespace ViMagento\HelloWorld\Controller\Adminhtml\Config;
 
use Magento\Backend\App\Action;
use Magento\Framework\App\Config\ScopeConfigInterface;
use Magento\Store\Model\ScopeInterface;
 
class Index extends \Magento\Backend\App\Action
{
 
    const ENABLE = "setting/post/enable";
    const DISPLAY_TEXT = "setting/post/display_text";
 
    protected $scopeConfig;
 
    public function __construct(
        Action\Context $context,
        ScopeConfigInterface  $scopeConfig
    )
    {
        $this->scopeConfig = $scopeConfig;
        parent::__construct($context);
    }
 
    public function execute()
    {
        $enable = $this->scopeConfig->getValue(self::ENABLE, ScopeInterface::SCOPE_STORE);
        $displayText = $this->scopeConfig->getValue(self::DISPLAY_TEXT, ScopeInterface::SCOPE_STORE);
        echo $enable;
        echo "<br>";
        echo $displayText;
    }
}
 
Truy cập vào controller vừa tạo example.com/admin/helloworld/config/index
 Hướng dẫn tạo system.xml trong Magento 2
 
Tạo Source model trong Magento 2
bởi Admin 13/09/2020 0 Bình luận 68 xem
Khi học đến bài tạo system.xml trong Magento 2 tôi có đề cập đến source model trong Magento 2 nhưng chưa phân tích sâu vào vấn đề này. Nên trong bài viết này tôi sẽ hướng dẫn các bạn tạo source model trong Magento 2.
Các bạn có thể xem lại bài về tạo system.xml tại đây để hiểu rõ hơn.
Source model thường được dùng để tạo các options cho các input có type là select, multi select…và được sử dụng ở nhiều nơi chứ không riêng ở system.xml (configuration).
 Source model trong Magento 2 dùng để tạo các options cho các input select, multi select…
Tạo system.xml
ViMagento/HelloWorld/etc/adminhtml/system.xml

	 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Config:etc/system_file.xsd">
    <system>
        <tab id="vimagento" translate="label" sortOrder="10">
            <label>ViMagento</label>
        </tab>
        <section id="setting" translate="label" sortOrder="130" showInDefault="1" showInWebsite="1" showInStore="1">
            <class>vimagento-setting</class>
            <label>Setting</label>
            <tab>vimagento</tab>
            <resource>ViMagento_HelloWorld::Configuration</resource>
            <group id="post" translate="label" type="text" sortOrder="10" showInDefault="1" showInWebsite="1" showInStore="1">
                <label>Source Model Example</label>
                <field id="color" translate="label" type="select" sortOrder="1" showInDefault="1" showInWebsite="1" showInStore="1">
                    <label>Color</label>
                    <source_model>ViMagento\HelloWorld\Model\Config\Source\Color</source_model>
                </field>
                <field id="language" translate="label" type="multiselect" sortOrder="1" showInDefault="1" showInWebsite="1" showInStore="1">
                    <label>Language</label>
                    <source_model>ViMagento\HelloWorld\Model\Config\Source\Language</source_model>
                </field>
            </group>
        </section>
    </system>
</config>
 
Ở trong file system.xml trên tôi đã tạo 2 input có type là select và multi select và khai báo hai source model tương ứng.
Tạo source model trong Magento 2
Các bạn sẽ tạo các file tương ứng với khai báo trong system.xml
ViMagento/HelloWorld/Model/Config/Source/Color.php
	 
<?php
 
namespace ViMagento\HelloWorld\Model\Config\Source;
 
class Color implements \Magento\Framework\Option\ArrayInterface
{
    public function toOptionArray()
    {
        return [
            [
                'value' => null,
                'label' => __('--Please Select--')
            ],
            [
                'value' => 'yellow',
                'label' => __('Yellow')
            ],
            [
                'value' => 'red',
                'label' => __('Red')
            ],
            [
                'value' => 'gold',
                'label' => __('Gold')
            ],
        ];
    }
}
 
ViMagento/HelloWorld/Model/Config/Source/Language.php

	 
<?php
 
namespace ViMagento\HelloWorld\Model\Config\Source;
 
class Language implements \Magento\Framework\Option\ArrayInterface
{
    public function toOptionArray()
    {
        return [
            [
                'value' => null,
                'label' => __('--Please Select--')
            ],
            [
                'value' => 'vi',
                'label' => __('Việt Nam')
            ],
            [
                'value' => 'en',
                'label' => __('Anh')
            ],
            [
                'value' => 'tq',
                'label' => __('Trung Quốc')
            ],
            [
                'value' => 'my',
                'label' => __('Mỹ')
            ],
        ];
    }
}
 
Một source model sẽ implements class ArrayInterface và chúng ta sẽ tạo các options cho các input dạng select bên trong hàm toOptionArray. Chúng ta sẽ return về một mảng các items tương ứng với các value và label của thẻ <option></option>. Thật đơn giản phải không nào, và đây là đầu ra ở trình duyệt trong Stores > Configuration.
 Các options của các input dạng select, multi select…
Source model có thể dùng ở đâu?
Source model ngoài việc được sử dụng trong system.xml thì nó có thể được dùng ở một số nơi như:
▪	Product attribute trong backend
▪	Customer attribute trong backend
▪	Dropdown filter trong admin grids
▪	Các form sử dụng ở frontend và backend (ví dụ như dropdown country ở trang checkout)
Kết luận
Trong bài viết này tôi đã hướng dẫn cho các bạn về source model. Chúng có thể được sử dụng ở nhiều nơi nhằm mục đích tạo ra các option nhưng về cách sử dụng thì tương tự nhau, nên ở những nơi khác bạn cũng có thể dựa vào cấu trúc bên trên để làm. Cảm ơn bạn đã đọc bài.
 
Frontend model trong Magento 2 (system.xml)
bởi Admin 13/09/2020 0 Bình luận 85 xem
Đây là bài viết giải thích thêm cho bài Tạo system.xml trong Magento 2. Như bạn biết trong system.xml sẽ có khai báo frontend model dùng để thay đổi những gì liên quan đến giao diện người dùng. Trong bài viết này tôi sẽ hướng dẫn các bạn cách sử dụng frontend model trong Magento 2.
Ví dụ 1
Tạo system.xml
Tất nhiên đầu tiên chúng ta phải khai báo một file system.xml đã.
ViMagento/HelloWorld/etc/adminhtml/system.xml

<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Config:etc/system_file.xsd">
    <system>
        <tab id="vimagento" translate="label" sortOrder="10">
            <label>ViMagento</label>
        </tab>
        <section id="setting" translate="label" sortOrder="130" showInDefault="1" showInWebsite="1" showInStore="1">
            <class>vimagento-setting</class>
            <label>Setting</label>
            <tab>vimagento</tab>
            <resource>ViMagento_HelloWorld::Configuration</resource>
            <group id="post" translate="label" type="text" sortOrder="10" showInDefault="1" showInWebsite="1" showInStore="1">
                <label>Source Model Example</label>
                <field id="color_example" translate="label" type="text" sortOrder="1" showInDefault="1" showInWebsite="1" showInStore="1">
                    <label>Color</label>
                    <frontend_model>ViMagento\HelloWorld\Block\Color</frontend_model>
                </field>
            </group>
        </section>
    </system>
</config>
 
Ở trên tôi đã thêm một input dạng text vào Stores > Configuration. Nếu như bình thường thì nó chỉ là một ô input để người dùng nhập thông tin. Nhưng ở đây tôi muốn ô input này khi chúng ta click vào thì sẽ hiện bảng màu cho chúng ta chọn. Nên tôi đã khai báo một frontend model và tạo một class tương ứng.
Tạo frontend model trong Magento 2
ViMagento/HelloWorld/Block/Color.php

	 
<?php
 
namespace ViMagento\HelloWorld\Block;
 
class Color extends \Magento\Config\Block\System\Config\Form\Field
{
    public function __construct(
        \Magento\Backend\Block\Template\Context $context, array $data = []
    ) {
        parent::__construct($context, $data);
    }
 
    protected function _getElementHtml(\Magento\Framework\Data\Form\Element\AbstractElement $element) {
        $html = $element->getElementHtml();
        $value = $element->getData('value');
 
        $html .= '<script type="text/javascript">
            require(["jquery","jquery/colorpicker/js/colorpicker"], function ($) {
                $(document).ready(function () {
                 var $el = $("#' . $element->getHtmlId() . '");
                    $el.css("backgroundColor", "'. $value .'");
                 // Attach the color picker
                    $el.ColorPicker({
                     color: "'. $value .'",
                        onChange: function (hsb, hex, rgb) {
                            $el.css("backgroundColor", "#" + hex).val("#" + hex);
                     }
                 });
             });
         });
         </script>';
        return $html;
    }
}
 
Như bạn thấy trong file Color.php tôi đã sử dụng hàm _getElementHtml và thay đổi mã HTML như tôi mong muốn. Và sau đó tôi phải chèn thêm thư viện của color picker vào trang Configuration.
ViMagento/HelloWorld/view/adminhtml/layout/adminhtml_system_config_edit.xml

	 
<?xml version="1.0" encoding="UTF-8"?>
<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" layout="admin-2columns-left" xsi:noNamespaceSchemaLocation="../../../../../../../lib/internal/Magento/Framework/View/Layout/etc/page_configuration.xsd">
    <head>
        <css src="jquery/colorpicker/css/colorpicker.css"/>
        <link src="jquery/colorpicker/js/colorpicker.js"/>
    </head>
</page>
 
Và đây là kết quả của các đoạn code trên:
 Sử dụng frontend model trong Magento 2 để chỉnh sửa giao diện người dùng
Ví dụ 2
Trong ví dụ 2 này tôi sẽ tạo một dynamic rows cũng thường xuyên được sử dụng để thêm nhiều dòng dữ liệu trong Configuration.
Tạo system.xml
ViMagento/HelloWorld/etc/adminhtml/system.xml


<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Config:etc/system_file.xsd">
    <system>
        <tab id="vimagento" translate="label" sortOrder="10">
            <label>ViMagento</label>
        </tab>
        <section id="setting" translate="label" sortOrder="130" showInDefault="1" showInWebsite="1" showInStore="1">
            <class>vimagento-setting</class>
            <label>Setting</label>
            <tab>vimagento</tab>
            <resource>ViMagento_HelloWorld::Configuration</resource>
            <group id="post" translate="label" type="text" sortOrder="10" showInDefault="1" showInWebsite="1" showInStore="1">
                <label>Source Model Example</label>
                <field id="report" translate="label" sortOrder="5" showInDefault="1">
                    <label>Thống kê</label>
                    <frontend_model>ViMagento\HelloWorld\Block\Dynamic</frontend_model>
                    <backend_model>Magento\Config\Model\Config\Backend\Serialized\ArraySerialized</backend_model>
                </field>
            </group>
        </section>
    </system>
</config>
 
Tạo frontend model trong Magento 2
ViMagento/HelloWorld/Block/Dynamic.php

 
<?php
 
namespace ViMagento\HelloWorld\Block;
 
use Magento\Config\Block\System\Config\Form\Field\FieldArray\AbstractFieldArray;
use Magento\Framework\DataObject;
use Magento\Framework\Exception\LocalizedException;
 
class Dynamic  extends AbstractFieldArray
{
    protected function _prepareToRender()
    {
        $this->addColumn(
            'name',
            [
                'label' => __('Họ và tên'),
                'class' => 'required-entry'
            ]
        );
        $this->addColumn(
            'age',
            [
                'label' => __('Tuổi'),
                'class' => 'required-entry',
            ]
        );
        $this->_addAfter = false;
        $this->_addButtonLabel = __('Add Type');
    }
}
 
Tôi đã tạo một dynamic row với 2 input là name và age. Sử dụng backend model là class ArraySerialized để giúp bạn lưu dữ liệu dưới dạng serialize. Đây là kết quả:
 Tạo dynamic rows bằng cách sử dụng frontend model
Kết luận
Vậy là chúng ta đã tìm hiểu xong về source model, frontend model. Ở bài viết sau tôi sẽ hướng dẫn các bạn về backend model (system.xml) trong magento 2. Thanks.
 
Backend model trong Magento 2 (system.xml)
bởi Admin 13/09/2020 0 Bình luận 75 xem
Các bài trước chúng ta đã cùng nhau tìm hiểu về source mode, frontend model rồi và hôm nay. Chúng ta sẽ tìm hiểu về backend model trong Magento 2. Các bạn có thể xem lại các bài này để hiểu rõ hơn về những gì chúng ta sẽ học trong bài viết này.
▪	Tạo system.xml trong Magento 2
▪	Source model trong Magento 2
▪	Frontend model trong Magento 2
Khi mà các giá trị trong Stores > Configuration được lưu. Nhờ vào backend model mà chúng ta có thể kiểm soát được các hành động của chúng trước khi save( nhờ vào hàm beforeSave()) và sau khi save với hàm afterSave().
Để lấy một ví dụ đơn giản thì tôi sẽ làm một validate form chỉ cho phép nhập số dương tức là lớn hơn 0. Tất nhiên system.xml có hỗ trợ validate rồi, nhưng ở đây tôi muốn sử dụng backend model để các bạn có thể hiểu được cách mà nó hoạt động.
Tạo system.xml
ViMagento/HelloWorld/etc/adminhtml/system.xml

	 
<?php
 
namespace ViMagento\HelloWorld\Model\Config\Backend;
 
class Validate extends \Magento\Framework\App\Config\Value
{
    public function beforeSave()
    {
        $label = $this->getData('field_config/label');
 
        if ($this->getValue() == '') {
            throw new \Magento\Framework\Exception\ValidatorException(__($label . ' is required.'));
        } else if (!is_numeric($this->getValue())) {
            throw new \Magento\Framework\Exception\ValidatorException(__($label . ' is not a number.'));
        } else if ($this->getValue() < 0) {
            throw new \Magento\Framework\Exception\ValidatorException(__($label . ' is less than 0.'));
        }
 
        $this->setValue(intval($this->getValue()));
 
        parent::beforeSave();
    }
}
 
Ở trên tôi đã sử dụng hàm beforeSave để validate input của tôi. và đây là kết quả:
 Validate form với backend model trong Magento 2
Bây giờ hãy lấy một ví dụ về afterSave(). Tôi muốn khi save không cần biết người dùng nhập cái gì, tôi đều lưu giá trị ViMagento_HelloWorld vào cơ sở dữ liệu. Vẫn sử dụng class Validate ở trên và tôi sẽ thêm vào hàm afterSave như bên dưới:

 
<?php
 
namespace ViMagento\HelloWorld\Model\Config\Backend;
 
class Validate extends \Magento\Framework\App\Config\Value
{
    const CUSTOM_OPTION_STRING_PATH = 'setting/post/age';
 
    protected $_configValueFactory;
 
    /**
     * @param \Magento\Framework\Model\Context $context
     * @param \Magento\Framework\Registry $registry
     * @param \Magento\Framework\App\Config\ScopeConfigInterface $config
     * @param \Magento\Framework\App\Cache\TypeListInterface $cacheTypeList
     * @param \Magento\Framework\App\Config\ValueFactory $configValueFactory
     * @param \Magento\Framework\Model\ResourceModel\AbstractResource $resource
     * @param \Magento\Framework\Data\Collection\AbstractDb $resourceCollection
     * @param string $runModelPath
     * @param array $data
     */
    public function __construct(
        \Magento\Framework\Model\Context $context,
        \Magento\Framework\Registry $registry,
        \Magento\Framework\App\Config\ScopeConfigInterface $config,
        \Magento\Framework\App\Cache\TypeListInterface $cacheTypeList,
        \Magento\Framework\App\Config\ValueFactory $configValueFactory,
        \Magento\Framework\Model\ResourceModel\AbstractResource $resource = null,
        \Magento\Framework\Data\Collection\AbstractDb $resourceCollection = null,
        array $data = []
    ) {
        $this->_configValueFactory = $configValueFactory;
        parent::__construct($context, $registry, $config, $cacheTypeList, $resource, $resourceCollection, $data);
    }
 
    public function beforeSave()
    {
        $label = $this->getData('field_config/label');
 
        if ($this->getValue() == '') {
            throw new \Magento\Framework\Exception\ValidatorException(__($label . ' is required.'));
        } else if (!is_numeric($this->getValue())) {
            throw new \Magento\Framework\Exception\ValidatorException(__($label . ' is not a number.'));
        } else if ($this->getValue() < 0) {
            throw new \Magento\Framework\Exception\ValidatorException(__($label . ' is less than 0.'));
        }
 
        $this->setValue(intval($this->getValue()));
 
        parent::beforeSave();
    }
 
    public function afterSave()
    {
        $value = 'ViMagento HelloWorld';
 
        try {
            $this->_configValueFactory->create()->load(
                self::CUSTOM_OPTION_STRING_PATH,
                'path'
            )->setValue(
                $value
            )->setPath(
                self::CUSTOM_OPTION_STRING_PATH
            )->save();
        } catch (\Exception $e) {
            throw new \Exception(__('We can\'t save new option.'));
        }
 
        return parent::afterSave();
    }
}
 
Đây chỉ là ví dụ đơn giản để các bạn hiểu được backend model, chúng ta có thể thực hiện một số hành động trước và sau khi lưu với backend model. Và để kiểm tra ví dụ trên tôi sẽ nhập số 1 vào ô input và đây là kết quả.
 Thực hiện hành động nào đó khi save dữ liệu
Kết luận
Vậy là tôi đã hướng dẫn cho các bạn về backend model trong Magento 2. Hy vọng bài viết có thể giúp ích phần nào cho các bạn. Thanks.
Tạo form admin trong Magento 2 với Ui Component
Ui Component được thiết kế để kết xuất một số thành phần giao diện người dùng đơn giản và phức tạp. Trong bài viết này tôi sẽ hướng dẫn các bạn tạo form admin đơn giản trong Magento 2 sử dụng Ui Component.
Để tiết kiệm thời gian tôi sẽ không tạo lại module và model…mà tôi sử dụng module của các bài trước. Nếu bạn nào chưa có module có thể tham khảo bài này:
▪	Tạo module trong Magento 2
▪	Tạo Model, Resource Model, Collection trong Magento 2
Trong bài viết này tôi sử dụng bảng helloworld_post với các cột: post_id, name, status, content, created_at được tạo trong bài Tạo bảng với db_schema.xml trong Magento 2
Bước 1: Tạo Controller
ViMagento/HelloWorld/Controller/Adminhtml/Post/AddNew.php

	 
<?php
 
namespace ViMagento\HelloWorld\Controller\Adminhtml\Post;
 
use Magento\Framework\View\Result\PageFactory;
use Magento\Backend\App\Action;
 
class AddNew extends \Magento\Backend\App\Action
{
    protected $_pageFactory;
 
    public function __construct(Action\Context $context, PageFactory $pageFactory)
    {
        $this->_pageFactory = $pageFactory;
        parent::__construct($context);
    }
 
    public function execute()
    {
        $resultPage = $this->_pageFactory->create();
        $resultPage->getConfig()->getTitle()->prepend(__('Add New Post'));
        return $resultPage;
    }
}
 
Bước 2: Tạo Layout file
Bạn tạo file: ViMagento/HelloWorld/view/adminhtml/layout/helloworld_post_addNew.xml

	 
<?xml version="1.0"?>
<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
    <head>
        <title>HelloWorld</title>
    </head>
    <body>
        <referenceContainer name="content">
           <uiComponent name="helloworld_post_form" />
        </referenceContainer>
    </body>
</page>
 
Trong đó component name chính là tên file ui component sẽ được tạo ở bước sau:
Bước 3: Tạo Ui Component Form
ViMagento/HelloWorld/view/adminhtml/ui_component/helloworld_post_form.xml


<?xml version="1.0" encoding="UTF-8"?>
<form xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd">
    <argument name="data" xsi:type="array">
        <item name="js_config" xsi:type="array">
            <item name="provider" xsi:type="string">helloworld_post_form.helloworld_post_form_data_source</item>
            <item name="deps" xsi:type="string">helloworld_post_form.helloworld_post_form_data_source</item>
        </item>
        <item name="label" xsi:type="string" translate="true">Post Information</item>
        <item name="config" xsi:type="array">
            <item name="dataScope" xsi:type="string">data</item>
            <item name="namespace" xsi:type="string">add_new_row_form</item>
        </item>
        <item name="template" xsi:type="string">templates/form/collapsible</item>
        <item name="buttons" xsi:type="array">
            <item name="back" xsi:type="array">
                <item name="name" xsi:type="string">back</item>
                <item name="label" xsi:type="string" translate="true">Back</item>
                <item name="class" xsi:type="string">back</item>
                <item name="url" xsi:type="string">helloworld/post/index</item>
            </item>
            <item name="save" xsi:type="array">
                <item name="name" xsi:type="string">save</item>
                <item name="label" xsi:type="string" translate="true">Save</item>
                <item name="class" xsi:type="string">primary</item>
                <item name="url" xsi:type="string">helloworld/post/save</item>
            </item>
        </item>
    </argument>
    <dataSource name="helloworld_post_form_data_source">
        <argument name="dataProvider" xsi:type="configurableObject">
            <argument name="class" xsi:type="string">ViMagento\HelloWorld\Model\Config\DataProvider</argument>
            <argument name="name" xsi:type="string">helloworld_post_form_data_source</argument>
            <argument name="primaryFieldName" xsi:type="string">post_id</argument>
            <argument name="requestFieldName" xsi:type="string">id</argument>
        </argument>
        <argument name="data" xsi:type="array">
            <item name="js_config" xsi:type="array">
                <item name="component" xsi:type="string">Magento_Ui/js/form/provider</item>
                <item name="submit_url" path="helloworld/post/save" xsi:type="url"/>
            </item>
        </argument>
    </dataSource>
    <fieldset name="helloworld_post">
        <argument name="data" xsi:type="array">
            <item name="config" xsi:type="array">
                <item name="collapsible" xsi:type="boolean">false</item>
                <item name="label" xsi:type="string" translate="true">Post Details</item>
                <item name="sortOrder" xsi:type="number">20</item>
            </item>
        </argument>
 
        <field name="name">
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="dataType" xsi:type="string">text</item>
                    <item name="label" xsi:type="string" translate="true">Name</item>
                    <item name="formElement" xsi:type="string">input</item>
                    <item name="source" xsi:type="string">post_rules</item>
                    <item name="dataScope" xsi:type="string">name</item>
                    <item name="validation" xsi:type="array">
                        <item name="required-entry" xsi:type="boolean">true</item>
                        <item name="max_text_length" xsi:type="number">50</item>
                    </item>
                </item>
            </argument>
        </field>
        <field name="status" formElement="select">
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="validation" xsi:type="array">
                        <item name="required-entry" xsi:type="boolean">true</item>
                    </item>
                </item>
            </argument>
            <settings>
                <dataType>text</dataType>
                <label translate="true">Status</label>
                <dataScope>status</dataScope>
            </settings>
            <formElements>
                <select>
                    <settings>
                        <options>
                            <option name="pending" xsi:type="array">
                                <item name="value" xsi:type="string">pending</item>
                                <item name="label" xsi:type="string">Pending</item>
                            </option>
                            <option name="ship" xsi:type="array">
                                <item name="value" xsi:type="string">ship</item>
                                <item name="label" xsi:type="string">Ship</item>
                            </option>
                        </options>
                        <caption translate="true">-- Please Select --</caption>
                    </settings>
                </select>
            </formElements>
        </field>
 
        <field name="content">
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="dataType" xsi:type="string">text</item>
                    <item name="label" xsi:type="string" translate="true">Content</item>
                    <item name="formElement" xsi:type="string">textarea</item>
                    <item name="source" xsi:type="string">post_rules</item>
                    <item name="dataScope" xsi:type="string">content</item>
                    <item name="validation" xsi:type="array">
                        <item name="required-entry" xsi:type="boolean">true</item>
                    </item>
                </item>
            </argument>
        </field>
    </fieldset>
</form>
 
Bước 4: Tạo DataProvider
ViMagento/HelloWorld/ModelConfig/DataProvider.php

	 
<?php
 
namespace ViMagento\HelloWorld\Model\Config;
 
use ViMagento\HelloWorld\Model\PostFactory;
use ViMagento\HelloWorld\Model\ResourceModel\Post\CollectionFactory;
 
class DataProvider extends \Magento\Ui\DataProvider\AbstractDataProvider
{
    protected $_loadedData;
    protected $collection;
 
    public function __construct(
        $name,
        $primaryFieldName,
        $requestFieldName,
        CollectionFactory $collectionFactory,
        array $meta = [],
        array $data = []
    )
    {
        $this->collection = $collectionFactory->create();
        parent::__construct($name, $primaryFieldName, $requestFieldName, $meta, $data);
    }
 
    public function getData()
    {
        if (isset($this->_loadedData)) {
            return $this->_loadedData;
        }
        $items = $this->collection->getItems();
        foreach ($items as $item) {
            $this->_loadedData[$item->getId()] = $item->getData();
        }
        return $this->_loadedData;
    }
}
 
Sau đó bạn xóa cache với câu lệnh php bin/magento cache:clean và truy cập vào controller vừa tạo
 Thêm một form trong admin sử dụng Ui Component Magento 2
Kết luận
Trong bài viết tôi đã hướng dẫn các bạn thêm một form admin trong Magento 2 với Ui Component. Ngoài cách sử dụng Ui Component các bạn cũng có thể sử dụng Block để tạo các form có tính phức tạp hơn.
Ở bài viết tiếp theo tôi sẽ hướng dẫn các bạn save, edit và delete trong Magento 2.
Bài viết để các bạn tham khảo: https://devdocs.magento.com/guides/v2.4/ui_comp_guide/components/ui-form.html
 
Tạo Grid trong Magento 2 với Ui Component
 Magento 2 Tạo Grid để quản lý dữ liệu với Ui Component
Trong bài viết này tôi sẽ hướng dẫn các bạn tạo một Grid đơn giản sử dụng Ui Component để quản lý dữ liệu trong Magento 2. Ở đây tôi sử dụng bảng helloworld_post và module ViMagento_HelloWorld đã được cài đặt ở các bài trước. Nếu bạn nào chưa tạo có thể tham khảo các bài sau:
▪	Tạo module trong Magento 2
▪	Tạo bảng với db_schema.xml
▪	Tạo model, resource model và collection trong Magento 2
Trong bài viết này tôi sử dụng bảng helloworld_post với các column post_id, name, status, content, created_at.
Bước 1: Tạo Controller Admin
ViMagento/HelloWorld/Controller/Adminhtml/Post/Index.php

 
<?php
 
namespace ViMagento\HelloWorld\Controller\Adminhtml\Post;
 
use Magento\Framework\View\Result\PageFactory;
use Magento\Backend\App\Action;
 
class Index extends \Magento\Backend\App\Action
{
    protected $_pageFactory;
 
    public function __construct(Action\Context $context, PageFactory $pageFactory)
    {
        $this->_pageFactory = $pageFactory;
        parent::__construct($context);
    }
 
    public function execute()
    {
        $resultPage = $this->_pageFactory->create();
        $resultPage->getConfig()->getTitle()->prepend(__('ViMagento Hello World Listing'));
        return $resultPage;
    }
}
 
Bước 2: Tạo layout
ViMagento/HelloWorld/view/adminhtml/layout/helloworld_post_index.xml

	 
<?xml version="1.0"?>
<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
    <head>
        <title>ViMagento HelloWorld Listing</title>
    </head>
    <body>
        <referenceContainer name="content">
            <uiComponent name="helloworld_post_listing" />
        </referenceContainer>
    </body>
</page>
 
Bước 3: Tạo di.xml
Tạo nguồn cung cấp dữ liệu cho grid. Các bạn tạo file: ViMagento/HelloWorld/etc/di.xml
 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:ObjectManager/etc/config.xsd">
    <type name="Magento\Framework\View\Element\UiComponent\DataProvider\CollectionFactory">
        <arguments>
            <argument name="collections" xsi:type="array">
                <item name="helloworld_post_listing_data_source" xsi:type="string">helloworld_post_collection</item>
            </argument>
        </arguments>
    </type>
    <virtualType name="helloworld_post_collection" type="Magento\Framework\View\Element\UiComponent\DataProvider\SearchResult">
        <arguments>
            <argument name="mainTable" xsi:type="string">helloworld_post</argument>
            <argument name="resourceModel" xsi:type="string">ViMagento\HelloWorld\Model\ResourceModel\Post</argument>
        </arguments>
    </virtualType>
</config>
 
Bước 4: Tạo Grid Listing với Ui Component
ViMagento/HelloWorld/view/adminhtml/ui_component/helloworld_post_listing.xml


<?xml version="1.0" encoding="UTF-8"?>
<listing xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd">
    <argument name="data" xsi:type="array">
        <item name="js_config" xsi:type="array">
            <item name="provider" xsi:type="string">helloworld_post_listing.helloworld_post_listing_data_source</item>
            <item name="deps" xsi:type="string">helloworld_post_listing.helloworld_post_listing_data_source</item>
        </item>
        <item name="spinner" xsi:type="string">helloworld_post_columns</item>
        <item name="buttons" xsi:type="array">
            <item name="add" xsi:type="array">
                <item name="name" xsi:type="string">add</item>
                <item name="label" xsi:type="string" translate="true">Add A New Row</item>
                <item name="class" xsi:type="string">primary</item>
                <item name="url" xsi:type="string">*/*/add</item>
            </item>
        </item>
    </argument>
    <listingToolbar name="listing_top">
        <argument name="data" xsi:type="array">
            <item name="config" xsi:type="array">
                <item name="sticky" xsi:type="boolean">true</item>
            </item>
        </argument>
        <bookmark name="bookmarks"/>
        <filters name="listing_filters" />
        <columnsControls name="columns_controls"/>
        <filterSearch name="fulltext">
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="provider" xsi:type="string">helloworld_post_listing.helloworld_post_listing_data_source</item>
                    <item name="chipsProvider" xsi:type="string">helloworld_post_listing.helloworld_post_listing.listing_top.listing_filters_chips</item>
                    <item name="storageConfig" xsi:type="array">
                        <item name="provider" xsi:type="string">helloworld_post_listing.helloworld_post_listing.listing_top.bookmarks</item>
                        <item name="namespace" xsi:type="string">current.search</item>
                    </item>
                </item>
            </argument>
        </filterSearch>
 
        <paging name="listing_paging"/>
        <exportButton name="export_button"/>
        <massaction name="listing_massaction">
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="component" xsi:type="string">Magento_Ui/js/grid/tree-massactions</item>
                </item>
            </argument>
            <action name="delete">
                <argument name="data" xsi:type="array">
                    <item name="config" xsi:type="array">
                        <item name="type" xsi:type="string">delete</item>
                        <item name="label" xsi:type="string" translate="true">Delete</item>
                        <item name="url" xsi:type="url" path="*/*/delete"/>
                        <item name="confirm" xsi:type="array">
                            <item name="title" xsi:type="string" translate="true">Delete Row</item>
                            <item name="message" xsi:type="string" translate="true">Are you sure you wan't to delete selected items?</item>
                        </item>
                    </item>
                </argument>
            </action>
        </massaction>
    </listingToolbar>
 
    <dataSource name="helloworld_post_listing_data_source">
        <argument name="dataProvider" xsi:type="configurableObject">
            <argument name="class" xsi:type="string">Magento\Framework\View\Element\UiComponent\DataProvider\DataProvider</argument>
            <argument name="name" xsi:type="string">helloworld_post_listing_data_source</argument>
            <argument name="primaryFieldName" xsi:type="string">post_id</argument>
            <argument name="requestFieldName" xsi:type="string">id</argument>
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="component" xsi:type="string">Magento_Ui/js/grid/provider</item>
                    <item name="update_url" xsi:type="url" path="mui/index/render"/>
                    <item name="storageConfig" xsi:type="array">
                        <item name="indexField" xsi:type="string">id</item>
                    </item>
                </item>
            </argument>
        </argument>
    </dataSource>
 
    <!-- columns -->
    <columns name="helloworld_post_columns">
        <argument name="data" xsi:type="array">
            <item name="config" xsi:type="array">
                <item name="storageConfig" xsi:type="array">
                    <item name="provider" xsi:type="string">helloworld_post_listing.helloworld_post_listing.listing_top.bookmarks</item>
                    <item name="namespace" xsi:type="string">current</item>
                </item>
                <item name="childDefaults" xsi:type="array">
                    <item name="controlVisibility" xsi:type="boolean">true</item>
                    <item name="storageConfig" xsi:type="array">
                        <item name="provider" xsi:type="string">helloworld_post_listing.helloworld_post_listing.listing_top.bookmarks</item>
                        <item name="root" xsi:type="string">columns.${ $.index }</item>
                        <item name="namespace" xsi:type="string">current.${ $.storageConfig.root}</item>
                    </item>
                </item>
            </item>
        </argument>
 
        <selectionsColumn name="ids">
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="indexField" xsi:type="string">post_id</item>
                </item>
            </argument>
        </selectionsColumn>
 
        <!-- Column id -->
        <column name="post_id">
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="filter" xsi:type="string">textRange</item>
                    <item name="sorting" xsi:type="string">asc</item>
                    <item name="label" xsi:type="string" translate="true">ID</item>
                </item>
            </argument>
        </column>
        <!-- Column title -->
        <column name="name">
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="visible" xsi:type="boolean">true</item>
                    <item name="dataType" xsi:type="string">text</item>
                    <item name="formElement" xsi:type="string">input</item>
                    <item name="source" xsi:type="string">helloworld_post</item>
                    <item name="dataScope" xsi:type="string">title</item>
                    <item name="label" xsi:type="string" translate="true">Name</item>
                    <item name="filter" xsi:type="string">text</item>
                </item>
            </argument>
        </column>
        <!-- Column status -->
        <column name="status">
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="visible" xsi:type="boolean">true</item>
                    <item name="dataType" xsi:type="string">text</item>
                    <item name="formElement" xsi:type="string">input</item>
                    <item name="source" xsi:type="string">helloworld_post</item>
                    <item name="dataScope" xsi:type="string">status</item>
                    <item name="label" xsi:type="string" translate="true">Status</item>
                    <item name="filter" xsi:type="string">text</item>
                </item>
            </argument>
        </column>
 
        <column name="content">
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="visible" xsi:type="boolean">true</item>
                    <item name="dataType" xsi:type="string">text</item>
                    <item name="formElement" xsi:type="string">input</item>
                    <item name="source" xsi:type="string">helloworld_post</item>
                    <item name="dataScope" xsi:type="string">rule_type</item>
                    <item name="label" xsi:type="string" translate="true">Content</item>
                    <item name="filter" xsi:type="string">text</item>
                </item>
            </argument>
        </column>
    </columns>
</listing>
 
Có một số điểm lưu ý ở đây:
▪	helloworld_post_listing: chính là tên file hiện tại
▪	helloworld_post_listing_data_source: là data source đã tạo trong file di.xml ở bước 3
Ở trên ngoài thêm một grid tôi còn thêm các thành phần như search, phân trang, export… bằng cách thêm đoạn sau:


<listingToolbar name="listing_top">
        <argument name="data" xsi:type="array">
            <item name="config" xsi:type="array">
                <item name="sticky" xsi:type="boolean">true</item>
            </item>
        </argument>
        <bookmark name="bookmarks"/>
        <filters name="listing_filters" />
        <columnsControls name="columns_controls"/>
        <filterSearch name="fulltext">
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="provider" xsi:type="string">helloworld_post_listing.helloworld_post_listing_data_source</item>
                    <item name="chipsProvider" xsi:type="string">helloworld_post_listing.helloworld_post_listing.listing_top.listing_filters_chips</item>
                    <item name="storageConfig" xsi:type="array">
                        <item name="provider" xsi:type="string">helloworld_post_listing.helloworld_post_listing.listing_top.bookmarks</item>
                        <item name="namespace" xsi:type="string">current.search</item>
                    </item>
                </item>
            </argument>
        </filterSearch>
        <paging name="listing_paging"/>
        <exportButton name="export_button"/>
        <massaction name="listing_massaction">
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="component" xsi:type="string">Magento_Ui/js/grid/tree-massactions</item>
                </item>
            </argument>
            <action name="delete">
                <argument name="data" xsi:type="array">
                    <item name="config" xsi:type="array">
                        <item name="type" xsi:type="string">delete</item>
                        <item name="label" xsi:type="string" translate="true">Delete</item>
                        <item name="url" xsi:type="url" path="*/*/delete"/>
                        <item name="confirm" xsi:type="array">
                            <item name="title" xsi:type="string" translate="true">Delete Row</item>
                            <item name="message" xsi:type="string" translate="true">Are you sure you wan't to delete selected items?</item>
                        </item>
                    </item>
                </argument>
            </action>
        </massaction>
    </listingToolbar>
 
 
Sau đó các bạn xóa cache: php bin/magento cache:clean và truy cập vào controller của bạn
 Magento 2 Tạo Grid để quản lý dữ liệu với Ui Component
 
Magento 2 Thêm Action Column trong Admin Grid
bởi Admin 22/08/2020 0 Bình luận 106 xem
Bài viết này sẽ hướng dẫn các bạn thêm một column edit trong grid listing ở admin.
 
Bước 1
Ở grid đã tạo ở bài MAGENTO 2 TẠO GRID ĐỂ QUẢN LÝ DỮ LIỆU VỚI UI COMPONENT chúng ta thêm một đoạn code như bên dưới để tạo thêm một column:
ViMagento/HelloWorld/view/adminhtml/ui_component/helloworld_post_listing.xml

 
<?xml version="1.0" encoding="UTF-8"?>
<listing xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd">
    <columns name="helloworld_post_columns">
        <actionsColumn name="actions" class="ViMagento\HelloWorld\Ui\Component\Listing\Grid\Column\Action">
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="resizeEnabled" xsi:type="boolean">false</item>
                    <item name="resizeDefaultWidth" xsi:type="string">107</item>
                    <item name="indexField" xsi:type="string">post_id</item>
                </item>
            </argument>
        </actionsColumn>
    </columns>
</listing>
 
Lưu ý là actionsColumn phải đặt trong thẻ columns nhé.
Bước 2
Tạo file ViMagento/HelloWorld/Ui/Component/Listing/Grid/Column/Action.php

 
<?php
 
namespace ViMagento\HelloWorld\Ui\Component\Listing\Grid\Column;
 
use Magento\Ui\Component\Listing\Columns\Column;
 
class Action extends Column
{
    /**
     * Prepare Data Source
     *
     * @param array $dataSource
     * @return array
     */
    public function prepareDataSource(array $dataSource)
    {
        $obj = \Magento\Framework\App\ObjectManager::getInstance();
        $store = $obj->create('\Magento\Store\Model\StoreManagerInterface');
        $url = $store->getStore()->getBaseUrl();
        if (isset($dataSource['data']['items'])) {
            foreach ($dataSource['data']['items'] as & $item) {
                $item[$this->getData('name')] = [
                    'edit' => [
                        'href' => $url.'admin/helloworld/post/addNew/id/'.$item["post_id"],
                        'label' => __('Edit')
                    ]
                ];
            }
        }
 
        return $dataSource;
    }
}
 
Bước 3
Xóa cache php bin/magento cache:clean và refesh lại trang.
 
Khi chúng ta nhấn vào edit sẽ được điều hướng đến trang edit tương ứng.
 
 
Thêm, Xóa, Sửa dữ liệu trong Magento 2
Ở các bài trước chúng ta đã tạo được một form để nhập dữ liệu trong admin. Trong bài viết này tôi sẽ hướng dẫn các bạn thêm, sửa, xóa dữ liệu trong Magento 2.
Save, Edit dữ liệu
Ở bài trước chúng ta đã tạo được một form như bên dưới:
 Hướng dẫn Thêm, Xóa, Sửa dữ liệu(CRUD) trong Magento 2
▪	Tạo Controller dùng để save và edit
Lưu ý ở bài tạo form chúng ta thêm đường dẫn. Khi submit form dữ liệu sẽ được gửi đến controller helloworld/post/save. Các bạn có thể xem lại bài viết tại đây.
ViMagento/HelloWorld/Controller/Adminhtml/Post/Save.php

	 
<?php
 
namespace ViMagento\HelloWorld\Controller\Adminhtml\Post;
 
use Magento\Backend\App\Action;
use ViMagento\HelloWorld\Model\PostFactory;
use Magento\Backend\Model\View\Result\RedirectFactory;
 
class Save extends Action
{
    private $resultRedirect;
    private $postFactory;
 
    public function __construct(
        Action\Context $context,
        PostFactory $postFactory,
        RedirectFactory $redirectFactory
    )
    {
        parent::__construct($context);
        $this->postFactory = $postFactory;
        $this->resultRedirect = $redirectFactory;
    }
 
    public function execute()
    {
        $data = $this->getRequest()->getPostValue();
        $id = !empty($data['post_id']) ? $data['post_id'] : null;
 
        $newData = [
            'name' => $data['name'],
            'status' => $data['status'],
            'content' => $data['content'],
        ];
 
        $post = $this->postFactory->create();
        if ($id) {
            $post->load($id);
            $this->getMessageManager()->addSuccessMessage(__('Edit thành công'));
        } else {
            $this->getMessageManager()->addSuccessMessage(__('Save thành công.'));
        }
        try{
            $post->addData($newData);
            $post->save();
            return $this->resultRedirect->create()->setPath('helloworld/post/index');
        }catch (\Exception $e){
            $this->getMessageManager()->addErrorMessage(__('Save thất bại.'));
        }
    }
}
 
 Magento 2 Hướng dẫn Thêm, Xóa, Sửa dữ liệu(CRUD)
 Magento 2 Hướng dẫn Thêm, Xóa, Sửa dữ liệu(CRUD)
Ở trên tôi dùng $this->getRequest()->getPostValue() để lấy được dữ liệu khi submit gửi lên. Sau đó tôi kiểm tra xem trong dữ liệu gửi lên có id hay không. Nếu có tức là đang edit, nếu không tức là thêm mới. Sau đó dùng model để lưu dữ liệu vào database, thêm câu thông báo sau đó chuyển hướng trang về grid.
Delete dữ liệu
Khi chúng ta tạo grid listing ở bài trước chúng ta đã thêm selectionsColumn và delete action dẫn đến controller helloworld/post/index như hình bên dưới:
 Magento 2 Hướng dẫn Thêm, Xóa, Sửa dữ liệu(CRUD)
ViMagento/HelloWorld/Controller/Adminhtml/Post/Delete.php

 
<?php
 
namespace ViMagento\HelloWorld\Controller\Adminhtml\Post;
 
use Magento\Backend\App\Action;
use ViMagento\HelloWorld\Model\ResourceModel\Post\CollectionFactory;
use ViMagento\HelloWorld\Model\PostFactory;
use Magento\Ui\Component\MassAction\Filter;
use Magento\Backend\Model\View\Result\RedirectFactory;
 
class Delete extends Action
{
    private $postFactory;
    private $filter;
    private $collectionFactory;
    private $resultRedirect;
 
    public function __construct(
        Action\Context $context,
        PostFactory $postFactory,
        Filter $filter,
        CollectionFactory $collectionFactory,
        RedirectFactory $redirectFactory
    )
    {
        parent::__construct($context);
        $this->postFactory = $postFactory;
        $this->filter = $filter;
        $this->collectionFactory = $collectionFactory;
        $this->resultRedirect = $redirectFactory;
    }
 
    public function execute()
    {
        $collection = $this->filter->getCollection($this->collectionFactory->create());
        $total = 0;
        $err = 0;
        foreach ($collection->getItems() as $item) {
            $deletePost = $this->postFactory->create()->load($item->getData('post_id'));
            try {
                $deletePost->delete();
                $total++;
            } catch (LocalizedException $exception) {
                $err++;
            }
        }
 
        if ($total) {
            $this->messageManager->addSuccessMessage(
                __('A total of %1 record(s) have been deleted.', $total)
            );
        }
 
        if ($err) {
            $this->messageManager->addErrorMessage(
                __(
                    'A total of %1 record(s) haven\'t been deleted. Please see server logs for more details.',
                    $err
                )
            );
        }
        return $this->resultRedirect->create()->setPath('helloworld/post/index');
    }
}
 
 Magento 2 Hướng dẫn Thêm, Xóa, Sửa dữ liệu(CRUD) Magento 2 Hướng dẫn Thêm, Xóa, Sửa dữ liệu(CRUD)
Sử dụng filter class để lấy được các record mà chúng ta tick chọn để xóa và dùng model để load id lấy được và dùng ->delete() để xóa. Sau đó thì chuyển hướng về trang grid của chúng ta. Ở bài sau tôi sẽ hướng dẫn các bạn tạo column edit trong grid dùng để chuyển đến trang edit.
 
[Magento 2 cơ bản] Tìm hiểu về Events và Observers trong Magento 2
bởi Admin 22/08/2020 0 Bình luận 92 xem
Làm việc với Events và Observers là một trong những cách để mở rộng chức năng của Magento. Bằng cách sử dụng Events và Observers bạn có thể chạy code của mình khi một event của Magento được gửi đi hoặc thậm chí là Event của các bạn tự tạo.
Events
Events được gửi bởi module khi một hành động nhất định được kích hoạt. Ngoài ra, Magento còn cho phép bạn tạo Events và có thể gửi đi trong code của mình. Khi một Events được gửi đi nó có thể truyền bất kỳ dữ liệu cho Observes bắt nó.
Dispatch Event
Events được gửi đi bằng cách sử dụng class Magento\Framework\Event\ManagerInterface. Để gửi một Event bạn cần sử dụng class  event manager gọi phương thức dispatch, cung cấp tên Event và một mảng dữ liệu mà bạn muốn gửi đi cho Observer.
Ví dụ sau tôi gửi một event có tên vimagento_post_before_save và có truyền thêm dữ liệu cho Observer:

	 
<?php
 
namespace ViMagento\HelloWorld\Controller\Adminhtml\Post;
 
use Magento\Backend\App\Action;
use ViMagento\HelloWorld\Model\PostFactory;
use Magento\Backend\Model\View\Result\RedirectFactory;
 
class Save extends Action
{
    private $resultRedirect;
    private $postFactory;
 
    public function __construct(
        Action\Context $context,
        PostFactory $postFactory,
        RedirectFactory $redirectFactory
    )
    {
        parent::__construct($context);
        $this->postFactory = $postFactory;
        $this->resultRedirect = $redirectFactory;
    }
 
    public function execute()
    {
        $data = $this->getRequest()->getPostValue();
        $id = !empty($data['post_id']) ? $data['post_id'] : null;
 
        $newData = [
            'name' => $data['name'],
            'status' => $data['status'],
            'content' => $data['content'],
        ];
 
        $post = $this->postFactory->create();
        if ($id) {
            $post->load($id);
            $this->getMessageManager()->addSuccessMessage(__('Edit thành công'));
        } else {
            $this->getMessageManager()->addSuccessMessage(__('Save thành công.'));
        }
        try {
            $post->addData($newData);
            $this->_eventManager->dispatch("vimagento_post_before_save", ['postData' => $post]);
            $post->save();
            return $this->resultRedirect->create()->setPath('helloworld/post/index');
        }catch (\Exception $e){
            $this->getMessageManager()->addErrorMessage(__('Save thất bại.'));
        }
    }
}
 
Lưu ý đoạn code này là để gửi Event trước khi save:

 
$this->_eventManager->dispatch("vimagento_post_before_save", ['postData' => $post]);
 
Cách bắt và xử lý Events
Phạm vi của Events
Sẽ có ba phạm vi của dùng để quản lý Events:
▪	Thư mục etc/ là cấu hình có thể được sử dụng cho cả frontend và backend
▪	Thư mục etc/adminhtml được sử dụng ở phạm vi backend
▪	Thư mục etc/frontend được sử dụng ở phạm vi frontend
Như ở trên ta có thể cấu hình Events tương ứng với các phạm vi trên:
▪	ViMagento/HelloWorld/etc/events.xml
▪	ViMagento/HelloWorld/etc/adminhtml/events.xml
▪	ViMagento/HelloWorld/etc/frontend/events.xml
Tạo events.xml
ViMagento/HelloWorld/etc/adminhtml/events.xml

	 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Event/etc/events.xsd">
    <event name="vimagento_post_before_save">
        <observer name="vimagento_post_change_name" instance="ViMagento\HelloWorld\Observer\ChangeName" />
    </event>
</config>
 
File trên tôi đã bắt sự kiện có tên vimagento_post_before_save đã được gửi đi ở trên và định nghĩa class ChangeName là Observer để bắt sự kiện và thực thi code mở rộng của chúng ta ở đây. Điều này có nghĩa là mỗi khi events được gửi đi, Magento sẽ xem có Observer nào đang bắt Event này không. Nếu có thì Magento sẽ thực thi class đó. Ở đây là class ChangeName.
Tạo Observers
ViMagento/HelloWorld/Observer/ChangeName.php
 
<?php
 
namespace ViMagento\HelloWorld\Observer;
 
use Magento\Framework\Event\Observer;
 
class ChangeName implements \Magento\Framework\Event\ObserverInterface
{
    public function execute(Observer $observer)
    {
        $data = $observer->getData('postData');
        $data->setData('name', 'Tôi đã thay đổi dữ liệu cột name khi dữ liệu được gửi.');
        $observer->setData('postData', $data);
    }
}
 
Cuối cùng các bạn xóa cache php bin/magento cache:clean
 Tìm hiểu về Events và Observers trong Magento 2
Và tôi đã thêm mới một record với name là bài 7
 Tìm hiểu về Events và Observers trong Magento 2
Ở trên tôi đã sử dụng observer ChangeName để bắt sự kiện có tên vimagento_post_before_save và sử đổi cột name thành dòng chữ mong muốn. Nếu các bạn có thắc mắc gì có thể để lại bình luận để mọi người cùng góp ý nhé.
 
Tất tần tật danh sách các Events trong Magento 2
bởi Admin 22/08/2020 0 Bình luận 92 xem
Nguồn: https://www.mageplaza.com/magento-2-module-development/magento-2-events.html#list-all-events-in-magento-2
▪	Event name: sales_quote_remove_item
▪	File: vendor/magento/Collect/Model/Quote.php


    $this->_eventManager->dispatch('sales_quote_remove_item', ['quote_item' => $item]);
 
 
 
▪	Event name: sales_quote_add_item
▪	File: vendor/magento/Collect/Model/Quote.php


    $this->_eventManager->dispatch('sales_quote_add_item', ['quote_item' => $item]);
 
▪	Event name: sales_quote_product_add_after
▪	File: vendor/magento/Collect/Model/Quote.php


    $this->_eventManager->dispatch('sales_quote_product_add_after', ['items' => $items]);
 
 
 
▪	Event name: _merge_before
▪	File: vendor/magento/Collect/Model/Quote.php

 
 
    $this->_eventManager->dispatch(
        $this->_eventPrefix . '_merge_before',
        [$this->_eventObject => $this, 'source' => $quote]
    );
 
 
 
▪	Event name: _merge_after
▪	File: vendor/magento/Collect/Model/Quote.php
 
    $this->_eventManager->dispatch(
        $this->_eventPrefix . '_merge_after',
        [$this->_eventObject => $this, 'source' => $quote]
    );
 
 
 
▪	Event name: sales_quote_item_qty_set_after
▪	File: vendor/magento/Collect/Model/Quote/Item.php

     $this->_eventManager->dispatch('sales_quote_item_qty_set_after', ['item' => $this]);
 
 
 
▪	Event name: sales_quote_item_set_product
▪	File: vendor/magento/Collect/Model/Quote/Item.php


    $this->_eventManager->dispatch(
        'sales_quote_item_set_product',
        ['product' => $product, 'quote_item' => $this]
    );
 
 
 
▪	Event name: _import_data_before
▪	File: vendor/magento/Collect/Model/Quote/Payment.php

    $this->_eventManager->dispatch(
        $this->_eventPrefix . '_import_data_before',
        [$this->_eventObject => $this, 'input' => $data]
    );
 
 
 
▪	Event name: _load_after
▪	File: vendor/magento/Collect/Model/ResourceModel/Quote/Address/Collection.php

    $this->_eventManager->dispatch($this->_eventPrefix . '_load_after', [$this->_eventObject => $this]);
 
 
 
▪	Event name: prepare_catalog_product_collection_prices
▪	File: vendor/magento/Collect/Model/ResourceModel/Quote/Item/Collection.php


    $this->_eventManager->dispatch(
        'prepare_catalog_product_collection_prices',
        ['collection' => $productCollection, 'store_id' => $this->getStoreId()]
    );
 
 
 
▪	Event name: sales_quote_item_collection_products_after_load
▪	File: vendor/magento/Collect/Model/ResourceModel/Quote/Item/Collection.php


    $this->_eventManager->dispatch(
        'sales_quote_item_collection_products_after_load',
        ['collection' => $productCollection]
    );
 
 
 
▪	Event name: controller_front_send_response_before
▪	File: vendor/magento/framework/App/Http.php

    $this->_eventManager->dispatch('controller_front_send_response_before', $eventParams);
 
 
▪	Event name: controller_action_layout_render_before
▪	File: vendor/magento/framework/App/View.php

    $this->_eventManager->dispatch('controller_action_layout_render_before');
 
▪	Event name: controller_action_layout_render_before_
▪	File: vendor/magento/framework/App/View.php
 
 
    $this->_eventManager->dispatch(
        'controller_action_layout_render_before_' . $this->_request->getFullActionName()
    );
 
▪	Event name: controller_action_predispatch
▪	File: vendor/magento/framework/App/Action/Action.php

    $this->_eventManager->dispatch('controller_action_predispatch', $eventParameters);
 
 
 
▪	Event name: controller_action_predispatch_
▪	File: vendor/magento/framework/App/Action/Action.php

    $this->_eventManager->dispatch('controller_action_predispatch_' . $request->getRouteName(), $eventParameters);
 
 
 
▪	Event name: controller_action_predispatch_
▪	File: vendor/magento/framework/App/Action/Action.php

    $this->_eventManager->dispatch(
        'controller_action_predispatch_' . $request->getFullActionName(),
        $eventParameters
    );
 
 
 
▪	Event name: controller_action_postdispatch_
▪	File: vendor/magento/framework/App/Action/Action.php

    $this->_eventManager->dispatch(
      'controller_action_postdispatch_' . $request->getFullActionName(),
        $eventParameters
    );
 
 
 
▪	Event name: controller_action_postdispatch_
▪	File: vendor/magento/framework/App/Action/Action.php


    $this->_eventManager->dispatch(
           'controller_action_postdispatch_' . $request->getRouteName(),
           $eventParameters
    );
 
 
 
▪	Event name: controller_action_postdispatch
▪	File: vendor/magento/framework/App/Action/Action.php

    $this->_eventManager->dispatch('controller_action_postdispatch', $eventParameters);
 
 
 
▪	Event name: controller_action_noroute
▪	File: vendor/magento/framework/Controller/Noroute/Index.php

    $this->_eventManager->dispatch('controller_action_noroute', ['action' => $this, 'status' => $status]);
 
 
 
▪	Event name: currency_display_options_forming
▪	File: vendor/magento/framework/Locale/Currency.php

    $this->_eventManager->dispatch(
       'currency_display_options_forming',
       ['currency_options' => $options, 'base_code' => $currency]
    );
 
 
 
▪	Event name: model_load_before
▪	File: vendor/magento/framework/Model/AbstractModel.php

    $this->_eventManager->dispatch('model_load_before', $params);
 
 
 
▪	Event name: _load_before
▪	File: vendor/magento/framework/Model/AbstractModel.php

     $this->_eventManager->dispatch($this->_eventPrefix . '_load_before', $params);
 
 
 
▪	Event name: model_load_after
▪	File: vendor/magento/framework/Model/AbstractModel.php

     $this->_eventManager->dispatch('model_load_after', ['object' => $this]);
 
 
 
▪	Event name: _load_after
▪	File: vendor/magento/framework/Model/AbstractModel.php

    $this->_eventManager->dispatch($this->_eventPrefix . '_load_after', $this->_getEventData());
 
 
 
▪	Event name: model_save_commit_after
▪	File: vendor/magento/framework/Model/AbstractModel.php

    $this->_eventManager->dispatch('model_save_commit_after', ['object' => $this]);
 
 
 
▪	Event name: _save_commit_after
▪	File: vendor/magento/framework/Model/AbstractModel.php

    $this->_eventManager->dispatch($this->_eventPrefix . '_save_commit_after', $this->_getEventData());
 
 
 
▪	Event name: model_save_before
▪	File: vendor/magento/framework/Model/AbstractModel.php

    $this->_eventManager->dispatch('model_save_before', ['object' => $this]);
 
 
 
▪	Event name: _save_before
▪	File: vendor/magento/framework/Model/AbstractModel.php

    $this->_eventManager->dispatch($this->_eventPrefix . '_save_before', $this->_getEventData());
 
 
 
▪	Event name: model_save_after
▪	File: vendor/magento/framework/Model/AbstractModel.php


    $this->_eventManager->dispatch('model_save_after', ['object' => $this]);
 
 
 
▪	Event name: clean_cache_by_tags
▪	File: vendor/magento/framework/Model/AbstractModel.php

 
 
    $this->_eventManager->dispatch('clean_cache_by_tags', ['object' => $this]);
 
 
 
▪	Event name: _save_after
▪	File: vendor/magento/framework/Model/AbstractModel.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_save_after', $this->_getEventData());
 
 
 
▪	Event name: model_delete_before
▪	File: vendor/magento/framework/Model/AbstractModel.php

 
 
    $this->_eventManager->dispatch('model_delete_before', ['object' => $this]);
 
 
 
▪	Event name: _delete_before
▪	File: vendor/magento/framework/Model/AbstractModel.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_delete_before', $this->_getEventData());
 
 
 
▪	Event name: model_delete_after
▪	File: vendor/magento/framework/Model/AbstractModel.php

 
 
    $this->_eventManager->dispatch('model_delete_after', ['object' => $this]);
 
 
 
▪	Event name: clean_cache_by_tags
▪	File: vendor/magento/framework/Model/AbstractModel.php

 
 
    $this->_eventManager->dispatch('clean_cache_by_tags', ['object' => $this]);
 
 
 
▪	Event name: _delete_after
▪	File: vendor/magento/framework/Model/AbstractModel.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_delete_after', $this->_getEventData());
 
 
 
▪	Event name: model_delete_commit_after
▪	File: vendor/magento/framework/Model/AbstractModel.php

 
 
    $this->_eventManager->dispatch('model_delete_commit_after', ['object' => $this]);
 
 
 
▪	Event name: _delete_commit_after
▪	File: vendor/magento/framework/Model/AbstractModel.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_delete_commit_after', $this->_getEventData());
 
 
 
▪	Event name: _clear
▪	File: vendor/magento/framework/Model/AbstractModel.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_clear', $this->_getEventData());
 
 
 
▪	Event name: _clear
▪	File: vendor/magento/framework/Model/AbstractModel.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_clear', $this->_getEventData());
 
 
 
▪	Event name: core_collection_abstract_load_before
▪	File: vendor/magento/framework/Model/ResourceModel/Db/Collection/AbstractCollection.php

 
 
    $this->_eventManager->dispatch('core_collection_abstract_load_before', ['collection' => $this]);
 
 
 
▪	Event name: _load_before
▪	File: vendor/magento/framework/Model/ResourceModel/Db/Collection/AbstractCollection.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_load_before', [$this->_eventObject => $this]);
 
 
 
▪	Event name: core_collection_abstract_load_after
▪	File: vendor/magento/framework/Model/ResourceModel/Db/Collection/AbstractCollection.php

 
 
    $this->_eventManager->dispatch('core_collection_abstract_load_after', ['collection' => $this]);
 
 
 
▪	Event name: _load_after
▪	File: vendor/magento/framework/Model/ResourceModel/Db/Collection/AbstractCollection.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_load_after', [$this->_eventObject => $this]);
 
 
 
▪	Event name: core_layout_render_element
▪	File: vendor/magento/framework/View/Layout.php


	 
 
    $this->_eventManager->dispatch(
            'core_layout_render_element',
            ['element_name' => $name, 'layout' => $this, 'transport' => $this->_renderingOutput]
        );
 
 
 
▪	Event name: view_block_abstract_to_html_before
▪	File: vendor/magento/framework/View/Element/AbstractBlock.php

 
 
    $this->_eventManager->dispatch('view_block_abstract_to_html_before', ['block' => $this]);
 
 
 
▪	Event name: view_message_block_render_grouped_html_after
▪	File: vendor/magento/framework/View/Element/Messages.php

 
 
    $this->_eventManager->dispatch('view_message_block_render_grouped_html_after', $params);
 
 
 
▪	Event name: adminhtml_block_html_before
▪	File: vendor/magento/module-backend/Block/Template.php

 
 
    $this->_eventManager->dispatch('adminhtml_block_html_before', ['block' => $this]);
 
 
 
▪	Event name: adminhtml_store_edit_form_prepare_form
▪	File: vendor/magento/module-backend/Block/System/Store/Edit/AbstractForm.php

 
 
    $this->_eventManager->dispatch('adminhtml_store_edit_form_prepare_form', ['block' => $this]);
 
 
 
▪	Event name: backend_block_widget_grid_prepare_grid_before
▪	File: vendor/magento/module-backend/Block/Widget/Grid.php


	 
 
    $this->_eventManager->dispatch(
            'backend_block_widget_grid_prepare_grid_before',
            ['grid' => $this, 'collection' => $this->getCollection()]
        );
 
 
 
▪	Event name: clean_catalog_images_cache_after
▪	File: vendor/magento/module-backend/Controller/Adminhtml/Cache/CleanImages.php

 
 
    $this->_eventManager->dispatch('clean_catalog_images_cache_after');
 
 
 
▪	Event name: clean_media_cache_after
▪	File: vendor/magento/module-backend/Controller/Adminhtml/Cache/CleanMedia.php

 
 
    $this->_eventManager->dispatch('clean_media_cache_after');
 
 
 
▪	Event name: clean_static_files_cache_after
▪	File: vendor/magento/module-backend/Controller/Adminhtml/Cache/CleanStaticFiles.php

 
 
    $this->_eventManager->dispatch('clean_static_files_cache_after');
 
 
 
▪	Event name: adminhtml_cache_flush_all
▪	File: vendor/magento/module-backend/Controller/Adminhtml/Cache/FlushAll.php

 
 
    $this->_eventManager->dispatch('adminhtml_cache_flush_all');
 
 
 
▪	Event name: adminhtml_cache_flush_system
▪	File: vendor/magento/module-backend/Controller/Adminhtml/Cache/FlushSystem.php

 
 
    $this->_eventManager->dispatch('adminhtml_cache_flush_system');
 
 
 
▪	Event name: theme_save_after
▪	File: vendor/magento/module-backend/Controller/Adminhtml/System/Design/Save.php

 
 
    $this->_eventManager->dispatch('theme_save_after');
 
 
 
▪	Event name: store_delete
▪	File: vendor/magento/module-backend/Controller/Adminhtml/System/Store/DeleteStorePost.php

 
 
    $this->_eventManager->dispatch('store_delete', ['store' => $model]);
 
 
 
▪	Event name: store_group_save
▪	File: vendor/magento/module-backend/Controller/Adminhtml/System/Store/Save.php

 
 
    $this->_eventManager->dispatch('store_group_save', ['group' => $groupModel]);
 
 
 
▪	Event name: store_edit
▪	File: vendor/magento/module-backend/Controller/Adminhtml/System/Store/Save.php

 
    $eventName = 'store_edit';
    $this->_eventManager->dispatch($eventName, ['store' => $storeModel]);
 
 
 
▪	Event name: store_add
▪	File: vendor/magento/module-backend/Controller/Adminhtml/System/Store/Save.php

 
    $eventName = 'store_add';
    $this->_eventManager->dispatch($eventName, ['store' => $storeModel]);
 
 
 
▪	Event name: backend_auth_user_login_success
▪	File: vendor/magento/module-backend/Model/Auth.php


	 
 
    $this->_eventManager->dispatch(
        'backend_auth_user_login_success',
        ['user' => $this->getCredentialStorage()]
    );
 
 
 
▪	Event name: backend_auth_user_login_failed
▪	File: vendor/magento/module-backend/Model/Auth.php


	 
 
    $this->_eventManager->dispatch(
        'backend_auth_user_login_failed',
        ['user_name' => $username, 'exception' => $e]
    );
 
 
 
▪	Event name: catalog_product_option_price_configuration_after
▪	File: vendor/magento/module-bundle/Block/Catalog/Product/View/Type/Bundle.php

 
 
    $this->_eventManager->dispatch('catalog_product_option_price_configuration_after', ['configObj' => $configObj]);
 
 
 
▪	Event name: prepare_catalog_product_collection_prices
▪	File: vendor/magento/module-bundle/Model/Product/Price.php


	 
 
    $this->_eventManager->dispatch(
        'prepare_catalog_product_collection_prices',
        ['collection' => $selections, 'store_id' => $product->getStoreId()]
    );
 
 
 
▪	Event name: catalog_product_get_final_price
▪	File: vendor/magento/module-bundle/Model/Product/Price.php

 
 
    $this->_eventManager->dispatch('catalog_product_get_final_price', ['product' => $product, 'qty' => $qty]);
 
 
 
▪	Event name: catalog_product_prepare_index_select
▪	File: vendor/magento/module-bundle/Model/ResourceModel/Indexer/Price.php
	 
 
        $this->_eventManager->dispatch(
            'catalog_product_prepare_index_select',
            [
                'select' => $select,
                'entity_field' => new \Zend_Db_Expr('e.entity_id'),
                'website_field' => new \Zend_Db_Expr('cw.website_id'),
                'store_field' => new \Zend_Db_Expr('cs.store_id')
            ]
        );
 
 
 
▪	Event name: catalog_product_import_bunch_delete_commit_before
▪	File: vendor/magento/module-catalog-import-export/Model/Import/Product.php 
 
    $this->_eventManager->dispatch(
    'catalog_product_import_bunch_delete_commit_before',
        [
            'adapter' => $this,
            'bunch' => $bunch,
            'ids_to_delete' => $idsToDelete
        ]
    );
 
 
 
▪	Event name: catalog_product_import_bunch_delete_after
▪	File: vendor/magento/module-catalog-import-export/Model/Import/Product.php

 
 
    $this->_eventManager->dispatch('catalog_product_import_bunch_delete_after', ['adapter' => $this, 'bunch' => $bunch]);
 
 
 
▪	Event name: catalog_product_import_finish_before
▪	File: vendor/magento/module-catalog-import-export/Model/Import/Product.php

 
 
    $this->_eventManager->dispatch('catalog_product_import_finish_before', ['adapter' => $this]);
 
 
 
▪	Event name: catalog_product_import_bunch_save_after
▪	File: vendor/magento/module-catalog-import-export/Model/Import/Product.php


	 
 
    $this->_eventManager->dispatch(
        'catalog_product_import_bunch_save_after',
        ['adapter' => $this, 'bunch' => $bunch]
    );
    
 
 
▪	Event name: catalogrule_dirty_notice
▪	File: vendor/magento/module-catalog-rule/Controller/Adminhtml/Promo/Catalog/Index.php


	 
 
        $this->_eventManager->dispatch(
            'catalogrule_dirty_notice',
            ['dirty_rules' => $dirtyRules, 'message' => $this->getDirtyRulesNoticeMessage()]
        );
    
 
 
▪	Event name: adminhtml_controller_catalogrule_prepare_save
▪	File: vendor/magento/module-catalog-rule/Controller/Adminhtml/Promo/Catalog/Save.php


	 
 
    $this->_eventManager->dispatch(
        'adminhtml_controller_catalogrule_prepare_save',
        ['request' => $this->getRequest()]
    );
    
 
 
▪	Event name: clean_cache_by_tags
▪	File: vendor/magento/module-catalog-rule/Model/Indexer/AbstractIndexer.php

 
 
    $this->_eventManager->dispatch('clean_cache_by_tags', ['object' => $this]);
    
 
 
▪	Event name: catalogsearch_reset_search_result
▪	File: vendor/magento/module-catalog-search/Model/ResourceModel/Fulltext.php

 
 
    $this->_eventManager->dispatch('catalogsearch_reset_search_result');
    
 
 
▪	Event name: shortcut_buttons_container
▪	File: vendor/magento/module-catalog/Block/ShortcutButtons.php



	 
 
        $this->_eventManager->dispatch(
            'shortcut_buttons_container',
            [
                'container' => $this,
                'is_catalog_product' => $this->_isCatalogProduct,
                'or_position' => $this->_orPosition
            ]
        );
    
 
 
▪	Event name: adminhtml_catalog_category_tree_is_moveable
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Category/Tree.php

 
 
    $this->_eventManager->dispatch('adminhtml_catalog_category_tree_is_moveable', ['options' => $options]);
    
 
 
▪	Event name: adminhtml_catalog_category_tree_can_add_root_category
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Category/Tree.php


	 
 
    $this->_eventManager->dispatch(
            'adminhtml_catalog_category_tree_can_add_root_category',
            ['category' => $this->getCategory(), 'options' => $options, 'store' => $this->getStore()->getId()]
        );
    
 
 
▪	Event name: adminhtml_catalog_category_tree_can_add_sub_category
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Category/Tree.php


	 
 
        $this->_eventManager->dispatch(
            'adminhtml_catalog_category_tree_can_add_sub_category',
            ['category' => $this->getCategory(), 'options' => $options, 'store' => $this->getStore()->getId()]
        );
    
 
 
▪	Event name: adminhtml_catalog_product_grid_prepare_massaction
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Product/Grid.php

 
 
    $this->_eventManager->dispatch('adminhtml_catalog_product_grid_prepare_massaction', ['block' => $this]);
    
 
 
▪	Event name: product_attribute_grid_build
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Product/Attribute/Grid.php

 
 
    $this->_eventManager->dispatch('product_attribute_grid_build', ['grid' => $this]);
    
 
 
▪	Event name: product_attribute_form_build
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Product/Attribute/Edit/Tab/Advanced.php

 
 
    $this->_eventManager->dispatch('product_attribute_form_build', ['form' => $form]);
    
 
 
▪	Event name: product_attribute_form_build_front_tab
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Product/Attribute/Edit/Tab/Front.php

 
 
    $this->_eventManager->dispatch('product_attribute_form_build_front_tab', ['form' => $form]);
    
 
 
▪	Event name: adminhtml_catalog_product_attribute_edit_frontend_prepare_form
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Product/Attribute/Edit/Tab/Front.php


	 
 
        $this->_eventManager->dispatch(
            'adminhtml_catalog_product_attribute_edit_frontend_prepare_form',
            ['form' => $form, 'attribute' => $attributeObject]
        );
    
 
 
▪	Event name: adminhtml_product_attribute_types
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Product/Attribute/Edit/Tab/Main.php

 
 
    $this->_eventManager->dispatch('adminhtml_product_attribute_types', ['response' => $response]);
    
 
 
▪	Event name: product_attribute_form_build_main_tab
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Product/Attribute/Edit/Tab/Main.php

 
 
    $this->_eventManager->dispatch('product_attribute_form_build_main_tab', ['form' => $form]);
    
 
 
▪	Event name: adminhtml_catalog_product_edit_prepare_form
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Product/Attribute/NewAttribute/Product/Attributes.php

 
 
    $this->_eventManager->dispatch('adminhtml_catalog_product_edit_prepare_form', ['form' => $form]);
    
 
 
▪	Event name: adminhtml_catalog_product_edit_element_types
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Product/Attribute/NewAttribute/Product/Attributes.php

 
 
    $this->_eventManager->dispatch('adminhtml_catalog_product_edit_element_types', ['response' => $response]);
    
 
 
▪	Event name: adminhtml_catalog_product_attribute_set_main_html_before
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Product/Attribute/Set/Main.php


	 
 
        $this->_eventManager->dispatch(
            'adminhtml_catalog_product_attribute_set_main_html_before',
            ['block' => $this]
        );
    
 
 
▪	Event name: adminhtml_catalog_product_attribute_set_toolbar_main_html_before
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Product/Attribute/Set/Toolbar/Main.php


	 
 
        $this->_eventManager->dispatch(
            'adminhtml_catalog_product_attribute_set_toolbar_main_html_before',
            ['block' => $this]
        );
    
 
 
▪	Event name: adminhtml_catalog_product_form_prepare_excluded_field_list
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Product/Edit/Action/Attribute/Tab/Attributes.php


	 
 
    $this->_eventManager->dispatch(
        'adminhtml_catalog_product_form_prepare_excluded_field_list',
        ['object' => $this]
    );
    
 
 
▪	Event name: adminhtml_catalog_product_edit_prepare_form
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Product/Edit/Tab/Attributes.php


	 
 
    $this->_eventManager->dispatch(
        'adminhtml_catalog_product_edit_prepare_form',
        ['form' => $form, 'layout' => $this->getLayout()]
    );
    
 
 
▪	Event name: adminhtml_catalog_product_edit_element_types
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Product/Edit/Tab/Attributes.php

 
 
     $this->_eventManager->dispatch('adminhtml_catalog_product_edit_element_types', ['response' => $response]);
    
 
 
▪	Event name: catalog_product_gallery_prepare_layout
▪	File: vendor/magento/module-catalog/Block/Adminhtml/Product/Helper/Form/Gallery/Content.php

 
 
    $this->_eventManager->dispatch('catalog_product_gallery_prepare_layout', ['block' => $this]);
    
 
 
▪	Event name: catalog_block_product_status_display
▪	File: vendor/magento/module-catalog/Block/Product/AbstractProduct.php

 
 
    $this->_eventManager->dispatch('catalog_block_product_status_display', ['status' => $statusInfo]);
    
 
 
▪	Event name: catalog_block_product_list_collection
▪	File: vendor/magento/module-catalog/Block/Product/ListProduct.php


	 
 
        $this->_eventManager->dispatch(
            'catalog_block_product_list_collection',
            ['collection' => $this->_getProductCollection()]
        );
 
 
 
▪	Event name: catalog_product_view_config
▪	File: vendor/magento/module-catalog/Block/Product/View.php

 
 
    $this->_eventManager->dispatch('catalog_product_view_config', ['response_object' => $responseObject]);
 
 
 
▪	Event name: catalog_product_upsell
▪	File: vendor/magento/module-catalog/Block/Product/ProductList/Upsell.php


	 
 
        $this->_eventManager->dispatch(
            'catalog_product_upsell',
            ['product' => $product, 'collection' => $this->_itemCollection, 'limit' => null]
        );
 
 
 
▪	Event name: catalog_product_option_price_configuration_after
▪	File: vendor/magento/module-catalog/Block/Product/View/Options.php

 
 
    $this->_eventManager->dispatch('catalog_product_option_price_configuration_after', ['configObj' => $configObj]);
 
 
 
▪	Event name: rss_catalog_category_xml_callback
▪	File: vendor/magento/module-catalog/Block/Rss/Category.php

 
 
    $this->_eventManager->dispatch('rss_catalog_category_xml_callback', ['product' => $product]);
 
 
 
▪	Event name: rss_catalog_new_xml_callback
▪	File: vendor/magento/module-catalog/Block/Rss/Product/NewProducts.php


	 
 
    $this->_eventManager->dispatch('rss_catalog_new_xml_callback', [
        'row' => $item->getData(),
        'product' => $item
    ]);
 
 
 
▪	Event name: rss_catalog_special_xml_callback
▪	File: vendor/magento/module-catalog/Block/Rss/Product/Special.php


	 
 
    $this->_eventManager->dispatch('rss_catalog_special_xml_callback', [
        'row' => $item->getData(),
        'product' => $item
    ]);
 
 
 
▪	Event name: category_prepare_ajax_response
▪	File: vendor/magento/module-catalog/Controller/Adminhtml/Category.php


	 
 
        $this->_eventManager->dispatch(
            'category_prepare_ajax_response',
            ['response' => $eventResponse, 'controller' => $this]
        );
 
 
 
▪	Event name: catalog_controller_category_delete
▪	File: vendor/magento/module-catalog/Controller/Adminhtml/Category/Delete.php

 
 
$this->_eventManager->dispatch('catalog_controller_category_delete', ['category' => $category]);
 
 
 
▪	Event name: catalog_category_prepare_save
▪	File: vendor/magento/module-catalog/Controller/Adminhtml/Category/Save.php


	 
 
    $this->_eventManager->dispatch(
        'catalog_category_prepare_save',
        ['category' => $category, 'request' => $this->getRequest()]
    );
 
 
 
▪	Event name: catalog_product_edit_action
▪	File: vendor/magento/module-catalog/Controller/Adminhtml/Product/Edit.php

 
 
    $this->_eventManager->dispatch('catalog_product_edit_action', ['product' => $product]);
 
 
 
▪	Event name: catalog_product_new_action
▪	File: vendor/magento/module-catalog/Controller/Adminhtml/Product/NewAction.php

 
 
    $this->_eventManager->dispatch('catalog_product_new_action', ['product' => $product]);
 
 
 
▪	Event name: controller_action_catalog_product_save_entity_after
▪	File: vendor/magento/module-catalog/Controller/Adminhtml/Product/Save.php


	 
 
    $this->_eventManager->dispatch(
        'controller_action_catalog_product_save_entity_after',
        ['controller' => $this, 'product' => $product]
    );
 
 
 
▪	Event name: catalog_product_to_website_change
▪	File: vendor/magento/module-catalog/Controller/Adminhtml/Product/Action/Attribute/Save.php

 
 
    $this->_eventManager->dispatch('catalog_product_to_website_change', ['products' => $productIds]);
 
 
 
▪	Event name: catalog_controller_category_init_after
▪	File: vendor/magento/module-catalog/Controller/Category/View.php


	 
 
    $this->_eventManager->dispatch(
        'catalog_controller_category_init_after',
        ['category' => $category, 'controller_action' => $this]
    );
 
 
 
▪	Event name: catalog_product_compare_add_product
▪	File: vendor/magento/module-catalog/Controller/Product/Compare/Add.php

 
 
    $this->_eventManager->dispatch('catalog_product_compare_add_product', ['product' => $product]);
 
 
 
▪	Event name: catalog_product_compare_remove_product
▪	File: vendor/magento/module-catalog/Controller/Product/Compare/Remove.php


	 
 
    $this->_eventManager->dispatch(
        'catalog_product_compare_remove_product',
        ['product' => $item]
    );
 
 
 
▪	Event name: catalog_controller_product_init_before
▪	File: vendor/magento/module-catalog/Helper/Product.php


	 
 
        $this->_eventManager->dispatch(
            'catalog_controller_product_init_before',
            ['controller_action' => $controller, 'params' => $params]
        );
 
 
 
▪	Event name: catalog_controller_product_init_after
▪	File: vendor/magento/module-catalog/Helper/Product.php


	 
 
    $this->_eventManager->dispatch(
        'catalog_controller_product_init_after',
        ['product' => $product, 'controller_action' => $controller]
    );
 
 
 
▪	Event name: catalog_controller_product_view
▪	File: vendor/magento/module-catalog/Helper/Product/View.php

 
 
    $this->_eventManager->dispatch('catalog_controller_product_view', ['product' => $product]);
 
 
 
▪	Event name: _move_before
▪	File: vendor/magento/module-catalog/Model/Category.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_move_before', $eventParams);
 
 
 
▪	Event name: _move_after
▪	File: vendor/magento/module-catalog/Model/Category.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_move_after', $eventParams);
 
 
 
▪	Event name: category_move
▪	File: vendor/magento/module-catalog/Model/Category.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . 'category_move', $eventParams);
 
 
 
▪	Event name: clean_cache_by_tags
▪	File: vendor/magento/module-catalog/Model/Category.php

 
 
    $this->_eventManager->dispatch('clean_cache_by_tags', ['object' => $this]);
 
 
 
▪	Event name: _validate_before
▪	File: vendor/magento/module-catalog/Model/Product.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_validate_before', $this->_getEventData());
 
 
 
▪	Event name: _validate_after
▪	File: vendor/magento/module-catalog/Model/Product.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_validate_after', $this->_getEventData());
 
 
 
▪	Event name: catalog_product_is_salable_before
▪	File: vendor/magento/module-catalog/Model/Product.php

 
 
    $this->_eventManager->dispatch('catalog_product_is_salable_before', ['product' => $this]);
 
 
 
▪	Event name: catalog_product_is_salable_after
▪	File: vendor/magento/module-catalog/Model/Product.php


	 
 
        $this->_eventManager->dispatch(
            'catalog_product_is_salable_after',
            ['product' => $this, 'salable' => $object]
        );
 
 
 
▪	Event name: catalog_product_attribute_update_before
▪	File: vendor/magento/module-catalog/Model/Product/Action.php


	 
 
        $this->_eventManager->dispatch(
            'catalog_product_attribute_update_before',
            ['attributes_data' => &$attrData, 'product_ids' => &$productIds, 'store_id' => &$storeId]
        );
 
 
 
▪	Event name: adminhtml_product_attribute_types
▪	File: vendor/magento/module-catalog/Model/Product/Attribute/Source/Inputtype.php

 
 
    $this->_eventManager->dispatch('adminhtml_product_attribute_types', ['response' => $response]);
    
 
 
▪	Event name: catalog_product_type_prepare_%s_options
▪	File: vendor/magento/module-catalog/Model/Product/Type/AbstractType.php



10	 
 
        $eventName = sprintf('catalog_product_type_prepare_%s_options', $processMode);
        $this->_eventManager->dispatch(
            $eventName,
            ['transport' => $transport, 'buy_request' => $buyRequest, 'product' => $product]
        );
    
 
 
▪	Event name: catalog_product_get_final_price
▪	File: vendor/magento/module-catalog/Model/Product/Type/Price.php

 
 
    $this->_eventManager->dispatch('catalog_product_get_final_price', ['product' => $product, 'qty' => $qty]);
    
 
 
▪	Event name: catalog_category_change_products
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Category.php


	 
 
    $this->_eventManager->dispatch(
        'catalog_category_change_products',
        ['category' => $category, 'product_ids' => $productIds]
    );
    
 
 
▪	Event name: catalog_category_delete_after_done
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Category.php


	 
 
        $this->_eventManager->dispatch(
            'catalog_category_delete_after_done',
            ['product' => $object]
        );
    
 
 
▪	Event name: _load_before
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Category/Collection.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_load_before', [$this->_eventObject => $this]);
    
 
 
▪	Event name: _load_after
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Category/Collection.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_load_after', [$this->_eventObject => $this]);
    
 
 
▪	Event name: _add_is_active_filter
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Category/Collection.php


	 
 
        $this->_eventManager->dispatch(
            $this->_eventPrefix . '_add_is_active_filter',
            [$this->_eventObject => $this]
        );
    
 
 
▪	Event name: catalog_category_tree_init_inactive_category_ids
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Category/Flat.php

 
 
    $this->_eventManager->dispatch('catalog_category_tree_init_inactive_category_ids', ['tree' => $this]);
    
 
 
▪	Event name: catalog_category_flat_loadnodes_before
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Category/Flat.php

 
 
    $this->_eventManager->dispatch('catalog_category_flat_loadnodes_before', ['select' => $select]);
    
 
 
▪	Event name: catalog_category_tree_init_inactive_category_ids
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Category/Tree.php
 
 
 
    $this->_eventManager->dispatch('catalog_category_tree_init_inactive_category_ids', ['tree' => $this]);
    
 
 
▪	Event name: _load_before
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Category/Flat/Collection.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_load_before', [$this->_eventObject => $this]);
    
 
 
▪	Event name: _load_after
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Category/Flat/Collection.php

 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_load_after', [$this->_eventObject => $this]);
    
 
 
▪	Event name: _add_is_active_filter
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Category/Flat/Collection.php


	 
 
        $this->_eventManager->dispatch(
            $this->_eventPrefix . '_add_is_active_filter',
            [$this->_eventObject => $this]
        );
    
 
 
▪	Event name: catalog_prepare_price_select
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Product/Collection.php

 
 
    $this->_eventManager->dispatch('catalog_prepare_price_select', $eventArgs);
    
 
 
▪	Event name: catalog_product_collection_load_after
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Product/Collection.php

 
 
    $this->_eventManager->dispatch('catalog_product_collection_load_after', ['collection' => $this]);
    
 
 
▪	Event name: catalog_product_collection_before_add_count_to_categories
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Product/Collection.php
 

	 
 
    $this->_eventManager->dispatch(
        'catalog_product_collection_before_add_count_to_categories',
        ['collection' => $this]
    );
    
 
 
▪	Event name: catalog_product_collection_apply_limitations_after
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Product/Collection.php
 

 
 
        $this->_eventManager->dispatch(
            'catalog_product_collection_apply_limitations_after',
            ['collection' => $this]
        );
 
 
▪	Event name: catalog_product_compare_item_collection_clear
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Product/Compare/Item/Collection.php
 

4
5	 
 
    $this->_eventManager->dispatch('catalog_product_compare_item_collection_clear');
 
 
▪	Event name: prepare_catalog_product_index_select
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Product/Indexer/Eav/AbstractEav.php
 


	 
 
        $this->_eventManager->dispatch(
            'prepare_catalog_product_index_select',
            [
                'select' => $select,
                'entity_field' => new \Zend_Db_Expr('l.parent_id'),
                'website_field' => new \Zend_Db_Expr('cs.website_id'),
                'store_field' => new \Zend_Db_Expr('cs.store_id')
            ]
        );
 
 
▪	Event name: prepare_catalog_product_index_select
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Product/Indexer/Eav/Decimal.php 
 
        $this->_eventManager->dispatch(
            'prepare_catalog_product_index_select',
            [
                'select' => $select,
                'entity_field' => new \Zend_Db_Expr('cpe.entity_id'),
                'website_field' => new \Zend_Db_Expr('cs.website_id'),
                'store_field' => new \Zend_Db_Expr('cs.store_id')
            ]
        );
 
 
 
▪	Event name: prepare_catalog_product_index_select
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Product/Indexer/Eav/Source.php
 
 
        $this->_eventManager->dispatch(
            'prepare_catalog_product_index_select',
            [
                'select' => $select,
                'entity_field' => new \Zend_Db_Expr('pid.entity_id'),
                'website_field' => new \Zend_Db_Expr('pid.website_id'),
                'store_field' => new \Zend_Db_Expr('pid.store_id')
            ]
        );
        
 
 
▪	Event name: prepare_catalog_product_index_select
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Product/Indexer/Eav/Source.php
 


        $this->_eventManager->dispatch(
            'prepare_catalog_product_index_select',
            [
                'select' => $select,
                'entity_field' => new \Zend_Db_Expr('cpe.entity_id'),
                'website_field' => new \Zend_Db_Expr('cs.website_id'),
                'store_field' => new \Zend_Db_Expr('cs.store_id')
            ]
        );
        
 
 
▪	Event name: prepare_catalog_product_index_select
▪	File: vendor/magento/module-catalog/Model/ResourceModel/Product/Indexer/Price/DefaultPrice.php
 



	 
 
        $this->_eventManager->dispatch(
            'prepare_catalog_product_index_select',
            [
                'select' => $select,
                'entity_field' => new \Zend_Db_Expr('e.entity_id'),
                'website_field' => new \Zend_Db_Expr('cw.website_id'),
                'store_field' => new \Zend_Db_Expr('cs.store_id')
            ]
        );
        
 
 
▪	Event name: shortcut_buttons_container
▪	File: vendor/magento/module-checkout/Block/QuoteShortcutButtons.php
 



	 
 
        $this->_eventManager->dispatch(
            'shortcut_buttons_container',
            [
                'container' => $this,
                'is_catalog_product' => $this->_isCatalogProduct,
                'or_position' => $this->_orPosition,
                'checkout_session' => $this->_checkoutSession
            ]
        );
        
 
 
▪	Event name: checkout_cart_add_product_complete
▪	File: vendor/magento/module-checkout/Controller/Cart/Add.php
 

	 
 
            $this->_eventManager->dispatch(
                'checkout_cart_add_product_complete',
                ['product' => $product, 'request' => $this->getRequest(), 'response' => $this->getResponse()]
            );
        
 
 
▪	Event name: checkout_cart_update_item_complete
▪	File: vendor/magento/module-checkout/Controller/Cart/UpdateItemOptions.php
 

	 
 
            $this->_eventManager->dispatch(
                'checkout_cart_update_item_complete',
                ['item' => $item, 'request' => $this->getRequest(), 'response' => $this->getResponse()]
            );
        
 
 
▪	Event name: checkout_controller_onepage_saveOrder
▪	File: vendor/magento/module-checkout/Controller/Onepage/SaveOrder.php
 


 
 
    $this->_eventManager->dispatch(
        'checkout_controller_onepage_saveOrder',
        [
            'result' => $result,
            'action' => $this
        ]
    );
        
 
 
▪	Event name: checkout_onepage_controller_success_action
▪	File: vendor/magento/module-checkout/Controller/Onepage/Success.php
 

	 
 
    $this->_eventManager->dispatch(
        'checkout_onepage_controller_success_action',
        ['order_ids' => [$session->getLastOrderId()]]
    );
        
 
 
▪	Event name: checkout_allow_guest
▪	File: vendor/magento/module-checkout/Helper/Data.php
 

	 
 
    $this->_eventManager->dispatch(
        'checkout_allow_guest',
        ['quote' => $quote, 'store' => $store, 'result' => $result]
    );
        
 
 
▪	Event name: checkout_cart_product_add_after
▪	File: vendor/magento/module-checkout/Model/Cart.php
 

	 
 
    $this->_eventManager->dispatch(
        'checkout_cart_product_add_after',
        ['quote_item' => $result, 'product' => $product]
    );
        
 
 
▪	Event name: checkout_cart_update_items_before
▪	File: vendor/magento/module-checkout/Model/Cart.php
 

	 
 
    $this->_eventManager->dispatch(
        'checkout_cart_update_items_before',
        ['cart' => $this, 'info' => $infoDataObject]
    );
        
 
 
▪	Event name: checkout_cart_update_items_after
▪	File: vendor/magento/module-checkout/Model/Cart.php
 


10	 
 
    $this->_eventManager->dispatch(
        'checkout_cart_update_items_after',
        ['cart' => $this, 'info' => $infoDataObject]
    );
 
        
 
 
▪	Event name: checkout_cart_save_before
▪	File: vendor/magento/module-checkout/Model/Cart.php
 
 
 
    $this->_eventManager->dispatch('checkout_cart_save_before', ['cart' => $this]);
        
 
 
▪	Event name: checkout_cart_save_after
▪	File: vendor/magento/module-checkout/Model/Cart.php
 
 
 
    $this->_eventManager->dispatch('checkout_cart_save_after', ['cart' => $this]);
        
 
 
▪	Event name: checkout_cart_product_update_after
▪	File: vendor/magento/module-checkout/Model/Cart.php
 

	 
 
    $this->_eventManager->dispatch(
        'checkout_cart_product_update_after',
        ['quote_item' => $result, 'product' => $product]
    );
        
 
 
▪	Event name: custom_quote_process
▪	File: vendor/magento/module-checkout/Model/Session.php
 
 
 
    $this->_eventManager->dispatch('custom_quote_process', ['checkout_session' => $this]);
        
 
 
▪	Event name: checkout_quote_init
▪	File: vendor/magento/module-checkout/Model/Session.php
 
 
 
    $this->_eventManager->dispatch('checkout_quote_init', ['quote' => $quote]);
        
 
 
▪	Event name: load_customer_quote_before
▪	File: vendor/magento/module-checkout/Model/Session.php
 
 
 
    $this->_eventManager->dispatch('load_customer_quote_before', ['checkout_session' => $this]);
        
 
 
▪	Event name: checkout_quote_destroy
▪	File: vendor/magento/module-checkout/Model/Session.php
 
 
 
    $this->_eventManager->dispatch('checkout_quote_destroy', ['quote' => $this->getQuote()]);
        
 
 
▪	Event name: restore_quote
▪	File: vendor/magento/module-checkout/Model/Session.php
 
 
 
    $this->_eventManager->dispatch('restore_quote', ['order' => $order, 'quote' => $quote]);
        
 
 
▪	Event name: checkout_type_onepage_save_order_after
▪	File: vendor/magento/module-checkout/Model/Type/Onepage.php
 

	 
 
    $this->_eventManager->dispatch(
        'checkout_type_onepage_save_order_after',
        ['order' => $order, 'quote' => $this->getQuote()]
    );
 
 
 
▪	Event name: checkout_submit_all_after
▪	File: vendor/magento/module-checkout/Model/Type/Onepage.php
 


 
 
    $this->_eventManager->dispatch(
        'checkout_submit_all_after',
        [
            'order' => $order,
            'quote' => $this->getQuote()
        ]
    );
 
 
 
▪	Event name: cms_controller_router_match_before
▪	File: vendor/magento/module-cms/Controller/Router.php
 

	 
 
    $this->_eventManager->dispatch(
        'cms_controller_router_match_before',
        ['router' => $this, 'condition' => $condition]
    );
 
 
 
▪	Event name: adminhtml_cmspage_on_delete
▪	File: vendor/magento/module-cms/Controller/Adminhtml/Page/Delete.php
 

	 
 
    $this->_eventManager->dispatch(
        'adminhtml_cmspage_on_delete',
        ['title' => $title, 'status' => 'success']
    );
 
 
 
▪	Event name: adminhtml_cmspage_on_delete
▪	File: vendor/magento/module-cms/Controller/Adminhtml/Page/Delete.php
 

	 
 
    $this->_eventManager->dispatch(
        'adminhtml_cmspage_on_delete',
        ['title' => $title, 'status' => 'fail']
    );
 
 
 
▪	Event name: cms_page_prepare_save
▪	File: vendor/magento/module-cms/Controller/Adminhtml/Page/Save.php
 

	 
 
    $this->_eventManager->dispatch(
        'cms_page_prepare_save',
        ['page' => $model, 'request' => $this->getRequest()]
    );
 
 
 
▪	Event name: cms_page_render
▪	File: vendor/magento/module-cms/Helper/Page.php
 

	 
 
    $this->_eventManager->dispatch(
        'cms_page_render',
        ['page' => $this->_page, 'controller_action' => $action]
    );
 
 
 
▪	Event name: cms_wysiwyg_images_static_urls_allowed
▪	File: vendor/magento/module-cms/Helper/Wysiwyg/Images.php
 

	 
 
    $this->_eventManager->dispatch(
        'cms_wysiwyg_images_static_urls_allowed',
        ['result' => $checkResult, 'store_id' => $this->_storeId]
    );
 
 
 
▪	Event name: adminhtml_system_config_advanced_disableoutput_render_before
▪	File: vendor/magento/module-config/Block/System/Config/Form/Fieldset/Modules/DisableOutput.php
 

	 
 
    $this->_eventManager->dispatch(
        'adminhtml_system_config_advanced_disableoutput_render_before',
        ['modules' => $dispatchResult]
    );
 
 
 
▪	Event name: admin_system_config_changed_section_
▪	File: vendor/magento/module-config/Model/Config.php
 

	 
 
    $this->_eventManager->dispatch(
        "admin_system_config_changed_section_{$this->getSection()}",
        ['website' => $this->getWebsite(), 'store' => $this->getStore()]
    );
 
 
 
▪	Event name: controller_action_nocookies
▪	File: vendor/magento/module-cookie/Controller/Index/NoCookies.php
 

	 
 
    $this->_eventManager->dispatch(
        'controller_action_nocookies',
        ['action' => $this, 'redirect' => $redirect]
    );
 
 
 
▪	Event name: admin_system_config_changed_section_currency_before_reinit
▪	File: vendor/magento/module-currency-symbol/Model/System/Currencysymbol.php
 

	 
 
    $this->_eventManager->dispatch(
        'admin_system_config_changed_section_currency_before_reinit',
        ['website' => $this->_websiteId, 'store' => $this->_storeId]
    );
 
 
 
▪	Event name: adminhtml_block_html_before
▪	File: vendor/magento/module-customer/Block/Adminhtml/Edit/Tab/Carts.php
 
 
 
    $this->_eventManager->dispatch('adminhtml_block_html_before', ['block' => $this]);
 
 
 
▪	Event name: customer_register_success
▪	File: vendor/magento/module-customer/Controller/Account/CreatePost.php
 

	 
 
    $this->_eventManager->dispatch(
        'customer_register_success',
        ['account_controller' => $this, 'customer' => $customer]
    );
 
 
 
▪	Event name: customer_account_edited
▪	File: vendor/magento/module-customer/Controller/Account/EditPost.php
 

	 
 
    $this->_eventManager->dispatch(
        'customer_account_edited',
        ['email' => $customerCandidateDataObject->getEmail()]
    );
 
 
 
▪	Event name: adminhtml_customer_prepare_save
▪	File: vendor/magento/module-customer/Controller/Adminhtml/Index/Save.php
 

	 
 
    $this->_eventManager->dispatch(
        'adminhtml_customer_prepare_save',
        ['customer' => $customer, 'request' => $this->getRequest()]
    );
 
 
 
▪	Event name: adminhtml_customer_save_after
▪	File: vendor/magento/module-customer/Controller/Adminhtml/Index/Save.php
 

	 
 
    $this->_eventManager->dispatch(
        'adminhtml_customer_save_after',
        ['customer' => $customer, 'request' => $this->getRequest()]
    );
 
 
 
▪	Event name: customer_customer_authenticated
▪	File: vendor/magento/module-customer/Model/Customer.php
 

	 
 
    $this->_eventManager->dispatch(
        'customer_customer_authenticated',
        ['model' => $this, 'password' => $password]
    );
 
 
 
▪	Event name: customer_session_init
▪	File: vendor/magento/module-customer/Model/Session.php
 
 
 
    $this->_eventManager->dispatch('customer_session_init', ['customer_session' => $this]);
 
 
 
▪	Event name: customer_login
▪	File: vendor/magento/module-customer/Model/Session.php
 
 
 
    $this->_eventManager->dispatch('customer_login', ['customer' => $customer]);
 
 
 
▪	Event name: customer_data_object_login
▪	File: vendor/magento/module-customer/Model/Session.php
 
 
 
    $this->_eventManager->dispatch('customer_data_object_login', ['customer' => $this->getCustomerDataObject()]);
 
 
 
▪	Event name: customer_logout
▪	File: vendor/magento/module-customer/Model/Session.php
 
 
 
    $this->_eventManager->dispatch('customer_logout', ['customer' => $this->getCustomer()]);
 
 
 
▪	Event name: visitor_init
▪	File: vendor/magento/module-customer/Model/Visitor.php
 
 
 
    $this->_eventManager->dispatch('visitor_init', ['visitor' => $this]);
 
 
 
▪	Event name: visitor_activity_save
▪	File: vendor/magento/module-customer/Model/Visitor.php
 
 
 
    $this->_eventManager->dispatch('visitor_activity_save', ['visitor' => $this]);
 
 
 
▪	Event name: customer_address_format
▪	File: vendor/magento/module-customer/Model/Address/AbstractAddress.php
 
 
 
     $this->_eventManager->dispatch('customer_address_format', ['type' => $formatType, 'address' => $this]);
 
 
 
▪	Event name: adminhtml_block_eav_attribute_edit_form_init
▪	File: vendor/magento/module-eav/Block/Adminhtml/Attribute/Edit/Main/AbstractMain.php
 

	 
 
    $this->_eventManager->dispatch(
        'adminhtml_block_eav_attribute_edit_form_init',
        ['form' => $this->getForm()]
    );
 
 
 
▪	Event name: eav_collection_abstract_load_before
▪	File: vendor/magento/module-eav/Model/Entity/Collection/AbstractCollection.php
 
 
 
    $this->_eventManager->dispatch('eav_collection_abstract_load_before', ['collection' => $this]);
 
 
 
▪	Event name: gift_options_prepare_items
▪	File: vendor/magento/module-gift-message/Block/Message/Inline.php
 
 
 
    $this->_eventManager->dispatch('gift_options_prepare_items', ['items' => $entityItems]);
 
 
 
▪	Event name: catalog_product_prepare_index_select
▪	File: vendor/magento/module-grouped-product/Model/ResourceModel/Product/Indexer/Price/Grouped.php
 



	 
 
        $this->_eventManager->dispatch(
            'catalog_product_prepare_index_select',
            [
                'select' => $select,
                'entity_field' => new \Zend_Db_Expr('e.entity_id'),
                'website_field' => new \Zend_Db_Expr('cw.website_id'),
                'store_field' => new \Zend_Db_Expr('cs.store_id')
            ]
        );
 
 
 
▪	Event name: checkout_controller_multishipping_shipping_post
▪	File: vendor/magento/module-multishipping/Controller/Checkout/ShippingPost.php
 

	 
 
    $this->_eventManager->dispatch(
        'checkout_controller_multishipping_shipping_post',
        ['request' => $this->getRequest(), 'quote' => $this->_getCheckout()->getQuote()]
    );
 
 
 
▪	Event name: multishipping_checkout_controller_success_action
▪	File: vendor/magento/module-multishipping/Controller/Checkout/Success.php
 
 
 
    $this->_eventManager->dispatch('multishipping_checkout_controller_success_action', ['order_ids' => $ids]);
 
 
 
▪	Event name: checkout_type_multishipping_set_shipping_items
▪	File: vendor/magento/module-multishipping/Model/Checkout/Type/Multishipping.php
 
 
 
    $this->_eventManager->dispatch('checkout_type_multishipping_set_shipping_items', ['quote' => $quote]);
 
 
 
▪	Event name: checkout_type_multishipping_create_orders_single
▪	File: vendor/magento/module-multishipping/Model/Checkout/Type/Multishipping.php
 

	 
 
    $this->_eventManager->dispatch(
        'checkout_type_multishipping_create_orders_single',
        ['order' => $order, 'address' => $address, 'quote' => $this->getQuote()]
    );
 
 
 
▪	Event name: checkout_submit_all_after
▪	File: vendor/magento/module-multishipping/Model/Checkout/Type/Multishipping.php
 

	 
 
    $this->_eventManager->dispatch(
        'checkout_submit_all_after',
        ['orders' => $orders, 'quote' => $this->getQuote()]
    );
 
 
 
▪	Event name: checkout_multishipping_refund_all
▪	File: vendor/magento/module-multishipping/Model/Checkout/Type/Multishipping.php
 
 
 
    $this->_eventManager->dispatch('checkout_multishipping_refund_all', ['orders' => $orders]);
 
 
 
▪	Event name: payment_form_block_to_html_before
▪	File: vendor/magento/module-payment/Block/Form/Cc.php
 
 
 
    $this->_eventManager->dispatch('payment_form_block_to_html_before', ['block' => $this]);
 
 
 
▪	Event name: payment_cart_collect_items_and_amounts
▪	File: vendor/magento/module-payment/Model/Cart.php
 
 
 
    $this->_eventManager->dispatch('payment_cart_collect_items_and_amounts', ['cart' => $this]);
 
 
 
▪	Event name: payment_method_assign_data_
▪	File: vendor/magento/module-payment/Model/Method/AbstractMethod.php
 


	 
 
    $this->_eventManager->dispatch(
        'payment_method_assign_data_' . $this->getCode(),
        [
            AbstractDataAssignObserver::METHOD_CODE => $this,
            AbstractDataAssignObserver::MODEL_CODE => $this->getInfoInstance(),
            AbstractDataAssignObserver::DATA_CODE => $data
        ]
    );
 
 
 
▪	Event name: payment_method_assign_data
▪	File: vendor/magento/module-payment/Model/Method/AbstractMethod.php
 


	 
 
    $this->_eventManager->dispatch(
        'payment_method_assign_data',
        [
            AbstractDataAssignObserver::METHOD_CODE => $this,
            AbstractDataAssignObserver::MODEL_CODE => $this->getInfoInstance(),
            AbstractDataAssignObserver::DATA_CODE => $data
        ]
    );
 
 
 
▪	Event name: payment_method_is_active
▪	File: vendor/magento/module-payment/Model/Method/AbstractMethod.php
 


	 
 
    $this->_eventManager->dispatch(
        'payment_method_is_active',
        [
            'result' => $checkResult,
            'method_instance' => $this,
            'quote' => $quote
        ]
    );
 
 
 
▪	Event name: paypal_express_place_order_success
▪	File: vendor/magento/module-paypal/Controller/Express/AbstractExpress/PlaceOrder.php
 


 
 
    $this->_eventManager->dispatch(
        'paypal_express_place_order_success',
            [
                    'order' => $order,
                    'quote' => $this->_getQuote()
            ]
    );
 
 
 
▪	Event name: persistent_session_expired
▪	File: vendor/magento/module-persistent/Controller/Index/UnsetCookie.php
 
 
 
    $this->_eventManager->dispatch('persistent_session_expired');
 
 
 
▪	Event name: persistent_session_expired
▪	File: vendor/magento/module-persistent/Observer/CheckExpirePersistentQuoteObserver.php
 
 
 
    $this->_eventManager->dispatch('persistent_session_expired');
 
 
 
▪	Event name: sales_quote_remove_item
▪	File: vendor/magento/module-quote/Model/Quote.php
 
 
 
    $this->_eventManager->dispatch('sales_quote_remove_item', ['quote_item' => $item]);
 
 
 
▪	Event name: sales_quote_add_item
▪	File: vendor/magento/module-quote/Model/Quote.php
 
 
 
    $this->_eventManager->dispatch('sales_quote_add_item', ['quote_item' => $item]);
 
 
 
▪	Event name: sales_quote_product_add_after
▪	File: vendor/magento/module-quote/Model/Quote.php
 
 
 
    $this->_eventManager->dispatch('sales_quote_product_add_after', ['items' => $items]);
 
 
 
▪	Event name: _merge_before
▪	File: vendor/magento/module-quote/Model/Quote.php
 

	 
 
    $this->_eventManager->dispatch(
        $this->_eventPrefix . '_merge_before',
        [$this->_eventObject => $this, 'source' => $quote]
    );
 
 
 
▪	Event name: _merge_after
▪	File: vendor/magento/module-quote/Model/Quote.php
 

	 
 
    $this->_eventManager->dispatch(
        $this->_eventPrefix . '_merge_after',
        [$this->_eventObject => $this, 'source' => $quote]
    );
 
 
 
▪	Event name: sales_quote_item_qty_set_after
▪	File: vendor/magento/module-quote/Model/Quote/Item.php
 
 
 
    $this->_eventManager->dispatch('sales_quote_item_qty_set_after', ['item' => $this]);
 
 
 
▪	Event name: sales_quote_item_set_product
▪	File: vendor/magento/module-quote/Model/Quote/Item.php
 

	 
 
    $this->_eventManager->dispatch(
        'sales_quote_item_set_product',
        ['product' => $product, 'quote_item' => $this]
    );
 
 
 
▪	Event name: _import_data_before
▪	File: vendor/magento/module-quote/Model/Quote/Payment.php
 

	 
 
    $this->_eventManager->dispatch(
        $this->_eventPrefix . '_import_data_before',
        [$this->_eventObject => $this, 'input' => $data]
    );
 
 
 
▪	Event name: _load_after
▪	File: vendor/magento/module-quote/Model/ResourceModel/Quote/Address/Collection.php
 
 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_load_after', [$this->_eventObject => $this]);
 
 
 
▪	Event name: prepare_catalog_product_collection_prices
▪	File: vendor/magento/module-quote/Model/ResourceModel/Quote/Item/Collection.php
 

	 
 
    $this->_eventManager->dispatch(
        'prepare_catalog_product_collection_prices',
        ['collection' => $productCollection, 'store_id' => $this->getStoreId()]
    );
 
 
 
▪	Event name: sales_quote_item_collection_products_after_load
▪	File: vendor/magento/module-quote/Model/ResourceModel/Quote/Item/Collection.php
 

	 
 
    $this->_eventManager->dispatch(
        'sales_quote_item_collection_products_after_load',
        ['collection' => $productCollection]
    );
 
 
 
▪	Event name: adminhtml_widget_grid_filter_collection
▪	File: vendor/magento/module-reports/Block/Adminhtml/Grid.php
 

	 
 
    $this->_eventManager->dispatch(
        'adminhtml_widget_grid_filter_collection',
        ['collection' => $this->getCollection(), 'filter_values' => $this->_filterValues]
    );
 
 
 
▪	Event name: sales_prepare_amount_expression
▪	File: vendor/magento/module-reports/Model/ResourceModel/Order/Collection.php
 

	 
 
    $this->_eventManager->dispatch(
        'sales_prepare_amount_expression',
        ['collection' => $this, 'expression_object' => $expressionTransferObject]
    );
 
 
 
▪	Event name: review_controller_product_init_before
▪	File: vendor/magento/module-review/Controller/Product.php
 
 
 
    $this->_eventManager->dispatch('review_controller_product_init_before', ['controller_action' => $this]);
 
 
 
▪	Event name: review_controller_product_init
▪	File: vendor/magento/module-review/Controller/Product.php
 
 
 
    $this->_eventManager->dispatch('review_controller_product_init', ['product' => $product]);
 
 
 
▪	Event name: review_controller_product_init_after
▪	File: vendor/magento/module-review/Controller/Product.php
 

	 
 
    $this->_eventManager->dispatch(
        'review_controller_product_init_after',
        ['product' => $product, 'controller_action' => $this]
    );
 
 
 
▪	Event name: rating_rating_collection_load_before
▪	File: vendor/magento/module-review/Model/ResourceModel/Rating/Collection.php
 
 
 
    $this->_eventManager->dispatch('rating_rating_collection_load_before', ['collection' => $this]);
 
 
 
▪	Event name: review_review_collection_load_before
▪	File: vendor/magento/module-review/Model/ResourceModel/Review/Collection.php
 
 
 
    $this->_eventManager->dispatch('review_review_collection_load_before', ['collection' => $this]);
 
 
 
▪	Event name: adminhtml_block_salesrule_actions_prepareform
▪	File: vendor/magento/module-sales-rule/Block/Adminhtml/Promo/Quote/Edit/Tab/Actions.php
 
 
 
    $this->_eventManager->dispatch('adminhtml_block_salesrule_actions_prepareform', ['form' => $form]);
 
 
 
▪	Event name: adminhtml_promo_quote_edit_tab_coupons_form_prepare_form
▪	File: vendor/magento/module-sales-rule/Block/Adminhtml/Promo/Quote/Edit/Tab/Coupons/Form.php
 

	 
 
    $this->_eventManager->dispatch(
        'adminhtml_promo_quote_edit_tab_coupons_form_prepare_form',
        ['form' => $form]
    );
 
 
 
▪	Event name: adminhtml_block_promo_widget_chooser_prepare_collection
▪	File: vendor/magento/module-sales-rule/Block/Adminhtml/Promo/Widget/Chooser.php
 

	 
 
    $this->_eventManager->dispatch(
        'adminhtml_block_promo_widget_chooser_prepare_collection',
        ['collection' => $collection]
    );
 
 
 
▪	Event name: adminhtml_controller_salesrule_prepare_save
▪	File: vendor/magento/module-sales-rule/Controller/Adminhtml/Promo/Quote/Save.php
 

	 
 
    $this->_eventManager->dispatch(
        'adminhtml_controller_salesrule_prepare_save',
        ['request' => $this->getRequest()]
    );
 
 
 
▪	Event name: salesrule_rule_get_coupon_types
▪	File: vendor/magento/module-sales-rule/Model/Rule.php
 
 
 
    $this->_eventManager->dispatch('salesrule_rule_get_coupon_types', ['transport' => $transport]);
 
 
 
▪	Event name: salesrule_validator_process
▪	File: vendor/magento/module-sales-rule/Model/RulesApplier.php
 




15
16	 
 
    $this->_eventManager->dispatch(
        'salesrule_validator_process',
        [
            'rule' => $rule,
            'item' => $item,
            'address' => $address,
            'quote' => $quote,
            'qty' => $qty,
            'result' => $discountData
        ]
    );
 
 
 
▪	Event name: salesrule_rule_condition_combine
▪	File: vendor/magento/module-sales-rule/Model/Rule/Condition/Combine.php
 
 
 
    $this->_eventManager->dispatch('salesrule_rule_condition_combine', ['additional' => $additional]);
 
 
 
▪	Event name: adminhtml_customer_orders_add_action_renderer
▪	File: vendor/magento/module-sales/Block/Adminhtml/Reorder/Renderer/Action.php
 

	 
 
    $this->_eventManager->dispatch(
        'adminhtml_customer_orders_add_action_renderer',
        ['renderer' => $this, 'row' => $row]
    );
 
 
 
▪	Event name: admin_sales_order_address_update
▪	File: vendor/magento/module-sales/Controller/Adminhtml/Order/AddressSave.php
 


 
 
    $this->_eventManager->dispatch(
        'admin_sales_order_address_update',
        [
            'order_id' => $address->getParentId()
        ]
    );
 
 
 
▪	Event name: adminhtml_sales_order_create_process_data_before
▪	File: vendor/magento/module-sales/Controller/Adminhtml/Order/Create.php
 
 
 
    $this->_eventManager->dispatch('adminhtml_sales_order_create_process_data_before', $eventData);
 
 
 
▪	Event name: adminhtml_sales_order_create_process_data
▪	File: vendor/magento/module-sales/Controller/Adminhtml/Order/Create.php
 
 
 
    $this->_eventManager->dispatch('adminhtml_sales_order_create_process_data', $eventData);
 
 
 
▪	Event name: sales_order_place_before
▪	File: vendor/magento/module-sales/Model/Order.php
 
 
 
    $this->_eventManager->dispatch('sales_order_place_before', ['order' => $this]);
 
 
 
▪	Event name: sales_order_place_after
▪	File: vendor/magento/module-sales/Model/Order.php
 
 
 
    $this->_eventManager->dispatch('sales_order_place_after', ['order' => $this]);
 
 
 
▪	Event name: order_cancel_after
▪	File: vendor/magento/module-sales/Model/Order.php
 
 
 
    $this->_eventManager->dispatch('order_cancel_after', ['order' => $this]);
 
 
 
▪	Event name: sales_convert_order_to_quote
▪	File: vendor/magento/module-sales/Model/AdminOrder/Create.php
 
 
 
    $this->_eventManager->dispatch('sales_convert_order_to_quote', ['order' => $order, 'quote' => $quote]);
 
 
 
▪	Event name: sales_convert_order_item_to_quote_item
▪	File: vendor/magento/module-sales/Model/AdminOrder/Create.php
 

	 
 
    $this->_eventManager->dispatch(
        'sales_convert_order_item_to_quote_item',
        ['order_item' => $orderItem, 'quote_item' => $item]
    );
 
 
 
▪	Event name: checkout_submit_all_after
▪	File: vendor/magento/module-sales/Model/AdminOrder/Create.php
 
 
 
    $this->_eventManager->dispatch('checkout_submit_all_after', ['order' => $order, 'quote' => $quote]);
 
 
 
▪	Event name: _sales_email_general_async_sending_
▪	File: vendor/magento/module-sales/Model/Config/Backend/Email/AsyncSending.php
 

	 
 
    $this->_eventManager->dispatch(
        $this->_eventPrefix . '_sales_email_general_async_sending_' . $state,
        $this->_getEventData()
    );
 
 
 
▪	Event name: _dev_grid_async_indexing_
▪	File: vendor/magento/module-sales/Model/Config/Backend/Grid/AsyncIndexing.php
 

	 
 
    $this->_eventManager->dispatch(
        $this->_eventPrefix . '_dev_grid_async_indexing_' . $state,
        $this->_getEventData()
    );
 
 
 
▪	Event name: sales_order_invoice_pay
▪	File: vendor/magento/module-sales/Model/Order/Invoice.php
 
 
 
    $this->_eventManager->dispatch('sales_order_invoice_pay', [$this->_eventObject => $this]);
 
 
 
▪	Event name: sales_order_invoice_cancel
▪	File: vendor/magento/module-sales/Model/Order/Invoice.php
 
 
 
    $this->_eventManager->dispatch('sales_order_invoice_cancel', [$this->_eventObject => $this]);
 
 
 
▪	Event name: sales_order_invoice_register
▪	File: vendor/magento/module-sales/Model/Order/Invoice.php
 

	 
 
    $this->_eventManager->dispatch(
        'sales_order_invoice_register',
        [$this->_eventObject => $this, 'order' => $order]
    );
 
 
 
▪	Event name: sales_order_item_cancel
▪	File: vendor/magento/module-sales/Model/Order/Item.php
 
 
 
    $this->_eventManager->dispatch('sales_order_item_cancel', ['item' => $this]);
 
 
 
▪	Event name: sales_order_payment_place_start
▪	File: vendor/magento/module-sales/Model/Order/Payment.php
 
 
 
    $this->_eventManager->dispatch('sales_order_payment_place_start', ['payment' => $this]);
 
 
 
▪	Event name: sales_order_payment_place_end
▪	File: vendor/magento/module-sales/Model/Order/Payment.php
 
 
 
    $this->_eventManager->dispatch('sales_order_payment_place_end', ['payment' => $this]);
 
 
 
▪	Event name: sales_order_payment_cancel_invoice
▪	File: vendor/magento/module-sales/Model/Order/Payment.php
 

	 
 
    $this->_eventManager->dispatch(
        'sales_order_payment_cancel_invoice',
        ['payment' => $this, 'invoice' => $invoice]
    );
 
 
 
▪	Event name: sales_order_payment_void
▪	File: vendor/magento/module-sales/Model/Order/Payment.php
 
 
 
    $this->_eventManager->dispatch('sales_order_payment_void', ['payment' => $this, 'invoice' => $document]);
 
 
 
▪	Event name: sales_order_payment_refund
▪	File: vendor/magento/module-sales/Model/Order/Payment.php
 

	 
 
    $this->_eventManager->dispatch(
        'sales_order_payment_refund',
        ['payment' => $this, 'creditmemo' => $creditmemo]
    );
 
 
 
▪	Event name: sales_order_payment_cancel_creditmemo
▪	File: vendor/magento/module-sales/Model/Order/Payment.php
 

	 
 
    $this->_eventManager->dispatch(
        'sales_order_payment_cancel_creditmemo',
        ['payment' => $this, 'creditmemo' => $creditmemo]
    );
 
 
 
▪	Event name: sales_order_payment_cancel
▪	File: vendor/magento/module-sales/Model/Order/Payment.php
 
 
 
    $this->_eventManager->dispatch('sales_order_payment_cancel', ['payment' => $this]);
 
 
 
▪	Event name: sales_order_status_unassign
▪	File: vendor/magento/module-sales/Model/Order/Status.php
 


 
 
    $this->_eventManager->dispatch(
        'sales_order_status_unassign',
        [
            'status' => $this->getStatus(),
            'state' => $state
        ]
    );
 
 
 
▪	Event name: _html_txn_id
▪	File: vendor/magento/module-sales/Model/Order/Payment/Transaction.php
 
 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_html_txn_id', $this->_getEventData());
 
 
 
▪	Event name: _load_after
▪	File: vendor/magento/module-sales/Model/ResourceModel/Order/Address/Collection.php
 
 
 
    $this->_eventManager->dispatch($this->_eventPrefix . '_load_after', [$this->_eventObject => $this]);
 
 
 
▪	Event name: _set_sales_order
▪	File: vendor/magento/module-sales/Model/ResourceModel/Order/Collection/AbstractCollection.php
 

	 
 
    $this->_eventManager->dispatch(
        $this->_eventPrefix . '_set_sales_order',
        ['collection' => $this, $this->_eventObject => $this, 'order' => $order]
    );
 
 
 
▪	Event name: sales_sale_collection_query_before
▪	File: vendor/magento/module-sales/Model/ResourceModel/Sale/Collection.php
 
 
 
    $this->_eventManager->dispatch('sales_sale_collection_query_before', ['collection' => $this]);
 
 
 
▪	Event name: on_view_report
▪	File: vendor/magento/module-search/Controller/Adminhtml/Term/Report.php
 
 
 
    $this->_eventManager->dispatch('on_view_report', ['report' => 'search']);
 
 
 
▪	Event name: sendfriend_product
▪	File: vendor/magento/module-send-friend/Controller/Product/Send.php
 
 
 
    $this->_eventManager->dispatch('sendfriend_product', ['product' => $product]);
 
 
 
▪	Event name: swatch_gallery_upload_image_after
▪	File: vendor/magento/module-swatches/Controller/Adminhtml/Iframe/Show.php
 

	 
 
    $this->_eventManager->dispatch(
        'swatch_gallery_upload_image_after',
        ['result' => $result, 'action' => $this]
    );
 
 
 
▪	Event name: adminhtml_cache_refresh_type
▪	File: vendor/magento/module-tax/Controller/Adminhtml/Tax/IgnoreTaxNotification.php
 
 
 
    $this->_eventManager->dispatch('adminhtml_cache_refresh_type', ['type' => 'block_html']);
 
 
 
▪	Event name: tax_rate_data_fetch
▪	File: vendor/magento/module-tax/Model/Calculation.php
 
 
 
    $this->_eventManager->dispatch('tax_rate_data_fetch', ['request' => $request, 'sender' => $this]);
 
 
 
▪	Event name: tax_settings_change_after
▪	File: vendor/magento/module-tax/Model/Calculation/Rate.php
 
 
 
    $this->_eventManager->dispatch('tax_settings_change_after');
 
 
 
▪	Event name: page_block_html_topmenu_gethtml_before
▪	File: vendor/magento/module-theme/Block/Html/Topmenu.php
 

	 
 
    $this->_eventManager->dispatch(
        'page_block_html_topmenu_gethtml_before',
        ['menu' => $this->_menu, 'block' => $this]
    );
 
 
 
▪	Event name: page_block_html_topmenu_gethtml_after
▪	File: vendor/magento/module-theme/Block/Html/Topmenu.php
 

	 
 
    $this->_eventManager->dispatch(
        'page_block_html_topmenu_gethtml_after',
        ['menu' => $this->_menu, 'transportObject' => $transportObject]
    );
 
 
 
▪	Event name: assign_theme_to_stores_after
▪	File: vendor/magento/module-theme/Model/Config.php
 

	 
 
        $this->_eventManager->dispatch(
            'assign_theme_to_stores_after',
            ['stores' => $stores, 'scope' => $scope, 'theme' => $theme]
        );
 
 
 
▪	Event name: permissions_role_html_before
▪	File: vendor/magento/module-user/Block/Role.php
 
 
 
    $this->_eventManager->dispatch('permissions_role_html_before', ['block' => $this]);
 
 
 
▪	Event name: admin_permissions_role_prepare_save
▪	File: vendor/magento/module-user/Controller/Adminhtml/User/Role/SaveRole.php
 

	 
 
    $this->_eventManager->dispatch(
        'admin_permissions_role_prepare_save',
        ['object' => $role, 'request' => $this->getRequest()]
    );
 
 
 
▪	Event name: admin_user_authenticate_before
▪	File: vendor/magento/module-user/Model/User.php
 

	 
 
    $this->_eventManager->dispatch(
        'admin_user_authenticate_before',
        ['username' => $username, 'user' => $this]
    );
 
 
 
▪	Event name: admin_user_authenticate_after
▪	File: vendor/magento/module-user/Model/User.php
 

	 
 
    $this->_eventManager->dispatch(
        'admin_user_authenticate_after',
        ['username' => $username, 'password' => $password, 'user' => $this, 'result' => $result]
    );
 
 
 
▪	Event name: admin_user_authenticate_after
▪	File: vendor/magento/module-user/Model/User.php
 



	 
 
    $this->_eventManager->dispatch(
        'admin_user_authenticate_after',
        [
            'username' => $this->getUserName(),
            'password' => $passwordString,
            'user' => $this,
            'result' => $isCheckSuccessful
        ]
    );
 
 
 
▪	Event name: product_option_renderer_init
▪	File: vendor/magento/module-wishlist/Block/Customer/Wishlist/Item/Options.php
 
 
 
    $this->_eventManager->dispatch('product_option_renderer_init', ['block' => $this]);
 
 
 
▪	Event name: wishlist_add_product
▪	File: vendor/magento/module-wishlist/Controller/Index/Add.php
 

	 
 
    $this->_eventManager->dispatch(
    'wishlist_add_product',
    ['wishlist' => $wishlist, 'product' => $product, 'item' => $result]
    );
 
 
 
▪	Event name: wishlist_share
▪	File: vendor/magento/module-wishlist/Controller/Index/Send.php
 
 
 
    $this->_eventManager->dispatch('wishlist_share', ['wishlist' => $wishlist]);
 
 
 
▪	Event name: wishlist_items_renewed
▪	File: vendor/magento/module-wishlist/Helper/Data.php
 
 
 
    $this->_eventManager->dispatch('wishlist_items_renewed');
 
 
 
▪	Event name: wishlist_product_add_after
▪	File: vendor/magento/module-wishlist/Model/Wishlist.php
 
 
 
    $this->_eventManager->dispatch('wishlist_product_add_after', ['items' => $items]);
 
 
 
▪	Event name: wishlist_item_collection_products_after_load
▪	File: vendor/magento/module-wishlist/Model/ResourceModel/Item/Collection.php
 

 
 
    $this->_eventManager->dispatch(
        'wishlist_item_collection_products_after_load',
        ['product_collection' => $productCollection]
    );
 

 
Magento 2 Hướng dẫn tạo Cron Job
bởi Admin 22/08/2020 0 Bình luận 85 xem
Cron jon là cài đặt một lịch trình cụ thể để tự động thực hiện một hành động nào đó. Điều này thực sự hữu ích khi bạn chạy cửa hàng Magento của bạn. Tại sao? Ví dụ bạn cần thống kê trang web của bạn hoặc gửi mail đến khách hàng vào lúc 12 giờ đêm để nhắc nhở họ ngủ sớm chẳng hạn. Tuy nhiên lúc đó bạn lại không rảnh để làm việc đó, nên bạn cần phải tạo cron job trên web server của mình.
Cron job là gì?
Cron Job mà một tính năng tuyệt vời của Linux, một hệ điều hành miễn phí cho người dùng. Cron Job sẽ tạo một lệnh thích hợp với nhiệm vụ mà bạn mong muốn. Thay vì làm một cách thủ công thì Cron Job sẽ tự động thực hiện nhiệm vụ vào thời gian chính xác. Do tính tự động hóa của nó, Cron Job là sự lựa chọn hoàn hoản cho các chức năng phải thực hiện lặp đi lặp lại hàng ngày hoặc hàng tuần.
Cấu hình Cron là một phần rất quan trọng trong Magento để kích hoạt nhiều hệ thống được hoạt động như reindexing, cập nhật giá trị tiền tệ, Magento email…Chỉ khi bạn cấu hình cron đúng thì nó mới được kích hoạt, ngược lại một số tính năng trong Magento sẽ không hoạt động như mong đợi.
Tại sao phải cần Cron Job?
Một số tính năng trong Magento yêu cầu phải có ít nhất một Cron Job. Lên lịch các hoạt động sẽ xảy ra trong tương lai. Ví dụ:
▪	Reindexing
▪	Cập nhật tỉ giá
▪	Magento email
▪	Newsletters
▪	Catalog price rules
▪	Tạo google sitemap
Tạo Cron Job
Tạo  crontab.xml trong module ViMagento_HelloWorld
ViMagento/HelloWorld/etc/crontab.xml
 
<?xml version="1.0" ?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Cron:etc/crontab.xsd">
    <group id="default">
        <job instance="ViMagento\HelloWorld\Cron\TestCron" method="execute" name="vimagento_helloworld_cron">
            <schedule>* * * * *</schedule>
        </job>
    </group>
</config>
 
▪	group id: tên group của bạn . Chỉ có thể chạy cron cho một group tại một thời điểm
▪	job instance: tên class sẽ thực hiện hành động mà bạn mong muốn
▪	job method: phương thức sẽ thực hiện hành động mà bạn mong muốn
▪	job nam: tên của cron
▪	schedule: lịch trình thời gian sẽ thực hiện hành động bạn mong muốn, 5 dấu sao từ trái sang phải tương ứng với:
▪	phút (0 – 59)
▪	giờ (0 – 23)
▪	ngày trong tháng (1 – 31)
▪	tháng (1 – 12)
▪	ngày trong tuần (0 – 7) với 0 là chủ nhật, 1 là thứ 2…
Tạo TestCron.php
ViMagento/HelloWorld/Cron/TestCron.php
 
<?php
 
namespace ViMagento\HelloWorld\Cron;
 
class TestCron
{
    public function execute()
    {
        $writer = new \Zend\Log\Writer\Stream(BP . '/var/log/cron.log');
        $logger = new \Zend\Log\Logger();
        $logger->addWriter($writer);
        $logger->info(__METHOD__);
 
        return $this;
    }
}
 
Cuối cùng các bạn xóa cache php bin/magento cache:clean và chạy câu lệnh php bin/magento cron:run –group=”default”. Cron Job sẽ được lên lịch và bạn có thể xem chi tiết trong bảng cron_schedule.
 
Và để test các bạn có thể mở file var/log/cron.log để xem
 
 
[Magento 2 cơ bản] Hướng dẫn thêm một Customer Attribute trong Magento 2
Bài viết sẽ hướng dẫn các bạn cách thêm một một customer attribute của riêng bạn. Hướng dẫn này dựa trên module ViMagento_HelloWorld đã được tạo ở những bài đầu.
Cách 1: Thêm một Customer Attribute với setup script
Làm ơn xem lại bài viết về setup script để hiểu thêm về cách chúng hoạt động.
ViMagento/HelloWorld/Setup/UpgradeData.php
 
<?php
 
namespace ViMagento\HelloWorld\Setup;
 
use Magento\Customer\Model\Customer;
use Magento\Framework\Setup\ModuleDataSetupInterface;
use Magento\Framework\Setup\UpgradeDataInterface;
use Magento\Framework\Setup\ModuleContextInterface;
use Magento\Customer\Setup\CustomerSetupFactory;
 
class UpgradeData implements UpgradeDataInterface
{
 
    private $customerSetupFactory;
 
    /**
     * Constructor
     *
     * @param \Magento\Customer\Setup\CustomerSetupFactory $customerSetupFactory
     */
    public function __construct(
        CustomerSetupFactory $customerSetupFactory
    ) {
        $this->customerSetupFactory = $customerSetupFactory;
    }
 
    /**
     * {@inheritdoc}
     */
    public function upgrade(
        ModuleDataSetupInterface $setup,
        ModuleContextInterface $context
    ) {
 
        $customerSetup = $this->customerSetupFactory->create(['setup' => $setup]);
 
        if (version_compare($context->getVersion(), '1.0.5') < 0) {
 
            $customerSetup->addAttribute(\Magento\Customer\Model\Customer::ENTITY, 'customer_attribute_use_script', [
                'type' => 'varchar',
                'label' => 'Use Setup Script',
                'input' => 'text',
                'source' => '',
                'required' => true,
                'visible' => true,
                'position' => 333,
                'system' => false,
                'backend' => ''
            ]);
 
            $attribute = $customerSetup->getEavConfig()->getAttribute('customer', 'customer_attribute_use_script')
                ->addData(['used_in_forms' => [
                    'adminhtml_customer',
                    'adminhtml_checkout',
                    'customer_account_create',
                    'customer_account_edit'
                ]
                ]);
            $attribute->save();
        }
    }
}
 
Sau đó các bạn nâng version của module lên và chạy câu lệnh:
php bin/magento setup:upgrade
Hướng dẫn thêm một Customer Attribute trong Magento 2
Cuối cùng bạn vào Customers > All Customers > Add New Customer
 Hướng dẫn thêm một Customer Attribute trong Magento 2
Cách 2: Thêm một Customer Attribute với Data Patch
Các bạn có thể xem lại bài Cách sử dụng Data Patch trong Magento 2 để hiểu về cấu trúc của nó.
ViMagento/HelloWorld/Setup/Patch/Data/AddCustomerAttribute.php
  
<?php
 
namespace ViMagento\HelloWorld\Setup\Patch\Data;
 
use Magento\Customer\Model\Customer;
use Magento\Eav\Model\Config;
use Magento\Customer\Setup\CustomerSetupFactory;
use Magento\Framework\Setup\ModuleDataSetupInterface;
use Magento\Framework\Setup\Patch\DataPatchInterface;
 
class AddCustomerAttribute implements DataPatchInterface
{
    /**
     * @var CustomerSetupFactory
     */
    private $customerSetupFactory;
 
    /**
     * @var ModuleDataSetupInterface
     */
    private $setup;
 
    /**
     * @var Config
     */
    private $eavConfig;
 
    /**
     * AccountPurposeCustomerAttribute constructor.
     * @param ModuleDataSetupInterface $setup
     * @param Config $eavConfig
     * @param CustomerSetupFactory $customerSetupFactory
     */
    public function __construct(
        ModuleDataSetupInterface $setup,
        Config $eavConfig,
        CustomerSetupFactory $customerSetupFactory
    )
    {
        $this->customerSetupFactory = $customerSetupFactory;
        $this->setup = $setup;
        $this->eavConfig = $eavConfig;
    }
 
    public function apply()
    {
        $customerSetup = $this->customerSetupFactory->create(['setup' => $this->setup]);
        $customerEntity = $customerSetup->getEavConfig()->getEntityType(Customer::ENTITY);
        $attributeSetId = $customerSetup->getDefaultAttributeSetId($customerEntity->getEntityTypeId());
        $attributeGroup = $customerSetup->getDefaultAttributeGroupId($customerEntity->getEntityTypeId(), $attributeSetId);
        $customerSetup->addAttribute(Customer::ENTITY, 'use_data_patch', [
            'type' => 'varchar',
            'input' => 'text',
            'label' => 'Use Data Patch',
            'required' => true,
            'default' => 0,
            'visible' => true,
            'user_defined' => true,
            'system' => false,
            'is_visible_in_grid' => true,
            'is_used_in_grid' => true,
            'is_filterable_in_grid' => true,
            'is_searchable_in_grid' => true,
            'position' => 300
        ]);
        $newAttribute = $this->eavConfig->getAttribute(Customer::ENTITY, 'use_data_patch');
        $newAttribute->addData([
            'used_in_forms' => ['adminhtml_checkout','adminhtml_customer','customer_account_edit','customer_account_create'],
            'attribute_set_id' => $attributeSetId,
            'attribute_group_id' => $attributeGroup
        ]);
        $newAttribute->save();
    }
 
    /**
     * {@inheritdoc}
     */
    public static function getDependencies()
    {
        return [];
    }
 
    /**
     * {@inheritdoc}
     */
    public function getAliases()
    {
        return [];
    }
 
    public static function getVersion()
    {
        return '1.0.1';
    }
}
 
	php bin/magento setup:upgrade
 Hướng dẫn thêm một Customer Attribute trong Magento 2
Các thuộc tính được sử dụng trong Customer tương tự như của Product và đã được giải thích chi tiết trong bài Hai cách để thêm Product Attribute trong Magento 2.
 
Magento 2 Đối tượng Factory
bởi Admin 24/08/2020 0 Bình luận 83 xem
Trong bài viết này, chúng ta sẽ nói về đối tượng Factory cho Model trong Magento 2. Như bạn đã biết trong lập trình hướng đối tượng, phương thức factory được sử dụng để khởi tạo một đối tượng. Trong Magento 2 đối tượng Factory cũng làm điều tương tự.
Tên của đối tượng Factory là tên class của Model nối thêm với từ Factory. Vì vậy với ví dụ bên dưới, chúng ta có class PostFactory. Bạn không cần phải tạo class này, Magento sẽ tạo nó cho bạn. Bất cứ khi nào Object manager của Magento gặp một tên class kết thúc bằng từ ‘Factory’, nó sẽ tự động tạo class Factory bên trong thư mục generated nếu class đó không tồn tại. Bạn có thể tìm class Factory trong:
generated/<vendor_name>/<module_name>/Model/ClassFactory.php
 
Để khởi tạo đối tượng Model, chúng ta sẽ sử dụng dependency injection trong constructor tác động đến đối tượng Factory. Sau đó sử dụng đối tượng Factory để khởi tạo Model.
Ví dụ, chúng ta sẽ gọi model để lấy dữ liệu trong Block. Chúng ta sẽ tạo một block:
ViMagento/HelloWorld/Block/Topic.php
 	 
<?php
namespace ViMagento\HelloWorld\Block;
class Topic extends \Magento\Framework\View\Element\Template
{
    protected $postFactory;
    public function _construct(
        \Magento\Framework\View\Element\Template\Context $context,
        \ViMagento\HelloWorld\Model\PostFactory $postFactory
    ){
        $this->postFactory = $postFactory;
        parent::_construct($context);
    }
 
    public function _prepareLayout()
    {
        $post = $this->postFactory->create();
        $collection = $post->getCollection();
        foreach($collection as $item){
            var_dump($item->getData());
        }
        exit;
    }
}
 
Như bạn có thể thấy, đối tượng postFactory được tạo trong constructor. Trong phương thức _prepareLayout tôi đã sử dụng $this->postFactory->create() để khởi tạo Model.
Bài viết được dịch từ: https://www.mageplaza.com/magento-2-module-development/factory-object-magento-2.html
 
Magento 2 Các loại join và giải thích chi tiết
bởi Admin 25/08/2020 0 Bình luận 106 xem
Trong bài này chúng ta sẽ tìm hiểu các truy vấn join mysql trong magento2,tôi thường thấy mọi người gặp khó khăn khi sử dụng join mysql và dẫn đến việc viết code “tệ” cho các hoạt động cơ sở dữ liệu.
Chúng ta sẽ xem cách viết các truy vấn join bằng phương thức magento2 ORM (Object Relational Mapping).
Bên dưới, tôi đã giải thích một số truy vấn, giả sử rằng tôi có một model được kết nối với một bảng có cấu trúc như bên dưới:
 

 
Column    Type    Comment
entity_id    int(11) Auto Increment     primary key
product_id    int(11)     product id
order_id    int(11)     order id
customer_id    int(11)     customer id
test_data       text
 
Bài viết được dịch tại: https://webkul.com/blog/magento2-mysql-join-explained/
Trong bảng trên ‘my_table_join_test’, giả sử chúng ta đang lưu product id, customer id và order id cho một vài mục đích, và muốn nhận thông tin về sản phẩm, đơn đặt hàng và khách hàng, những id đó thường có trong bảng của chúng tôi, những gì mọi người làm trước tiên họ viết một truy vấn để lấy dữ liệu từ bảng ‘my_table_join_test’, sau đó họ sẽ viết một truy vấn khác để lấy dữ liệu từ bảng product, order hoặc customer của magento2 để có được dữ liệu mong muốn, Cách trên hoàn toàn sai, chúng ta có thể viết một truy vấn “join” để lấy tất cả dữ liệu và tạo một collection thích hợp, và nó cũng sẽ giải quyết nhiều vấn đề mà bạn gặp phải trong việc tạo grid quản trị nơi bạn muốn hiển thị thông tinproduct, order hoặc customer, nếu bạn không sử dụng join, filter và sort sẽ không hoạt động.
Bên dưới là model của chúng tôi giả sử tên mô-đun là Stripe và tên vendor là Webkul, tạo model với đường dẫn sau : app/code/Webkul/Stripe/Model/JoinModel.php
 
<?php
 
/**
 * model class to work with join
 */
namespace Webkul\Stripe\Model;
 
use Magento\Framework\DataObject\IdentityInterface;
 
/**
 * JoinModel Model.
 */
class JoinModel extends \Magento\Framework\Model\AbstractModel
    implements \Webkul\Stripe\Api\Data\JoinModelInterface, IdentityInterface
{
    /**
     * No route page id.
     */
    const NOROUTE_ENTITY_ID = 'no-route';
 
    /**
     * Stripe JoinModel cache tag.
     */
    const CACHE_TAG = 'my_table_join_test';
 
    /**
     * @var string
     */
    protected $_cacheTag = 'my_table_join_test';
 
    /**
     * Prefix of model events names.
     *
     * @var string
     */
    protected $_eventPrefix = 'my_table_join_test';
 
    /**
     * Initialize resource model.
     */
    protected function _construct()
    {
        $this->_init('Webkul\Stripe\Model\ResourceModel\JoinModel');
    }
 
    /**
     * Load object data.
     *
     * @param int|null $id
     * @param string $field
     *
     * @return $this
     */
    public function load($id, $field = null)
    {
        if ($id === null) {
            return $this->noRouteReasons();
        }
 
        return parent::load($id, $field);
    }
 
    /**
     * Load No-Route JoinModel.
     *
     * @return \Webkul\Stripe\Model\JoinModel
     */
    public function noRouteReasons()
    {
        return $this->load(self::NOROUTE_ENTITY_ID, $this->getIdFieldName());
    }
 
    /**
     * Get identities.
     *
     * @return array
     */
    public function getIdentities()
    {
        return [self::CACHE_TAG . '_' . $this->getId()];
    }
 
    /**
     * Get ID.
     *
     * @return int
     */
    public function getId()
    {
        return parent::getData(self::ENTITY_ID);
    }
 
    /**
     * Set ID.
     *
     * @param int $id
     *
     * @return \Webkul\Stripe\Api\Data\JoinModelInterface
     */
    public function setId($id)
    {
        return $this->setData(self::ENTITY_ID, $id);
    }
}
 
 
Sau đó hãy tạo resource model tại: app/code/Webkul/Stripe/Model/ResourceModel/JoinModel/JoinModel.php
 	 
<?php
/**
 * Resource Model
 */
namespace Webkul\Stripe\Model\ResourceModel;
 
/**
 * Stripe JoinModel ResourceModel.
 */
class JoinModel extends \Magento\Framework\Model\ResourceModel\Db\AbstractDb
{
    /**
     * Store model
     *
     * @var null|\Magento\Store\Model\Store
     */
    protected $_store = null;
 
    /**
     * Construct
     *
     * @param \Magento\Framework\Model\ResourceModel\Db\Context $context
     * @param string $connectionName
     */
    public function __construct(
        \Magento\Framework\Model\ResourceModel\Db\Context $context,
        $connectionName = null
    )
    {
        parent::__construct($context, $connectionName);
    }
 
    /**
     * Initialize resource model
     *
     * @return void
     */
    protected function _construct()
    {
        $this->_init('my_table_join_test', 'entity_id');
    }
 
    /**
     * Load an object using 'identifier' field if there's no field specified and value is not numeric
     *
     * @param \Magento\Framework\Model\AbstractModel $object
     * @param mixed $value
     * @param string $field
     * @return $this
     */
    public function load(\Magento\Framework\Model\AbstractModel $object, $value, $field = null)
    {
        if (!is_numeric($value) && is_null($field)) {
            $field = 'identifier';
        }
 
        return parent::load($object, $value, $field);
    }
 
    /**
     * Set store model
     *
     * @param \Magento\Store\Model\Store $store
     * @return $this
     */
    public function setStore($store)
    {
        $this->_store = $store;
        return $this;
    }
 
    /**
     * Retrieve store model
     *
     * @return \Magento\Store\Model\Store
     */
    public function getStore()
    {
        return $this->_storeManager->getStore($this->_store);
    }
}
 
Sau đó tạo collection với: app/code/Webkul/Stripe/Model/ResourceModel/JoinModel/Collection.php
  
<?php
/**
 * join model collection
 */
 
namespace Webkul\Stripe\Model\ResourceModel\JoinModel;
 
use Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection;
 
/**
 * Webkul Stripe ResourceModel JoinModel collection
 */
class Collection extends AbstractCollection
{
    /**
     * @var string
     */
    protected $_idFieldName = 'entity_id';
 
    /**
     * Store manager
     *
     * @var \Magento\Store\Model\StoreManagerInterface
     */
    protected $_storeManager;
 
    /**
     * @param \Magento\Framework\Data\Collection\EntityFactoryInterface $entityFactory
     * @param \Psr\Log\LoggerInterface $logger
     * @param \Magento\Framework\Data\Collection\Db\FetchStrategyInterface $fetchStrategy
     * @param \Magento\Framework\Event\ManagerInterface $eventManager
     * @param \Magento\Store\Model\StoreManagerInterface $storeManager
     * @param \Magento\Framework\DB\Adapter\AdapterInterface|null $connection
     * @param \Magento\Framework\Model\ResourceModel\Db\AbstractDb|null $resource
     */
    public function __construct(
        \Magento\Framework\Data\Collection\EntityFactoryInterface $entityFactory,
        \Psr\Log\LoggerInterface $logger,
        \Magento\Framework\Data\Collection\Db\FetchStrategyInterface $fetchStrategy,
        \Magento\Framework\Event\ManagerInterface $eventManager,
        \Magento\Store\Model\StoreManagerInterface $storeManager,
        \Magento\Framework\DB\Adapter\AdapterInterface $connection = null,
        \Magento\Framework\Model\ResourceModel\Db\AbstractDb $resource = null
    )
    {
        parent::__construct($entityFactory, $logger, $fetchStrategy, $eventManager, $connection, $resource);
        $this->_storeManager = $storeManager;
    }
 
    /**
     * Define resource model
     *
     * @return void
     */
    protected function _construct()
    {
        $this->_init('Webkul\Stripe\Model\JoinModel', 'Webkul\Stripe\Model\ResourceModel\JoinModel');
        $this->_map['fields']['entity_id'] = 'main_table.entity_id';
    }
    /**
     * Add filter by store
     *
     * @param int|array|\Magento\Store\Model\Store $store
     * @param bool $withAdmin
     * @return $this
     */
    public function addStoreFilter($store, $withAdmin = true)
    {
        if (!$this->getFlag('store_filter_added')) {
            $this->performAddStoreFilter($store, $withAdmin);
        }
        return $this;
    }
}
 
Tạo Api interfate tại: app/code/Webkul/Stripe/Api/Data/JoinModelInterface.php
 	 
<?php
/**
 * Join table data interface
 */
 
namespace Webkul\Stripe\Api\Data;
 
/**
 * Stripe JoinModel interface.
 *
 * @api
 */
interface JoinModelInterface
{
    /**#@+
     * Constants for keys of data array. Identical to the name of the getter in snake case
     */
    const ENTITY_ID = 'entity_id';
    /**#@-*/
 
    /**
     * Get ID.
     *
     * @return int|null
     */
    public function getId();
 
    /**
     * Set ID.
     *
     * @param int $id
     *
     * @return \Webkul\Stripe\Api\Data\ReasonsInterface
     */
    public function setId($id);
}
 
Ở trên chúng ta đã tạo model, bây giờ chúng ta sẽ thực hiện một vài câu truy vấn join dựa trên các bảng ở trên và bảng mặc định của Magento 2.
Inner Join đơn giản
 
	 
<?php
/**
 * $orderTable name of order table
 */
$orderTable = $this->_resource->getTableName('sales_order');
 
/**
 * $customerTable name of customer table
 */
$customerTable = $this->_resource->getTableName('customer_entity');
 
/**
 * $joinCollection
 * @var Webkul\Stripe\Model\ResourceModel\JoinModel\CollectionFactory
 */
$joinCollection = $this->_joinFactory->create();
$joinCollection
    ->join(
        ['ot' => $orderTable],
        "main_table.order_id = ot.entity_id"
    );
 
echo $joinCollection->getSelect();
die;
 
Ở đoạn code trên, chúng tôi đã gọi hàm join mysql trong Magento 2 trên đối tượng collection và truyền vào 2 tham số. Tham số đầu tiên là 1 mảng với tên bí danh cho bảng, tham số thứ 2 là điều kiện để join các bảng với nhau. Cuối cùng, tôi đã in truy vấn sql ra, đầu ra cho đoạn code trên là:
 
	 
SELECT `main_table`.*, `ot`.* FROM `wk_my_table_join_test` AS `main_table` INNER JOIN `wk_sales_order` AS `ot` ON main_table.order_id = ot.entity_id
 
Bạn có thể chạy truy vấn này trong mysql và kiểm tra kết quả.
Left Join
 	 
<?php
/**
 * $orderTable name of order table
 */
$orderTable = $this->_resource->getTableName('sales_order');
 
/**
 * $customerTable name of customer table
 */
$customerTable = $this->_resource->getTableName('customer_entity');
 
/**
 * $joinCollection
 * @var Webkul\Stripe\Model\ResourceModel\JoinModel\CollectionFactory
 */
$joinCollection = $this->_joinFactory->create();
$joinCollection
    ->getSelect()
    ->joinLeft(
        ['ot' => $orderTable],
        "main_table.order_id = ot.entity_id"
    );
 
echo $joinCollection->getSelect();
die;
 
Đoạn code trên sử dụng phương thức joinLeft, joinLeft sẽ trả về tất cả các dòng dữ liệu của bảng bên trái và các dòng dữ liệu phù hợp của bảng bên phải.
Bây giờ chúng ta đã thấy cách tạo các truy vấn join đơn giản, các truy vấn trên sẽ tìm nạp tất cả các cột từ cả hai bảng. Bây giờ Chúng ta sẽ xem cách lấy các cột mà chúng ta muốn chọn.
 
 
<?php
/**
* $orderTable name of order table
*/
$orderTable = $this->_resource->getTableName('sales_order');
 
/**
* $customerTable name of customer table
*/
$customerTable = $this->_resource->getTableName('customer_entity');
 
/**
* $joinCollection
* @var Webkul\Stripe\Model\ResourceModel\JoinModel\CollectionFactory
*/
$joinCollection = $this->_joinFactory->create();
$joinCollection
->getSelect()
->join(
['ot'=>$orderTable],
"main_table.order_id = ot.entity_id",
[
'increment_id' => 'ot.increment_id'
]
);
 
echo $joinCollection->getSelect();die;   
 
Đoạn mã trên sẽ xuất câu truy vấn này:
 
	 
SELECT `main_table`.*, `ot`.`increment_id` FROM `wk_my_table_join_test` AS `main_table` INNER JOIN `wk_sales_order` AS `ot` ON main_table.order_id = ot.entity_id
 
Khi bạn chạy câu truy vấn trên, nó sẽ trả về tất cả các cột từ bảng main table và chỉ trả về cột increment_id từ bảng order bởi vì chúng ta chỉ chọn một cột trong tham số thứ ba của hàm join, bạn có thể chọn bao nhiêu cột tùy thích.
Bây giờ chúng ta sẽ xem cách tạo điều kiện hoặc mệnh đề where trên kết quả join:
Sử dụng mệnh đề Where
 
	 
<?php
/**
 * $orderTable name of order table
 */
$orderTable = $this->_resource->getTableName('sales_order');
 
/**
 * $customerTable name of customer table
 */
$customerTable = $this->_resource->getTableName('customer_entity');
 
/**
 * $joinCollection
 * @var Webkul\Stripe\Model\ResourceModel\JoinModel\CollectionFactory
 */
$joinCollection = $this->_joinFactory->create();
$joinCollection
    ->getSelect()
    ->join(
        ['ot'=>$orderTable],
        "main_table.order_id = ot.entity_id",
        [
            'increment_id' => 'ot.increment_id',
            'status' => 'ot.state'
        ]
    )
    ->where("status = 'pending'");
 
echo $joinCollection->getSelect();die;
 
Đoạn mã trên sẽ xuất câu truy vấn này:
 
	 
SELECT `main_table`.*, `ot`.`increment_id`, `ot`.`state` AS `status` FROM `wk_my_table_join_test` AS `main_table` INNER JOIN `wk_sales_order` AS `ot` ON main_table.order_id = ot.entity_id WHERE (status = 'pending')
 
Trong đoạn code trên để thêm mệnh đề where, chúng tôi gọi phương thức where trên collection đã join và truyền một tham số dạng chuỗi như là điều kiện.
Bây giờ chúng ta sẽ xem cách sử dụng hàm tổng hợp như GROUP_CONCAT, COUNT, v.v.:
	 
<?php
/**
 * $orderTable name of order table
 */
$orderTable = $this->_resource->getTableName('sales_order');
 
/**
 * $customerTable name of customer table
 */
$customerTable = $this->_resource->getTableName('customer_entity');
 
/**
 * $joinCollection
 * @var Webkul\Stripe\Model\ResourceModel\JoinModel\CollectionFactory
 */
$joinCollection = $this->_joinFactory->create();
$joinCollection
    ->getSelect()
    ->join(
        ['ot'=>$orderTable],
        "main_table.order_id = ot.entity_id",
        [
            'increment_id' => 'ot.increment_id',
            'status' => 'GROUP_CONCAT(ot.state)'
        ]
    )
    ->where("status = 'pending'")
    ->group("main_table.order_id");
 
echo $joinCollection->getSelect();die;
 
Trong đoạn code trên, tôi đã sử dụng hàm group và truyền vào một tham số dạng chuỗi, bạn có thể truyền vào nhiều cột và phân cách bằng dấu phẩy. Tôi đã sử dụng hàm tổng hợp GROUP_CONCAT trên cột ‘status’ và nhóm kết quả trên cột ‘order_id’. Đoạn mã trên sẽ xuất câu truy vấn này:
 
	 
SELECT `main_table`.*, `ot`.`increment_id`, GROUP_CONCAT(ot.state) AS `status` FROM `wk_my_table_join_test` AS `main_table` INNER JOIN `wk_sales_order` AS `ot` ON main_table.order_id = ot.entity_id WHERE (status = 'pending') GROUP BY `main_table`.`order_id`
 
Câu truy vấn trên sẽ dẫn đến việc kết hợp tất cả các order_id giống nhau trong một hàng và sẽ nối tất cả các trạng thái đơn hàng trong một cột dưới dạng dấu phẩy được phân tách. Nếu bạn muốn kết hợp các giá trị riêng biệt, hãy sử dụng mã bên dưới:
 
 
<?php
/**
 * $orderTable name of order table
 */
$orderTable = $this->_resource->getTableName('sales_order');
 
/**
 * $customerTable name of customer table
 */
$customerTable = $this->_resource->getTableName('customer_entity');
 
/**
 * $joinCollection
 * @var Webkul\Stripe\Model\ResourceModel\JoinModel\CollectionFactory
 */
$joinCollection = $this->_joinFactory->create();
$joinCollection
    ->getSelect()
    ->join(
        ['ot'=>$orderTable],
        "main_table.order_id = ot.entity_id",
        [
            'increment_id' => 'ot.increment_id',
            'status' => 'GROUP_CONCAT(DISTINCT ot.state)'
        ]
    )
    ->where("status = 'pending'")
    ->group("main_table.order_id");
 
echo $joinCollection->getSelect();die;
 
Bây giờ chúng ta sẽ lấy một ví dụ cuối cùng để join nhiều bảng:
	 
/**
* $orderTable name of order table
*/
$orderTable = $this->_resource->getTableName('sales_order');
 
/**
* $customerTable name of customer table
*/
$customerTable = $this->_resource->getTableName('customer_entity');
 
/**
* $joinCollection
* @var Webkul\Stripe\Model\ResourceModel\JoinModel\CollectionFactory
*/
$joinCollection = $this->_joinFactory->create();
$joinCollection
->getSelect()
->join(
['ot'=>$orderTable],
"main_table.order_id = ot.entity_id",
[
'increment_id' => 'ot.increment_id',
'status' => 'GROUP_CONCAT(DISTINCT ot.state)'
]
)
->join(
['ct' => $customerTable],
"main_table.customer_id = ct.entity_id",
[
"customer_name" => "ct.firstname"
]
)
->group("main_table.order_id");
 
echo $joinCollection->getSelect();die;
 
Trong đoạn code trên, tôi đã tạo một phép join khác với bảng customer để lấy tên khách hàng, đoạn mã trên sẽ xuất ra câu truy vấn này:
 
	 
SELECT `main_table`.*, `ot`.`increment_id`, GROUP_CONCAT(DISTINCT ot.state) AS `status`, `ct`.`firstname` AS `customer_name` FROM `wk_my_table_join_test` AS `main_table` INNER JOIN `wk_sales_order` AS `ot` ON main_table.order_id = ot.entity_id INNER JOIN `wk_customer_entity` AS `ct` ON main_table.customer_id = ct.entity_id GROUP BY `main_table`.`order_id`
 
Kết luận
Hy vọng điều này sẽ giúp bạn hiểu cách viết code cho các truy vấn join trong Magento2. Hãy thử code ở trên và trong trường hợp bạn không thể hiểu bất kỳ điều gì ở trên, vui lòng bình luận bên dưới. Cảm ơn  
Bài viết được dịch tại: https://webkul.com/blog/magento2-mysql-join-explained/
 
Magento 2 Dependency Injection là gì? Tại sao phải sử dụng Dependency Injection?
bởi Admin 27/08/2020 1 Bình luận 9 xem
Magento 2 không còn mới đối với các developer Việt Nam nữa. Hầu hết các developer yêu thích Magento 2 bởi vì công nghệ phong phú của nó. Dependency Injection (DI) là một trong những design patterns mà Magento 2 sử dụng nhưng nhiều người vẫn chưa hiểu chính xác DI là gì? Vì vậy tôi sẽ cố gắng giải thích DI một các dễ hiểu nhất có thể trong bài viết này.
 Cách Dependency Injection hoạt động
Giới thiệu
Như cái tên của nó đã nói, Các bạn hãy hiểu riêng biệt từng từ của DI:
Dependency
Dependency có nghĩa đơn giản là một cái gì đó phụ thuộc vào một cái gì đó, giống như bạn đang phụ thuộc vào ba mẹ của bạn vậy. Trong lập trình bạn cũng có thể hiểu tương tự như vậy, một class sẽ phụ thuộc vào các Object được khởi tạo bên trong class đó. Ví dụ:
 


 
<?php 
 
class Product {
 
  public function getTax($id) {
     $tax = new Taxation();
     return $tax->getCalculateTax($id);
  }   
 
}
 
Ở đoạn code trên bạn có thể thấy class Product có một phương thức getTax và bên trong khởi tạo một đối tượng Taxation với từ khóa new. Đây là một cách khởi tạo trong lập trình hướng đối tượng. Bạn nghĩ sao nếu không tìm thấy class Taxation? Tất nhiên là class Product sẽ không hoạt động được. Vậy ở đây ta sẽ nói class Product phụ thuộc vào đối tượng Taxation bởi vì nó không thể hoạt động đúng nếu không tìm thấy đối tượng Taxation. Trong Magento 2 sự phụ thuộc có thể là một class sử dụng Model hoặc một class của một Module khác chẳng hạn.
Injection
Injection đơn giản có nghĩa là cung cấp một cái gì đó bởi bên thứ ba.
Và ở ví dụ trên, new Taxation() là đối tượng cần cung cấp bởi bên thứ 3.
Vì vậy Dependency Injection là loại bỏ việc phụ thuộc trực tiếp của class với đối tượng, thay vào đó sẽ sử dụng một bên thứ 3 để tạo các đối tượng cho class đó là Object Manager trong Magento 2.
Tại sao lại phải sử dụng Dependency Injection?
Bạn vẫn chưa hiểu tại sao phải sử dụng Dependency Injection? Giả sử bạn cần xây dựng một ngôi nhà, Bạn sẽ làm gì? Điều bạn cần cơ bản khi bắt đầu là gạch và xi măng…Vậy bạn sẽ bắt đầu đi tìm đất sét để làm gạch và sau đó xây nhà? Hay bạn sẽ mua gạch tại một nhà cung cấp và chỉ việc xây nhà thôi.
Điều đó hoàn toàn đúng, bạn chỉ cần liên hệ với nhà cung cấp gạch và mọi thứ sẽ sẵn sàng để bạn xây dựng căn nhà của mình. Đó cũng là những gì Dependency Injection sẽ làm. Nó sẽ tách class của bạn khỏi việc xây dựng phụ thuộc của nó.
 	 
class Customer
{
    private $firstName;
    private $lastName;
 
    public function __construct($firstName, $lastName)
    {
        $this->firstName = $firstName;
        $this->lastName = $lastName;
    }
 
    public function getFirstName()
    {
        return $this->firstName;
    }
 
    public function getLastName()
    {
        return $this->lastName;
    }
}
 
class CustomerInfo
{
    private $customer;
 
    public function __construct($customerFirstName, $customerLastName)
    {
        $this->customer = new Customer($customerFirstName, $customerLastName);
    }
 
    public function getCustomer()
    {
        return $this->customer;
    }
 }
 
Chẳng có gì sai đối với đoạn code trên. Nó sẽ trả về firstname và lastname mà chẳng gặp vấn đề gì cả. Nhưng vấn đề ở đây là class Customer được liên kết chặt chẽ với class CustomerInfo. Nếu class Customer có cập nhật chẳng hạn như thêm một tham số email chẳng hạn. Và sau đó những nơi có khởi tạo đối tượng Customer bạn phải sửa đổi và truyền thêm vào một đối số là email. Mọi chuyện vẫn ổn nếu chỉ có một chỗ khởi tạo đối tượng Customer nhưng không may bạn tham gia một dự án lớn và có hàng trăm chỗ có khởi tạo đối tượng Customer. Chỉ nghe thôi cũng đã cảm thấy tồi tệ rồi ý nhỉ.
Đến đây thì các bạn cũng có thể hiểu được lợi ích và tại sao phải sử dụng Dependency Injection rồi phải không nào. Dependency Injection sẽ giải quyết được vấn đề trên bằng cách truyền các phụ thuộc vào phương thức Constructor của class.
Cách sử dụng Dependency Injection
Và đây là cách mà Dependency Injection làm việc:
 
	 
<?php
 
class Product {
 
    protected $_taxation;
 
    public function __construct(
        \Taxation $taxation
    ) {
        $this->_taxation = $taxation;
    }
 
    public function getTax($id) {
        return $this->_taxation->getCalculateTax($id);
    }
}
 
Trong đoạn code trên bạn có thể thấy, chúng ta không sử dụng từ khóa new để khởi tạo class Taxation. Nhưng có thể bạn sẽ nghĩ trong trường hợp class Taxation không có tham số truyền vào thì vẫn ổn nhưng nếu class có tham số truyền vào thì sao nhỉ. Chúng ta sẽ truyền tham số cho class Taxation bằng cách nào. Đây cũng là một điều mà Magento 2 Dependency Injection đã làm rất tốt.
Để giải quyết tình huống trên đó là truyền tham số cho một phụ thuộc, tất cả những gì bạn cần làm là tạo một file di.xml trong module của bạn.
 
	 
<type name="/Taxation">
        <arguments>
            <argument name="firstname" xsi:type="string">Nguyễn Văn Tèo</argument>
        </arguments>
</type>
 
Điều này có nghĩa là khi Object Manager tạo đối tượng Taxation nó sẽ kiểm tra khai báo trong file di.xml và thêm giá trị Nguyễn Văn Tèo vào biến firstname với kiểu giá trị là string. Bạn có thể thêm bất kỳ kiểu giá trị nào vào xsi:type như string, object, int…Đây cũng là lý do mà tôi khuyên bạn nên sử dụng Dependency Injection thay vì sử dụng phương thức create() của Object Manager để khởi tạo đối tượng. Vì sử dụng phương thức create() của Object Manager bạn sẽ không truyền tham số được cho những phụ thuộc của class.
Kết luận
Bằng cách hiểu những gì đã được viết ở trên bạn có thể nắm được cơ bản về Dependency Injection trong Magento 2. Hy vọng bài viết có thể giúp được phần nào cho các bạn. Nếu các bạn có thắc mắc gì liên quan đến Dependency Injection trong Magento 2 các bạn có thể để lại bình luận bên dưới để được giải đáp.
 



Magento 2 Cách sử dụng Knockout Js trong custom templates
bởi Admin 02/09/2020 0 Bình luận 117 xem
Knockout(KO) là một thư viện của Javascript, nó giúp bạn tạo, hiển thị hay hiệu chỉnh User Interface(UI) với một data model được định nghĩa sẵn. Bất cứ khi nào bạn có phần thay đổi(thay đổi về action của user hay dữ liệu nội tại thay đổi) trong UI thì KO có thể giúp bạn thực hiện nó một cách đơn giản, và dễ kiểm soát. Trong bài viết này tôi sẽ hướng dẫn các bạn cách sử dụng Knockout Js trong file templates trong Magento 2.
Tạo custom templates
Đầu tiên các bạn tạo một file templates dùng để kết nối đến Knockout Js. Ví dụ ở đây tôi đã tạo module, layout, controller rồi nhé. Nếu các bạn chưa biết thì có thể đọc lại các bài trước đó.
Trong file layout tôi tạo một block và kết nối đến file templates.
ViMagento/OrderGrid/view/frontend/layout/grid_post_index.xml
 
 
<?xml version="1.0"?>
<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
    <body>
        <referenceContainer name="content">
            <block name="vimagento_helloworld_knockout_test" template="ViMagento_OrderGrid::knockout.phtml" cacheable="false"/>
        </referenceContainer>
    </body>
</page>
 
ViMagento/OrderGrid/view/frontend/templates/knockout.phtml
 
 
<div id="custom-component" data-bind="scope:'customcomponent'">
    <!-- ko template: getTemplate() --><!-- /ko -->
    <script type="text/x-magento-init">
    {
        "#custom-component": {
            "Magento_Ui/js/core/app": {
               "components": {
                    "customcomponent": {
                        "component": "ViMagento_OrderGrid/js/custom-component"
                    }
                }
            }
        }
    }
    </script>
</div>
 
Trong file templates trên tôi đã kết nối đến file knockout js có tên custom-component.
Tạo knockout Js
ViMagento/OrderGrid/view/frontend/web/js/custom-component.js
 
 
define(['jquery', 'uiComponent', 'ko'], function ($, Component, ko) {
        'use strict';
        return Component.extend({
            defaults: {
                template: 'ViMagento_OrderGrid/knockout-test'
            },
            initialize: function () {
                this.customerName = ko.observableArray([]);
                this.customerData = ko.observable('');
                this._super();
            },
 
            addNewCustomer: function () {
                this.customerName.push({name:this.customerData()});
                this.customerData('');
            }
        });
    }
);
 
Ở file js trên tôi đã kết nối đến 1 file html có tên là knockout-test dùng để render mã HTML và dữ liệu từ knockout js.
Tạo file HTML
ViMagento/OrderGrid/view/frontend/web/template/knockout-test.html
 
 
<div class="component-wrapper">
    <div class="field">
        <label class="label" for="email"><span data-bind="i18n: 'Tạo người dùng mới'"></span></label>
        <div class="control">
            <input name="customername"
                   id="customername"
                   type="text"
                   class="input-text"
                   data-bind="value: customerData">
        </div>
    </div>
    <div class="primary">
        <button type="button" class="action action-login secondary" data-bind="click: addNewCustomer">
            <span data-bind="i18n: 'Lưu'"></span>
        </button>
    </div>
 
    <div class="customer-list" style="width: 20%;background: #eee;margin-top: 10px;" data-bind="foreach: customerName">
        <li data-bind="text: name"></li>
    </div>
</div>
 
Ở trên là một ví dụ cơ bản về cách viết của knockout js. Nếu thực hiện đúng thì sẽ có kết quả như sau:
 Cách sử dụng knockout js trong Magento 2
Kết luận
Vừa rồi tôi đã hướng dẫn các bạn sử dụng Knockout Js trong Magento 2. Đây chỉ là cú pháp cơ bản của Knockout Js, tôi sẽ cố gắng viết nhiều bài viết về Knockout Js hơn nữa trong thời gian tới. Thanks.
 
Magento 2 Tìm hiểu về 6 loại product
bởi Admin 02/09/2020 0 Bình luận 53 xem
Magento nổi tiếng trong lĩnh vực thương mại nhờ tính linh hoạt và khả năng tùy biến của nó. Magento cung cấp 6 loại product với các đặc tính khác nhau. Trong bài viết này chúng ta sẽ cùng nhau tìm hiểu về 6 loại product trong Magento 2:
 Tìm hiểu về 6 loại product trong Magento 2
1. Simple product
Simple product là sản phẩm phổ biến và cơ bản nhất trong Magento. Như cái tên của nó, sản phẩm này được bán trên từng mặt hàng không có nhiều mặt hàng để lựa chọn. Ví dụ như bên dưới là một cái quần vải nam và không có sự lựa chọn nào khác như màu sắc hoặc kích thước và mỗi sản phẩm sẽ có một SKU riêng để phân biệt.
 Ví dụ về Simple product trong Magento 2
Virtual product
Virtual product là sản phẩm như dịch vụ, thành viên, bảo hành, thuê bao. Các bạn có thể gọi chúng là sản phẩm ảo, chúng không cần phải bắt buộc vận chuyển hay giao hàng. Và tất nhiên cũng như các loại sản phẩm khác Virtual product cũng có SKU riêng cho từng sản phẩm.
 Ví dụ về Virtual product trong Magento 2
Configurable Product
Configurable Product là sản phẩm bao gồm nhiều sản phẩm Simple product hoặc Virtual product tạo thành. Cung cấp nhiều lựa chọn cho người dùng. Ví dụ cùng một cái quần dài nhưng sẽ có nhiều size và color khác nhau. Và mỗi color và size tương ứng với một sản phẩm simple product hoặc virtual product với mã SKU khác nhau.
 Ví dụ về configurable product trong Magento 2
Grouped Product
Grouped Product gồm một nhóm các sản phẩm simple product hoặc virtual product có cùng đặc điểm hoặc có liên quan với nhau. Chúng có thể tiết kiệm hơn so với việc mua riêng lẻ giúp tăng doanh số bán hàng.Và người dùng có thể chọn mua một trong số các sản phẩm trong nhóm. Ví dụ như 1 bộ sản phẩm gồm điện thoại, sạc dự phòng, miếng dán màn hình chẳng hạn.
 Ví dụ về Grouped Product trong Magento 2
Bundle Product
Bundle Product cũng tương tự như Grouped Product là gồm một nhóm các sản phẩm simple product hoặc virtual product. Nhưng khác nhau ở chỗ là người dùng chọn mua một combo các sản phẩm con chứ không thể mua một sản phẩm riêng lẻ.
 Ví dụ về Bundle Product trong Magento 2
Downloadable Product
Downloadable Product là bất cứ thứ gì bạn có thể tải xuống ví dụ như ebook, video, phần mềm, khóa học online…Sau khi khách hàng xem trailer, họ sẽ mua hàng sau đó download sản phẩm về và sử dụng.
 Ví dụ về Downloadable Product trong Magento 2
Kết luận
Qua bài viết tôi đã hướng dẫn các bạn về 6 loại product trong Magento 2. Và Magento cũng hỗ trợ các bạn thêm loại product khác, mình sẽ hướng dẫn trong các bài sau. Thanks.
 
Hướng dẫn thêm product type trong Magento 2
bởi Admin 02/09/2020 0 Bình luận 45 xem
Ở bài viết trước chúng ta đã tìm hiểu về 6 loại product. Bài viết này sẽ hướng dẫn các bạn thêm một loại product tùy chỉnh trong Magento 2. Magento hỗ trợ một số loại sản phẩm, mỗi loại có hành vi và thuộc tính riêng. Khái niệm mạnh mẽ này cho phép Magento hỗ trợ nhiều ngành và nhu cầu của người bán hàng bằng cách trộn và kết hợp các trải nghiệm sản phẩm trong danh mục của họ.
Tuy nhiên, điều tuyệt vời ở đây là khả năng cho phép các nhà phát triển dễ dàng thêm các loại sản phẩm mới.
Nói chung, khi một loại sản phẩm có hành vi hoặc thuộc tính riêng biệt, thì nó phải được thể hiện bằng loại sản phẩm của chính nó. Điều này cho phép loại sản phẩm có cách trình bày và tùy chỉnh, không ảnh hưởng đến các loại sản phẩm khác – đảm bảo rằng các loại sản phẩm gốc có thể tiếp tục hoạt động như dự định.
Tạo file product_types.xml
Để thêm một product type thì điều đầu tiên các bạn cần làm là khai báo file product_types.xml trong module của bạn:
ViMagento/HelloWorld/etc/product_types.xml
 
 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Catalog:etc/product_types.xsd">
    <type name="custom_product_type_code" label="Custom Product Type" modelInstance="ViMagento\HelloWorld\Model\Product\Type"></type>
</config>
 
Thẻ type có ba thuộc tính bắt buộc.
▪	name: Thuộc tính này định nghĩa tên của product type được sử dụng để lưu vào trong cơ sở dữ liệu.
▪	label: Thuộc tính này sẽ được hiển thị trong admin.
▪	modelInstance: Xác định model tương ứng của product type.
Đây chỉ là ví dụ đơn giản nhất, ngoài ra còn có nhiều thẻ và thuộc tính dùng để định nghĩa product type.
Tạo model
Sau khi tạo product type bước tiếp theo chúng ta phải tạo model tương ứng với product type đã tạo. Mỗi product type được liên kết với một model tương ứng. Model này sẽ sửa đổi hành vi và thuộc tính của loại sản phẩm và được gọi trong quá trình thao tác sản phẩm.
ViMagento/HelloWorld/Model/Product/Type.php
 
	 
<?php
 
namespace ViMagento\HelloWorld\Model\Product;
 
class Type extends \Magento\Bundle\Model\Product\Type
{
    const TYPE_ID = 'custom_product_type_code';
 
    /**
     * {@inheritdoc}
     */
    public function deleteTypeSpecificData(\Magento\Catalog\Model\Product $product)
    {
        // method cố ý để trống 
    }
}
 
Thường thì product type hoạt động ra sao sẽ liên quan đến class mà nó kế thừa. Ví dụ ở trên custom product type tôi đã kế thừa từ bundle product. Ngoài ra sẽ có thêm các class type sau:
▪	Simple product: \Magento\Catalog\Model\Product\Type\Simple
▪	Virtual product: \Magento\Catalog\Model\Product\Type\Virtual
▪	Configurable product: \Magento\ConfigurableProduct\Model\Product\Type\Configurable
▪	Grouped product: \Magento\GroupedProduct\Model\Product\Type\Grouped
▪	Downloadable product: \Magento\Downloadable\Model\Product\Type
▪	Bundle product: \Magento\Bundle\Model\Product\Type
Sau khi xong các bạn xóa cache magento bằng câu lệnh php bin/magento cache:clean để áp dụng những thay đổi bạn vừa thực hiện. Nếu không có lỗi gì xảy ra bạn sẽ được kết qua như bên dưới:
 Thêm product type trong Magento 2
Liên kết với các thuộc tính chung
Sau khi bạn thêm sản phẩm cho custom product type ở trên, bạn sẽ thấy thiếu một số field quan trọng như price, weight…Đó là những thuộc tính chung và chúng ta phải thêm nó vào.
ViMagento/HelloWorld/Setup/Patch/Data/Attribute.php
 
<?php
 
namespace ViMagento\HelloWorld\Setup\Patch\Data;
 
use Magento\Eav\Setup\EavSetup;
use Magento\Eav\Setup\EavSetupFactory;
use Magento\Framework\Setup\ModuleDataSetupInterface;
use Magento\Framework\Setup\Patch\DataPatchInterface;
 
class Attribute implements DataPatchInterface
{
    /**
     * @var ModuleDataSetupInterface
     */
    private $setup;
 
    /**
     * EAV setup factory
     *
     * @var EavSetupFactory
     */
    protected $eavSetupFactory;
 
    /**
     * Init
     *
     * @param ModuleDataSetupInterface $setup
     * @param EavSetupFactory $eavSetupFactory
     */
    public function __construct(
        ModuleDataSetupInterface $setup,
        EavSetupFactory $eavSetupFactory
    )
    {
        $this->setup = $setup;
        $this->eavSetupFactory = $eavSetupFactory;
    }
 
    public function apply()
    {
        /** @var EavSetup $eavSetup */
        $eavSetup = $this->eavSetupFactory->create(['setup' => $this->setup]);
 
        //liên kết những thuộc tính cần thiết cho product type
        $fieldList = [
            'price',
            'special_price',
            'special_from_date',
            'special_to_date',
            'minimal_price',
            'cost',
            'tier_price',
            'weight',
        ];
 
        foreach ($fieldList as $field) {
            $applyTo = explode(
                ',',
                $eavSetup->getAttribute(\Magento\Catalog\Model\Product::ENTITY, $field, 'apply_to')
            );
            if (!in_array(\ViMagento\HelloWorld\Model\Product\Type::TYPE_ID, $applyTo)) {
                $applyTo[] = \ViMagento\HelloWorld\Model\Product\Type::TYPE_ID;
                $eavSetup->updateAttribute(
                    \Magento\Catalog\Model\Product::ENTITY,
                    $field,
                    'apply_to',
                    implode(',', $applyTo)
                );
            }
        }
    }
 
    /**
     * {@inheritdoc}
     */
    public static function getDependencies()
    {
        return [];
    }
 
    /**
     * {@inheritdoc}
     */
    public function getAliases()
    {
        return [];
    }
 
    public static function getVersion()
    {
        return '1.0.1';
    }
}
 
Tiếp theo các bạn chạy câu lệnh php bin/magento setup:upgrade và sẽ được kết quả như bên dưới:
 Thêm các thuộc tính chung vào product type
Composite Products
Khi thêm sản phẩm con cho các loại product kết hợp như grouped product hay bundle product. Hiện tại khi làm đến đây chúng ta chưa thêm được những sản phẩm thuộc custom product type vừa tạo làm sản phẩm con cho các sản phẩm kết hợp. Tức là ví dụ khi bạn thêm một sản phẩm thuộc grouped product, đến khi bạn thêm sản phẩm con cho sản phẩm này thì những sản phẩm thuộc custom product type sẽ không hiển thị cho bạn chọn. Để giải quyết vấn đề này bạn cần cần thêm đoạn code sau vào file product_types.xml đã tạo ở đầu bài viết:
ViMagento/HelloWorld/etc/product_types.xml
 

	 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Catalog:etc/product_types.xsd">
    <type name="custom_product_type_code" label="Custom Product Type" modelInstance="ViMagento\HelloWorld\Model\Product\Type"></type>
    <composableTypes>
        <type name="custom_product_type_code" />
    </composableTypes>
</config>
 
Kết luận
Vừa rồi tôi đã hướng dẫn các bạn tạo một custom product type trong Magento 2. Qua bài viết này hi vọng các bạn có thể tạo product type của mình. Nếu có bất kỳ thắc mắc nào các bạn có thể để lại bình luận bên dưới để được giải đáp. Thanks.
 
Các cách để override templates trong Magento 2
bởi Admin 02/09/2020 0 Bình luận 137 xem
Ghi đè một templates có thể được coi là một trong những tác vụ phổ biến nhất đối với một nhà phát triển làm việc trên nền tảng Magento 2. Trong phần lớn các trường hợp, hoàn thành nhiệm vụ này là một điều tương đối dễ dàng. Tuy nhiên, trong một số trường hợp khác, nó có vẻ như là một nhiệm vụ bất khả thi.
Do đó, trong bài viết này, tôi sẽ cung cấp cho các bạn một số phương pháp mà bạn có thể sử dụng trong các trường hợp khác nhau để override templates gốc trong Magento 2. Bên cạnh đó, tôi cũng muốn cho các bạn biết khi nào các bạn nên cân nhắc sử dụng một giải pháp thay thế cho việc override templates.
Phương pháp 1: Theme file path
Phương pháp này sẽ được sử dụng khi bạn muốn xây dựng một theme. Cụ thể hơn, trong Magento 2, layout, templates hoặc web của module hoặc theme cha có thể được override dễ dàng bằng cách đặt nó vào <theme_dir> / <Vendor> _ <Module> / path / to / file.
Ví dụ: Đối với module Magento_Theme, bạn có thể đặt templates của mình trong <theme_dir> /Magento_Theme/templates/html/header.phtml, thì templates được đặt tại <theme_dir> / <Vendor> _ <Module> / view /html/header.phtml sẽ được override.
Phương pháp 2: reference trong layout file
Phương pháp này được đề xuất sử dụng khi bạn muốn xây dựng một module. Để sử dụng layout XML để override templates, bạn sẽ chỉ cần ghi đè đối số templates của block. Hãy lấy templates Magento_Wishlist/view/frontend/Templat /view.phtml làm ví dụ, để view.phtml được override bằng templates của riêng bạn, trước tiên bạn cần phải tạo file layout mới: <Vendor> _ <Module> /view/frontend/layout/wishlist_index_index.xml.
Hiện tại, có 3 phương pháp có thể được áp dụng để override một block, cả 3 đều cho kết quả như nhau nên bạn có thể sử dụng cách nào cũng được:
Cách 1:
wishlist_index_index.xml
 

 
<?xml version="1.0"?>
<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
    <body>
        <referenceBlock name="customer.wishlist" templates="Vendor_Module::view.phtml" />
    </body>
</page>
 
Cách 2:
 


 
<?xml version="1.0"?>
<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
    <body>
        <referenceBlock name="customer.wishlist">
            <arguments>
                <argument name="template" xsi:type="string">Vendor_Module::view.phtml</argument>
            </arguments>
        </referenceBlock>
    </body>
</page>
 
Cách 3:
 


 
<?xml version="1.0"?>
<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
    <body>
        <referenceBlock name="customer.wishlist">
            <action method="setTemplate">
                <argument name="template" xsi:type="string">Vendor_Module::view.phtml</argument>
            </action>
        </referenceBlock>
    </body>
</page>
 
Mặc dù người ta nói rằng phương pháp mới là phương pháp thích hợp để override templates bằng layout XML. Nhưng thực tế là có nhiều trường hợp mà phương pháp này không hoạt động. Trong những tình huống này, phương pháp cũ không dùng nữa có thể được sử dụng như một giải pháp tạm thời cho đến khi ai đó có thể giải quyết sự cố.
Tiếp theo, bạn phải đặt templates tùy chỉnh mới mà bạn vừa tạo vào vị trí mà bạn đã chỉ định trong file layout ở trên. Trong trường hợp này là: <Vendor>_<Module>/view/frontend/templates/view.phtml.
Vì đường dẫn đến templates của bạn đã được khia báo trong layout XML của bạn. Nên bạn chỉ cần tạo một file templates theo đường dẫn đó là được. Nhưng khuyên bạn nên đặt đường dẫn theo đúng đường dẫn của file templates gốc. Ví dụ bạn muốn override templates Magento_Wishlist/view/frontend/template/view.phtml thì bạn nên đặt thư mục dẫn đến templates của mình là <Vendor>_<Module>/view/frontend/template/view.phtml.
Sau đó bạn cần thêm module bạn vừa override templates vào thẻ sequence trong module.xml của bạn. Điều này cho phép module Magento_Wishlist được load trước module của bạn, để đảm bảo rằng templates gốc đã tồn tại. Nếu không việc override templates của bạn sẽ không được áp dụng do không tìm thấy templates mà bạn đã chỉ định.
 


10	 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Module/etc/module.xsd">
    <module name="Vendor_Module" setup_version="100.0.0">
        <sequence>
            <module name="Magento_Wishlist"/>
        </sequence>
    </module>
</config>
 
Phương pháp 3: Class preference
Trong thực tế thì có một số block không có thuộc tính name nên chúng ta không thể override templates theo các cách ở trên. Tuy nhiên bạn vẫn có thể override templates bằng cách sử dụng class preference nếu thuộc tính template của block không có prefix Vendor_Module.
Để giúp bạn dễ hiểu hơn về phương pháp này, trong ví dụ sau, bạn sẽ override block chứa templates cart / item / default.phtml trong Magento/Checkout/view/frontend/layout/checkout_cart_item_renderers.xml.
 
	 
<block class="Magento\Checkout\Block\Cart\Item\Renderer" as="virtual" template="cart/item/default.phtml">
 
Vì phạm vi cho đường dẫn templates được xác định bởi thuộc tính class của block, tiền tố Vendor_Module có vẻ không cần thiết nếu templates và class của block nằm trong cùng một module. Nói cách khác, để thay đổi phạm vi module của templates, bạn chỉ cần thay thế class của block bằng class của bạn trong file di.xml:
 
 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:ObjectManager/etc/config.xsd">
    <preference for="Magento\Checkout\Block\Cart\Item\Renderer" type="Vendor\Module\Block\Checkout\Cart\Item\Renderer" />
</config>
 
Mặc dù bạn không thực sự chỉnh sửa gì đối với class này nhưng bạn vẫn phải tạo nó. Vendor/Module/Block/Checkout/Cart/Item/Renderer.php
 
	 
<?php
/**
 * This block serves as a skeleton class to change the scope of a block definition. 
 * The template attribute on the block will now default to this module rather than the 
 * core module on the original block definition.
 */
namespace Vendor\Module\Block\Checkout\Cart\Item;
class Renderer extends \Magento\Checkout\Block\Cart\Item\Renderer {}
 
Sau đó để thực hiện việc override templates bạn chỉ cần khia báo file templates của bạn đúng như templates gốc như bình thường. Ở đây là : Vendor/Module/view/frontend/templates/cart/item/default.phtml. Lưu ý rằng phương pháp này không được khuyến khích sử dụng. Bạn chỉ nên sử dụng cách này nếu các cách còn lại không làm được.
Phương pháp 4: Sử dụng Plugin
Class preference có thể là một cách chấp nhận được nếu bạn muốn override templates cho tất cả các trường hợp của một class và khi tiền tố Vendor_Namespace bị thiếu trong thuộc tính template trong block. Tuy nhiên, trong những trường hợp bạn cần override một templates cụ thể. Bạn nên sử dụng Plugin.
Trong ví dụ dưới đây, tôi sẽ sử dụng một plugin để override templates Magento_Catalog :: category/products.phtml bằng templates riêng của tôi.
Đây là templates ban đầu:
 
	 
<block class="Magento\Catalog\Block\Category\View" name="category.products" template="Magento_Catalog::category/products.phtml">
 
Ở đây chúng ta cần plugin vào class Magento\Catalog\Block\Category\View để thực hiện việc override templates. Templates sẽ được truy xuất và chuyển thành html bằng phương thức toHtml(). Để override templates đó, bạn cần thay đổi biến $ _template thành templates của riêng bạn. Các bạn tạo file di.xml trong module của bạn:
 

 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:ObjectManager/etc/config.xsd">
    <type name="Magento\Catalog\Block\Category\View">
        <plugin name="module_catalog_category_view_override_template" type="Vendor\Module\Plugin\Catalog\Block\Category\View" />
    </type>
</config>
 
Vendor/Module/Plugin/Catalog/Block/Category/View.php
 



	 
<?php
namespace Vendor\Module\Plugin\Catalog\Block\Category;
 
class View
{
    public function beforeToHtml(\Magento\Catalog\Block\Category\View $subject)
    {
        if ($template === 'Magento_Catalog::category/products.phtml') {
            $subject->setTemplate('Vendor_Module::catalog/category/products.phtml');
        }
    }
}
 
Cuối cùng, để hoàn thành việc override templates, bạn chỉ cần đặt templates của mình vào vị trí thích hợp
<Vendor>/<Module>/view/frontend/templates/catalog/category/products.phtml
Lưu ý rằng bạn chỉ nên sử dụng phương pháp này nếu block không có bất kỳ name nào và nếu block có tiền tố Vendor_Module.
Các phương pháp khác
Override một templates không phải lúc nào cũng là một lựa chọn tốt cho bạn khi sửa đổi nội dung nào đó trên một trang. Trong những trường hợp khác nhau, sẽ tốt hơn cho bạn nếu bạn chọn một giải pháp thay thế.
Cấu trúc của layout
Đôi khi bạn muốn thêm một vài thông tin vào layout thì không cần thiết phải override templates mà bạn chỉ cần chèn templates của bạn vào vị trí thích hợp là được. Điều bạn cần lưu ý ở đây là nơi bạn muốn đặt templates của bạn là bên trong một block hay container. Đặc điểm mà bạn cần phân biệt giữa block và container đó là block cần phải gọi block con của nó một cách rõ ràng để block con có thể hiển thị, còn container sẽ hiển thị tất cả block và container con của nó.
layout/wishlist_index_index.xml
  
<?xml version="1.0"?>
<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd">
    <body>
        <referenceContainer name="content">
            <block class="Magento\Framework\View\Element\Template" name="some.block" template="Vendor_Module::some-template.phtml" after="customer.wishlist"/>
        </referenceContainer>
    </body>
</page>
 
Xóa phần tử với CSS, JS
Mặc dù phương pháp này không được khuyến nghị, nhưng trong một số trường hợp bạn muốn tránh xóa phần tử bằng cách override templates, bạn có thể xóa phần tử đó bằng JS hoặc CSS. Nhưng bạn phải cẩn thận vì nếu bạn sử dụng điều này quá thường xuyên, phần lớn HTML sẽ được tải mà không hiển thị cho người dùng. Do đó, thời gian tải trang sẽ tăng lên, dẫn đến HTML và CSS lộn xộn và khó bảo trì. Vì vậy, chỉ sử dụng phương pháp này khi bạn thực sự cần nó.
Thay thế một jQuery widget
Trong các tình huống khác nhau, không cần override templates mà JS được khởi tạo khi bạn muốn override JS trong Magento 2. Thay vào đó, các hàm và đối tượng trên Query UI widget có thể bị override giống như khi một biến hoặc phương thức trên một class PHP mà bạn đang mở rộng bị override. Để làm được điều này, trước tiên tệp JS của bạn cần được tạo trong theme hoặc module của bạn:
▪	In your theme: <Vendor>/<Theme>/web/js/customAccordion.js
▪	In your module: <Vendor>/<Module>/view/frontend/web/js/customAccordion.js
customAccordion.js
 
 
define([
  'jquery',
  'jquery/ui',
  'mage/accordion'
], function($){
  $.widget('Vendor_Module.customAccordion', $.mage.accordion, {
      _create: function() {
          // custom code here
      }
  });
 
  return $.Vendor_Module.customAccordion;
});
 
Tiếp theo, hãy tạo ánh xạ cho CustomAccordion của bạn:
▪	In your theme: <Vendor>/<Theme>/requirejs-config.js
▪	In your module: <Vendor>/<Module>/view/frontend/requirejs-config.js
requirejs-config.js
 

	 
var config = {
    map: {
        '*': {
            'accordion': 'Vendor_Module/js/customAccordion'
        }
    }
};
 
Sau khi hoàn thành các bước trên, customAccordion của bạn sẽ được tải ở bất kỳ nơi nào mà bạn include hoặc kích hoạt customAccordion.
Thay đổi dòng văn bản bằng translate file
Trong Magento 2, có một phương pháp siêu đơn giản để override các chuỗi văn bản. Phương pháp này là thêm bản dịch vào theme hoặc module của bạn phù hợp với dòng văn bản bạn muốn thay đổi và sau đó thay thế nó bằng bất kỳ chuỗi nào bạn đặt. Cách tiếp cận này không phải là cách tốt nhất nhưng trong nhiều tình huống khác nhau, nó đáng để đánh đổi. Điều này là do trong những trường hợp như vậy, thay vì phải override một số lượng lớn templates, bạn chỉ cần thực hiện một thay đổi văn bản đơn giản. Tuy nhiên, hãy cẩn thận với nó nếu chuỗi mà bạn đang dịch được sử dụng ở các vị trí khác nhau.
Kết luận
Override templates là một cách nhanh chóng và dễ dàng để thực hiện các thay đổi trong Magento 2. Do đó chúng có thể dễ dàng bị lạm dụng. Ở trên, tôi vừa giới thiệu cho các bạn những ưu và nhược điểm của việc override templates trong Magento 2. Hy vọng nó có thể hữu ích cho bạn khi lựa chọn một phương pháp thích hợp để sử dụng. Nếu bạn có bất kỳ câu hỏi hoặc ý tưởng mới, đừng ngại để lại bình luận bên dưới.
 
Widget là gì? Hướng dẫn tạo custom widget trong Magento 2
bởi Admin 03/09/2020 0 Bình luận 104 xem
Các widget cho phép quản trị viên cửa hàng Magento 2 thêm nội dung tĩnh hoặc động vào các trang và khối CMS, cung cấp nhiều chức năng và triển khai đơn giản. Widget là các thành phần có thể tái sử dụng có thể được thêm vào bất kỳ khối CMS nào của Magento 2.
Do đó, widget cho phép các developer Magento 2 và quản trị viên cửa hàng thêm các giao diện và tính năng tương tác vào giao diện người dùng mà không cần phải biết nhiều về lập trình. Tất nhiên, họ vẫn cần biết cách sử dụng Magento để tạo một widget. Trong bài viết này tôi sẽ giải thích cơ bản về widget là gì? Và cách sử dụng widget. Sau đó sẽ hướng dẫn các bạn thêm một custom widget trong Magento 2.
Widget là gì?
Magento 2 là phiên bản mới nhất của Magento, một trong những nền tảng Thương mại điện tử hàng đầu hiện nay. Các widget đóng một vai trò quan trọng trong Magento 2, đặc biệt là các chức năng của nó. Ngoài việc cung cấp thêm chức năng phía người dùng, các widget Magento giúp quản trị viên thêm nội dung tĩnh hoặc động vào các trang và khối CMS. Vậy widget là gì?
Widget trong Magento 2 về cơ bản là một tiện ích mở rộng được thiết kế với một tập hợp các tùy chọn cấu hình nâng cao. Do tính linh hoạt và khả năng kiểm soát cao, chúng được sử dụng để cung cấp thông tin và marketing content thông qua Administrator panel Magento. Một trong những lợi thế của các widget Magento 2 là bạn có thể “gọi” chúng từ bất kỳ đâu trên trang web.
Các widget cũng cho phép quản trị viên thêm các giao diện và tính năng tương tác trong giao diện người dùng của Magento mà không cần phải viết code.
Magento 2 cung cấp nhiều loại widget
Trước khi chúng ta chuyển sang cách tạo một widget, hãy xem xét kỹ hơn phạm vi tiêu chuẩn của các widget được hỗ trợ trong Magento 2:
▪	Recently Compared Products: Bạn hẳn đã bắt gặp tiện ích này khi duyệt các sản phẩm trên các trang thương mại điện tử yêu thích của mình. Tiện ích này được sử dụng để hiển thị các sản phẩm đã xem hoặc so sánh gần đây trong sidebar của trang danh mục.
▪	Orders and Returns: Bất cứ khi nào bạn mua sắm một sản phẩm trực tuyến, phải có một tiện ích giúp truy cập nhanh các đơn đặt hàng và trả hàng. Nếu người dùng muốn xem lại các sản phẩm đã đặt hàng hoặc đã trả lại, họ có thể điền vào các chi tiết cần thiết như Order ID, Billing the Last Date, Find Order by, Email v.v.
▪	Catalog Products List: Đây là một widget được sử dụng rộng rãi khác; mọi người đều quen thuộc với phần “sản phẩm nổi bật” trên các trang Thương mại điện tử, vì hầu hết mọi trang đều có phần này. Các sản phẩm nổi bật thường được đặt trên trang chủ với mục đích quảng bá sản phẩm. Sản phẩm cụ thể được hiển thị với các chi tiết ngắn gọn như giá cả, tính năng và các tùy chọn như thêm vào giỏ hàng, thêm vào danh sách yêu thích và thêm vào tính năng so sánh.
▪	Catalog Product Link: Mục đích chính của tiện ích Catalog Product Link là nó cho phép quản trị viên quản lý các liên kết cho các sản phẩm, bao gồm related products, cross sells, upsells, and grouped products. Khi bạn truy cập trang Catalog Product Link, bạn sẽ thấy các danh mục khác nhau được bắt đầu bằng phần giới thiệu.
▪	Catalog Category Link: Trong các trang web Thương mại điện tử, đặc biệt là các trang web dựa trên sản phẩm, bạn sẽ thấy không thiếu các tiện ích catalog category link.
▪	Custom Block Widget: Có thể kết hợp các khối, widgets và trang tùy chỉnh để hiển thị các phần của danh mục hoặc thông tin khác mà khách hàng có thể thấy hữu ích.
Widget có thể được sử dụng để cải thiện trải nghiệm người dùng và thêm chức năng cho cửa hàng.
Các khối và widget là những yếu tố quan trọng của hầu hết các trang web Thương mại điện tử. Chúng cho phép người dùng nhanh chóng tạo và kiểm soát nội dung, đồng thời có thể được sử dụng để làm những việc như:
▪	Thêm khối động hoặc thông tin trên sidebar.
▪	Thêm banners trên các trang CMS.
▪	Thêm custom menu.
▪	Thêm giao diện người dùng.
Bất kỳ trang web nào cũng cần nhiều chức năng để chạy trơn tru và thu hút nhiều khách truy cập hơn, và tạo ra trải nghiệm người dùng hấp dẫn là điều bắt buộc trong Thương mại điện tử. Đó là lúc các custom widget trong Magento 2 phát huy tác dụng của nó.
Cách tạo custom widget trong Magento 2
Bây giờ, chúng ta sẽ tìm hiểu cách tạo custom widget cho Magento 2. Các custom widget cung cấp cách tốt nhất để thêm và chỉnh sửa nội dung bên trong các khối hoặc trang CMS, vì chúng có thể được điều chỉnh để phù hợp với yêu cầu của bạn.
Đầu tiên để tạo một custom widget chúng ta cần phải tạo một module. Tôi sẽ tạo một module mới với tên là ViMagento_Widget.
ViMagento/Widget/etc/module.xml
 


10	 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Module/etc/module.xsd">
    <module name="ViMagento_Widget" setup_version="1.0.0">
        <sequence>
            <module name="Magento_Catalog"/>
        </sequence>
    </module>
</config>
 
ViMagento/Widget/registration.php
 

 
<?php
\Magento\Framework\Component\ComponentRegistrar::register(
    \Magento\Framework\Component\ComponentRegistrar::MODULE,
    'ViMagento_Widget',
    __DIR__
);
 
Tiếp theo các bạn chạy câu lệnh php bin/magento setup:upgrade để cài đặt module.
Để tạo custom widget bạn cần tạo file widget.xml bên trong thư mục etc trong module của bạn.
ViMagento/Widget/etc/widget.xml
 
<?xml version="1.0" ?>
<widgets xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Widget:etc/widget.xsd">
    <widget class="ViMagento\Widget\Block\Sample" id="vimagento_widget_sample">
        <label>Button</label>
        <description>Thêm button</description>
        <parameters>
            <parameter name="title" sort_order="10" visible="true" xsi:type="text" required="true">
                <label>Tiêu đề</label>
            </parameter>
            <parameter name="color" sort_order="20" visible="true" xsi:type="text" required="true">
                <label>Màu sắc</label>
            </parameter>
            <parameter name="width" sort_order="30" visible="true" xsi:type="text" required="true">
                <label>Chiều rộng</label>
            </parameter>
            <parameter name="height" sort_order="40" visible="true" xsi:type="text" required="true">
                <label>Chiều dài</label>
            </parameter>
        </parameters>
    </widget>
</widgets>
 
 
	 
ViMagento/Widget/Block/Sample.php
 
 


	 
<?php
 
namespace ViMagento\Widget\Block;
 
use Magento\Framework\View\Element\Template;
use Magento\Widget\Block\BlockInterface;
 
class Sample extends Template implements BlockInterface
{
    protected $_template = "widget/sample.phtml";
}
 
 
	 
ViMagento/Widget/view/frontend/templates/widget/sample.phtml
 
 



	 
<button id="sample">
    <?= $block->getData('title') ?>
</button>
 
<style>
    #sample {
        border-radius: 5px;
        width: <?= $block->getData('width') ?>;
        height: <?= $block->getData('height') ?>;
        color: <?= $block->getData('color') ?>;
    }
</style>
 
Ở đây mình chỉ làm một ví dụ cơ bản là thêm một button thôi nhé. Trong thực tế các bạn có thể làm được những tính năng hay ho nhờ widget.
Sau đó các bạn hãy xóa cache bằng câu lệnh php bin/magento cache:clean để áp dụng những thay đổi mà bạn vừa thực hiện.
Cách sử dụng widget trong Magento 2
Bạn có thể thêm widget vừa tạo vào bất cứ trang nào bạn thích. Đầu tiên bạn vào CONTENT > WIDGET
 Cách sử dụng widget trong Magento 2
Sau đó các bạn sẽ được điều hướng đến trang quản lý widget, các bạn nhấn vào button Add Widget.
 Cách sử dụng widget trong Magento 2
Sau đó ở tab Settings các bạn chọn Type là widget bạn muốn chọn, ở đây tôi sẽ chọn widget Button tôi vừa tạo ở trên.
 Cách sử dụng widget trong Magento 2
Các bạn chọn theme sẽ áp dụng widget ở mục Design Theme.
 Cách sử dụng widget trong Magento 2
Ở tab Storefront Properties các bạn điền đầy đủ thông tin như bên dưới:
 Cách sử dụng widget trong Magento 2
Ở mục Layout Updates các bạn có thể chọn được trang và vị trí cụ thể sẽ hiển thị widget của bạn.
 Cách sử dụng widget trong Magento 2
Tiếp theo ở tab Widget Options các bạn thêm các thông số chúng ta đã thêm vào wiget ở trên:
 Cách sử dụng widget trong Magento 2
Cuối cùng các bạn ra ngoài frontend sẽ thấy được button mình đã thêm. Ở trên mình chỉ định widget được hiển thị ở toàn bộ trang và sẽ xuất hiện ở vị trí After Page Header.
 Cách sử dụng widget trong Magento 2
Kết luận
Vừa rồi mình vừa hướng dẫn các bạn cơ bản về widget cũng như cách tạo một custom widget trong Magento 2. Hy vọng bài viết có thể hữu ích với mọi người. Thanks.
 
Tìm hiểu về di.xml trong Magento 2
bởi Admin 07/09/2020 0 Bình luận 188 xem
di.xml (viết tắt của Dependency Injection) là một tập tin quan trọng trong Magento 2, được dùng để khai báo các phụ thuộc của module trong Magento 2. Vậy di.xml trong Magento 2 có thể làm được những gì:
▪	Bạn có thể sử dụng di.xml để ghi đè lên một class cụ thể với preference node.
▪	Bạn có thể tạo mới hoặc thay thế một đối số trong constructor của một class với arguments.
▪	Thay đổi hành vi của một class với before, after và arround Plugin.
▪	Tạo một class con của một class khác với virtualType node.
 Tìm hiểu về di.xml trong Magento 2
Trước khi đi tìm hiểu từng phần cụ thể của các nodes trong di.xml thì chúng ta hãy lấy một cái nhìn tổng quan về phạm vi của nó.
Phạm vi của tập tin di.xml trong Magento 2
Mỗi module có thể có một tập tin di.xml ở khu vực global và area. Tôi nói area ở đây là gì? Nó có thể là frontend hoặc backend còn global có nghĩa là tập tin di.xml nằm trực tiếp trong thư mục etc. Magento sẽ đọc tất cả các tập tin di.xml có trong hệ thống và sau đó merge(hợp nhất) tất cả chúng lại bằng cách nối các nodes lại với nhau. Các nodes ở đây chính là các thẻ như: type, virtualType, plugin, preference.
Magento sẽ đọc các file di.xml theo các phạm vi sau:
▪	Tập tin khởi tạo app/etc/di.xml
▪	Global (<moduleDir>/etc/di.xml)
▪	Area (<moduleDir>/etc/<area>/di.xml)
Thẻ type trong di.xml
Đầu tiên chúng ta hãy xem qua đoạn code sau:
 
 
<type name="Magento\Customer\Model\ResourceModel\Group" shared="false">
    <arguments>
        <argument name="groupManagement" xsi:type="object">Magento\Customer\Api\GroupManagementInterface\Proxy</argument>
    </arguments>
</type>
 
Ở đây chúng ta có thể hiểu rằng chúng ta đang tạo mới một đối tượng có tên là groupManagement với class là Proxy như là một đối số, và chúng ta sẽ truyền cái đối số này vào contructor của class Group.
Ở đây chúng ta cũng có thể thay thế một đối số trong contructor của một class. Để các bạn có một cái nhìn tổng quan hơn thì tôi sẽ lấy một ví dụ đơn giản như sau: Giả sử tôi có một class có tên là ViMagento\HelloWorld\Block\Index và trong contructor của tôi đang có một biến $a = 1 như đoạn code bên dưới:
 

 
    protected $a;
 
    public function __construct($a = 1)
    {
        $this->a = $a;
    }
 
Biến a của tôi đang bằng 1 và tôi muốn sử dụng thẻ type trong di.xml để thay thế đối số này thành 2 chẳng hạn thì tôi phải làm sao. Lưu ý ở đây chỉ là ví dụ để các bạn có thể hiểu được nó làm việc như thế nào thôi nhé.
  
 <type name="ViMagento\HelloWorld\Block\Index">
    <arguments>
        <argument name="a" xsi:type="string">2</argument>
    </arguments>
</type>
 
Và ở trên tôi đã khai báo một file di.xml, tôi sử dụng thẻ type và truyền vào class mà tôi muốn thay đổi đối số. Sau đó sử dụng arguments khai báo một biến là a trùng với biến ở contructor mà tôi muốn thay thế có giá trị là 2 và kiểu dữ liệu là string. Đó là cách mà thẻ type trong tập tin di.xml hoạt động.
Thẻ virtualType trong di.xml
virtual type có tạo một class ảo của một class cha. Hay nói cách khác virtualType có thể dùng để tạo một class con của một class khác mà không làm ảnh hưởng đến class đó.
 


 
<virtualType name="moduleConfig" type="Magento\Core\Model\Config">
    <arguments>
        <argument name="type" xsi:type="string">system</argument>
    </arguments>
</virtualType>
<type name="Magento\Core\Model\App">
    <arguments>
        <argument name="config" xsi:type="object">moduleConfig</argument>
    </arguments>
</type>
 
Đoạn code trên đã sử dụng virtualType để tạo một class con có tên là moduleConfig của class cha là Config. Giống như class moduleConfig kế thừa từ class Config và nó tất cả những đặc tính của class cha vậy. Cái này là mình hiểu như vậy thôi chưa chắc đã đúng nhé. Chúng thường tạo ra class ảo như thế và truyền vào thẻ type để thay thế một đối số trong contructor của một class. Các bạn hay dùng khi tạo một UI grid trong admin.
Plugin trong di.xml
Plugin thì có thể các bạn sẽ sử dụng nhiều đến nó. Plugin thường được sử dụng để tác động đến hành vi của một class hay phương thức bằng cách chặn lệnh gọi đến phương thức ban đầu và chạy code của chúng ta. Có ba loại plugin là before, after và arround. Các bạn có thể xem lại bài viết Tìm hiểu về Plugin(Interceptor) trong Magento 2 để hiểu hơn về plugin. Ở bài này tôi sẽ không nói lại nữa.
 	 
<type name="Magento\Catalog\Block\Product\ProductList\Toolbar">
    <plugin name="sortby_extend_default_sort_filters" type="ViMagento\HelloWorld\Plugin\Block\Toolbar" />
</type>
 
preference trong Magento 2
Có lẽ đây chính là thẻ dễ hiểu nhất trong tập tin di.xml. Hãy xem đoạn code bên dưới sau đó tôi sẽ giải thích.
 	 
<preference for="Magento\Customer\Api\AddressRepositoryInterface"
            type="Magento\Customer\Model\ResourceModel\AddressRepository" />
 
preference dùng để ghi đè(override) một class cụ thể. Ở đoạn code trên chúng ta có thể hiểu class AddressRepository sẽ ghi đè lên class AddressRepositoryInterface. Điều này nói cho Magento biết rằng những nơi nào có khởi tạo class AddressRepositoryInterface thì hãy thay thế bằng class AddressRepository.
preference không chỉ được dùng cho Interface không đâu nhé. Chúng có thể sử dụng cho bất cứ class nào mà bạn muốn. Nhưng cách này thì không được khuyến khích, bạn nên sử dụng plugin hoặc events, nếu các cách còn lại không được thì mới sử dụng preference. Đoạn code bên dưới sẽ nói cho Magento biết chỗ nào khởi tạo hoặc khai báo class CustomerManagement thì hãy thay thế bằng class customModel.
  
<preference for="Magento\Customer\Model\CustomerManagement"
            type="Magento\Customer\Model\customModel" />
 
Các bạn cũng có thể đọc thêm devdocs để hiểu hơn về di.xml và trau dồi thêm tiếng anh cho mình nữa https://devdocs.magento.com/guides/v2.4/extension-dev-guide/build/di-xml-file.html
Kết luận
Vừa rồi tôi đã hướng dẫn cho mọi người về các thẻ cơ bản trong tập tin di.xml. Hy vọng có thể giúp được phần nào trong quá trình học tập của các bạn. Thanks.
Filter Collection trong Magento 2
bởi Admin 12/09/2020 0 Bình luận 63 xem
Trong bài viết này tôi sẽ hướng dẫn các bạn về addAttributeToFilter và addFieldToFilter trong Magento 2. Cả hai function này đều được dùng để filter collection trong Magento 2. Đều dùng để filter collection? Tại sao lại có hai function có cùng chức năng, chúng ta sẽ cùng nhau tìm hiểu xem hai function này khác nhau chỗ nào nhé.
Nếu bạn chưa biết về collection trong Magento 2, hãy tìm hiểu trước về bài này nhé.
Model, Resouce Model và Collection trong Magento 2.
Phương thức addFieldToFilter
Phương thức này được sử dụng cho các collection không phải là EAV. Nhưng cú pháp thì tương tự như addAttributeToFilter vì vậy bạn chỉ cần biết cách sử dụng một cái là được.
Phương thức addAttributeToFilter
Phương thức này được sử dụng cho các collection theo mô hình EAV. Cả hai phương thức này bạn có thể hiểu là WHERE trong SQL. Chúng hỗ trợ tất cả các điều kiện có trong SQL như lớn hơn, like, lớn hơn hoặc bằng… miễn là bạn viết đúng cú pháp của nó.
Điều kiện filter collection trong Magento 2
Tất nhiên đầu tiên bạn phải khởi tạo collection trong Constructor của bạn:
 

 
public function __construct(
        \Magento\Catalog\Model\ResourceModel\Product\CollectionFactory $collectionFactory
    )
    {
        $this->collectionFactory = $collectionFactory;
    }
 
Điều kiện =
 
$this->collectionFactory->create()->addAttributeToFilter('entity_id', ['eq' => 1]);
//hoặc
$this->collectionFactory->create()->addAttributeToFilter('entity_id', 1]);
 
Đoạn code trên sẽ filter và chỉ lấy những sản phẩm có entity_id = 1.
Điều kiện khác (!=)
 
	 
$this->collectionFactory->create()->addAttributeToFilter('entity_id', ['neq' => 1]);
 
Đoạn code trên sẽ filter và chỉ lấy những sản phẩm có entity_id khác 1.
Điều kiện like
 
	 
$this->collectionFactory->create()->addAttributeToFilter('sku', ['like' => 'SX%']);
 
Điều kiện not like
 
	 
$this->collectionFactory->create()->addAttributeToFilter('sku', ['nlike' => 'err%']);
 
Điều kiện in
 
	 
$this->collectionFactory->create()->addAttributeToFilter('entity_id', ['in' => [1, 2, 4]]);
 
Điều kiện not in
 
	 
$this->collectionFactory->create()->addAttributeToFilter('entity_id', ['nin' => [1, 3, 5]]);
 
Điều kiện null
 
	 
$this->collectionFactory->create()->addAttributeToFilter('description', ['null' => true]);
 
Điều kiện not null
 
	 
$this->collectionFactory->create()->addAttributeToFilter('description', ['notnull' => true]);
 
Điều kiện lớn hơn
 
	 
$this->collectionFactory->create()->addAttributeToFilter('entity_id', ['gt' => 12]);
 
Điều kiện nhỏ hơn
 
	 
$this->collectionFactory->create()->addAttributeToFilter('description', ['lt' => 12]);
 
Điều kiện lớn hơn hoặc bằng
 
	 
$this->collectionFactory->create()->addAttributeToFilter('description', ['gteq' => 12]);
 
Điều kiện nhỏ hơn hoặc bằng
 
	 
$this->collectionFactory->create()->addAttributeToFilter('description', ['lteq' => 12]);
 
Cách xem mã SQL dùng để debug
Khi bạn làm việc và bị báo lỗi truy vấn SQL, bạn có thể dùng sử dụng $collection->getselect()->__toString() để xem câu lệnh SQL của bạn.
 	 
$collection = $this->collectionFactory->create();
$collection ->addAttributeToFilter('entity_id', ['gt' => 10]);
echo $collection->getSelect()->__toString();
 
Đoạn code trên sẽ xuất ra màn hình mã SQL như bên dưới:
 
	 
SELECT `e`.* FROM `catalog_product_entity` AS `e` WHERE (`e`.`entity_id` > 10)
 
Kết luận
Vừa rồi tôi đã hướng dẫn cho các bạn về filter collection trong Magento 2. Hy vọng bài viết sẽ giúp ích được cho các bạn. Thanks.
 
Các hàm xử lý dữ liệu trong Magento 2
bởi Admin 12/09/2020 0 Bình luận 1 xem
Ở bài trước thì chúng ta đã tìm hiểu về addAttributeToFilter rồi, ở bài hôm nay tôi sẽ hướng dẫn các bạn về các hàm xử lý dữ liệu trong Magento 2.
Các hàm xử lý dữ liệu trong Magento 2
Các hàm xử lý dữ liệu ở đây là các hàm dùng để sắp xếp, filter…collection trong Magento 2. Thực ra thì sau cùng chúng cũng render ra các mã SQL như WHERE, ORDER BY, LIMIT… thôi, nhưng Magento 2 hỗ trợ cho chúng ta các hàm này nên chúng ta không cần phải viết các câu truy vấn SQL phức tạp nữa và quá trình làm việc cũng trở nên dễ dàng hơn nhiều.
setPageSize trong Magento 2
Hàm này giống với LIMIT trong SQL dùng để giới hạn dữ liệu của collection mà chúng ta muốn lấy. Ví dụ bên dưới tôi chỉ muốn lấy 5 sản phẩm từ product collection thôi nên tôi sẽ sử dụng hàm setPageSize và truyền vào một đối số kiểu int chính là số sản phẩm mà tôi muốn lấy.
 	 
$collection = $this->collectionFactory->create();
$collection->setPageSize(5);
 
 Collection sẽ chứa 5 sản phẩm
Tôi sẽ lấy được 5 record từ đoạn code trên và đây là câu truy vấn SQL của collection trên.
 
	 
SELECT `e`.* FROM `catalog_product_entity` AS `e` LIMIT 5
 
addAttributeToSelect trong Magento 2
Như bạn đã biết thì Magento 2 sử dụng mô hình EAV nên khi chúng ta get collection thì Magento sẽ join các bảng lại với nhau và lấy ra tất cả record mà chúng ta yêu cầu. Nhưng nếu các bạn để ý kỹ thì khi get collection của product thì nó chỉ lấy được một số record mặc định. Ví dụ:
 
 
$collection = $this->collectionFactory->create()->setPageSize(1);
echo '<pre>';
print_r($collection->getData());
echo '</pre>';
 
Ở trên tôi đã get collection của product và in dữ liệu của chúng ra màn hình.
 Khi get collection Magento chỉ lấy một số record
Và đây là câu truy vấn SQL tôi lấy được từ đoạn code trên:
 
	 
SELECT `e`.* FROM `catalog_product_entity` AS `e`
 
Khi các bạn get collection thì mặc định chúng chỉ lấy dữ liệu của bảng catalog_product_entity.
 Khi get collection mặc định chỉ lấy các attribute của table catalog_product_entity
Để lấy các attribute khác thì các bạn phải sử dụng addAttributeToSelect và truyền vào các attribute mà bạn muốn lấy thêm. Ví dụ tôi muốn lấy thêm attribute là price và name thì tôi sử dụng như sau:
 
 
$collection = $this->collectionFactory->create();
$collection->addAttributeToSelect('name')
    ->addAttributeToSelect('price');
return $collection;
 
 Lấy thêm attribute name và price sử dụng addAttributeToSelect
Nếu bạn muốn lấy tất cả attribute của collection thì bạn hãy truyền vào dấu sao addAttributeToSelect(‘*’).
addAttributeToSort trong Magento 2
Hàm này được dùng để sắp xếp theo các column có trong trong collection, tương tự như ORDER BY trong SQL. Hàm này sẽ nhận 2 đối số, đầu tiên là column dùng để sắp xếp, thứ 2 là thứ tự sắp xếp tăng dần(ASC) hay giảm dần(DESC). Ví dụ tôi muốn sắp xếp sản phẩm của tôi theo entity_id và giảm dần thì code của tôi như sau:
 	 
$collection = $this->collectionFactory->create();
$collection->addAttributeToSelect('name');
$collection->addAttributeToSort('entity_id', 'DESC');
 
Và đây là kết quả của đoạn code trên.
 Sắp xếp dùng addAttributeToSort trong Magento 2
Và bên dưới là câu truy vấn SQL cho collection trên.
 
	 
SELECT `e`.* FROM `catalog_product_entity` AS `e` ORDER BY `e`.`entity_id` DESC
 
addAttributeToFilter trong Magento 2
Hàm này dùng để filter collection tương tự như câu lệnh WHERE trong SQL. Vì tôi đã có viết một bài viết về addAttributeToFilter rồi nên các bạn có thể xem lại.
addAttributeToFilter trong Magento 2
Kết luận
Vừa rồi tôi đã hướng dẫn cho các bạn các hàm thường được sử dụng để xử lý dữ liệu trong Magento 2. Hy vọng bài viết có thể giúp ích cho các bạn mới học về Magento 2. Thanks.
 
Lưu custom data vào bộ nhớ cache | Magento 2
bởi Admin 22/09/2020 0 Bình luận 41 xem
Để duy trì hiệu xuất cho cửa hàng Magento 2 của bạn khi làm việc với các dữ liệu hiếm khi được cập nhật hoặc dữ liệu có khối lượng lớn. Chúng ta có thể lưu chúng vào bộ nhớ cache, sau đó không cần phải lần nào cũng truy cập vào database để lấy dữ liệu nữa. Thay vào đó chỉ là một câu kiểm tra, nếu dữ liệu có trong bộ nhớ cache rồi thì trả về luôn, còn ngược lại thì mới vào database để get dữ liệu ra. Nghe có vẻ cũng đơn giản phải không nào. Chúng ta hãy cùng nhau xem cách để lưu data vào bộ nhớ cache như thế nào nhé.
Cache là gì?
Bộ nhớ đệm(cache) là lớp lưu trữ dữ liệu tạm thời tốc độ cao. Trong quá trình này, các phần dữ liệu có liên quan được lưu trữ, để các yêu cầu về dữ liệu tương tự trong tương lai có thể được phục vụ nhanh hơn.
Bộ nhớ đệm giúp các ứng dụng hoạt động nhanh hơn đáng kể. Bằng cách sử dụng Bộ nhớ đệm, bạn có thể sử dụng lại các thông tin và dữ liệu cũ một cách hiệu quả. Truy xuất dữ liệu từ bộ nhớ cache nhanh hơn nhiều so với truy xuất dữ liệu trực tiếp từ Cơ sở dữ liệu.
Cache làm việc như thế nào?
Ban đầu, dữ liệu được tìm nạp từ nguồn chính của nó (ví dụ: Cơ sở dữ liệu) và được lưu trữ trong Cache. Phần dữ liệu đó có thể được truy xuất và phục vụ từ Cache thay vì được tải trực tiếp từ nguồn dữ liệu ban đầu, tức là Cơ sở dữ liệu. Khi bộ đệm được xóa hoặc làm sạch, dữ liệu mới sẽ được cập nhật trong Bộ đệm.
Tạo mới một Cache type
Tạo một file cache.xml bên trong thư mục etc trong module của bạn:
ViMagento/HelloWorld/etc/cache.xml
 

	 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Cache/etc/cache.xsd">
    <type name="vimagento_custom_cache" translate="label,description" instance="ViMagento\HelloWorld\Model\Cache\Type">
        <label>ViMagento Custom Cache</label>
        <description>Custom Cache Storage by ViMagento</description>
    </type>
</config>
 
ViMagento/HelloWorld/Model/Cache/Type.php
 
 
<?php
 
namespace ViMagento\HelloWorld\Model\Cache;
 
class Type extends \Magento\Framework\Cache\Frontend\Decorator\TagScope
{
    /**
     * Cache type code là tên định danh duy nhất
     */
    const TYPE_IDENTIFIER = 'vimagento_custom_cache';
 
    /**
     * Cache tag được sử dụng để phân biệt cache type với các cache khác
     */
    const CACHE_TAG = 'VIMAGENTO_CUSTOMCACHE';
 
    /**
     * @param \Magento\Framework\App\Cache\Type\FrontendPool $cacheFrontendPool
     */
    public function __construct(\Magento\Framework\App\Cache\Type\FrontendPool $cacheFrontendPool)
    {
        parent::__construct($cacheFrontendPool->get(self::TYPE_IDENTIFIER), self::CACHE_TAG);
    }
}
 
Sau đó các bạn xóa cache của Magento và truy cập vào admin phần System > Tools > Cache Management, bạn sẽ được như hình bên dưới:
 Tạo mới cache type trong Magento 2
Lưu custom data vào bộ nhớ cache
Đây sẽ là phần đơn giản nhưng quan trọng trong bài viết này. Mục đích thì như đầu bài viết tôi đã nói, sẽ không cần phải lần nào cũng vào database để get data. Thay vào đó chúng ta sẽ lưu chúng vào bộ nhớ cache để lần truy cập tiếp theo chúng ta sẽ sử dụng.
Đầu tiên bạn phải khởi tạo class CacheInterface trong module của bạn nơi bạn dự định sẽ lưu data và bộ nhớ cache:
  
protected $cache;
public function __construct(\Magento\Framework\App\CacheInterface $cache)
{
    $this->cache = $cache;
}
 
Để lưu dữ liệu của bạn vào bộ nhớ cache hãy sử dụng hàm save
 
	 
$this->cache->save($data, $identifier, $tags, $lifeTime);
 
Trong đó:
▪	$data: là dữ liệu cần được lưu vào cache(phải chuyển sang dạng serialize).
▪	$identifier: tên định danh duy nhất không trùng lặp.
▪	$tags: có thể bỏ trống.
▪	$lifeTime: là thời gian tồn tại của cache(tính bằng giây).
Ví dụ:
  
    const CACHE_TAG = 'VIMAGENTO_CUSTOMCACHE';
    const CUSTOM_IDENTIFIER = 'custom_cache';
    protected $cache;
    protected $serializer
    public function __construct(
        \Magento\Framework\App\CacheInterface $cache,
        \Magento\Framework\Serialize\SerializerInterface $serializer
    )
    {
        $this->cache = $cache;
        $this->serializer = $serializer;
    }
 
    public function save($data)
    {
        $this->cache->save($this->serializer->serialize($data), self::CUSTOM_IDENTIFIER, array(self::CACHE_TAG), 8600);
    }
 
Lấy dữ liệu từ bộ nhớ cache
 
	 
$data = $this->cache->load(self::CUSTOM_IDENTIFIER);
 
Các bạn nhớ chuyển sang dạng mảng nếu data đang ở dạng serialize nhé.
Ngoài ra còn các hàm dùng để xóa dữ liệu đã được cache:
 

	 
     /**
     * Remove cached data by identifier
     *
     * @param string $identifier
     * @return bool
     */
    public function remove($identifier);
 
Hàm dùng để xóa cache
 

	 
     /**
     * Clean cached data by specific tag
     *
     * @param array $tags
     * @return bool
     */
    public function clean($tags = []);
 
Kết luận
Vừa rồi mình đã hướng dẫn cho các bạn cách tạo mới một cache type cũng như lưu custom data vào bộ nhớ cache trong Magento 2. Nếu bài viết có gì thiết sót, mọi người đừng ngại để lại một bình luận để bài viết hoàn thiện hơn nhé.
Widget là gì? Hướng dẫn tạo custom widget trong Magento 2
bởi Admin 03/09/2020 0 Bình luận 107 xem
Các widget cho phép quản trị viên cửa hàng Magento 2 thêm nội dung tĩnh hoặc động vào các trang và khối CMS, cung cấp nhiều chức năng và triển khai đơn giản. Widget là các thành phần có thể tái sử dụng có thể được thêm vào bất kỳ khối CMS nào của Magento 2.
Do đó, widget cho phép các developer Magento 2 và quản trị viên cửa hàng thêm các giao diện và tính năng tương tác vào giao diện người dùng mà không cần phải biết nhiều về lập trình. Tất nhiên, họ vẫn cần biết cách sử dụng Magento để tạo một widget. Trong bài viết này tôi sẽ giải thích cơ bản về widget là gì? Và cách sử dụng widget. Sau đó sẽ hướng dẫn các bạn thêm một custom widget trong Magento 2.
Widget là gì?
Magento 2 là phiên bản mới nhất của Magento, một trong những nền tảng Thương mại điện tử hàng đầu hiện nay. Các widget đóng một vai trò quan trọng trong Magento 2, đặc biệt là các chức năng của nó. Ngoài việc cung cấp thêm chức năng phía người dùng, các widget Magento giúp quản trị viên thêm nội dung tĩnh hoặc động vào các trang và khối CMS. Vậy widget là gì?
Widget trong Magento 2 về cơ bản là một tiện ích mở rộng được thiết kế với một tập hợp các tùy chọn cấu hình nâng cao. Do tính linh hoạt và khả năng kiểm soát cao, chúng được sử dụng để cung cấp thông tin và marketing content thông qua Administrator panel Magento. Một trong những lợi thế của các widget Magento 2 là bạn có thể “gọi” chúng từ bất kỳ đâu trên trang web.
Các widget cũng cho phép quản trị viên thêm các giao diện và tính năng tương tác trong giao diện người dùng của Magento mà không cần phải viết code.
Magento 2 cung cấp nhiều loại widget
Trước khi chúng ta chuyển sang cách tạo một widget, hãy xem xét kỹ hơn phạm vi tiêu chuẩn của các widget được hỗ trợ trong Magento 2:
▪	Recently Compared Products: Bạn hẳn đã bắt gặp tiện ích này khi duyệt các sản phẩm trên các trang thương mại điện tử yêu thích của mình. Tiện ích này được sử dụng để hiển thị các sản phẩm đã xem hoặc so sánh gần đây trong sidebar của trang danh mục.
▪	Orders and Returns: Bất cứ khi nào bạn mua sắm một sản phẩm trực tuyến, phải có một tiện ích giúp truy cập nhanh các đơn đặt hàng và trả hàng. Nếu người dùng muốn xem lại các sản phẩm đã đặt hàng hoặc đã trả lại, họ có thể điền vào các chi tiết cần thiết như Order ID, Billing the Last Date, Find Order by, Email v.v.
▪	Catalog Products List: Đây là một widget được sử dụng rộng rãi khác; mọi người đều quen thuộc với phần “sản phẩm nổi bật” trên các trang Thương mại điện tử, vì hầu hết mọi trang đều có phần này. Các sản phẩm nổi bật thường được đặt trên trang chủ với mục đích quảng bá sản phẩm. Sản phẩm cụ thể được hiển thị với các chi tiết ngắn gọn như giá cả, tính năng và các tùy chọn như thêm vào giỏ hàng, thêm vào danh sách yêu thích và thêm vào tính năng so sánh.
▪	Catalog Product Link: Mục đích chính của tiện ích Catalog Product Link là nó cho phép quản trị viên quản lý các liên kết cho các sản phẩm, bao gồm related products, cross sells, upsells, and grouped products. Khi bạn truy cập trang Catalog Product Link, bạn sẽ thấy các danh mục khác nhau được bắt đầu bằng phần giới thiệu.
▪	Catalog Category Link: Trong các trang web Thương mại điện tử, đặc biệt là các trang web dựa trên sản phẩm, bạn sẽ thấy không thiếu các tiện ích catalog category link.
▪	Custom Block Widget: Có thể kết hợp các khối, widgets và trang tùy chỉnh để hiển thị các phần của danh mục hoặc thông tin khác mà khách hàng có thể thấy hữu ích.
Widget có thể được sử dụng để cải thiện trải nghiệm người dùng và thêm chức năng cho cửa hàng.
Các khối và widget là những yếu tố quan trọng của hầu hết các trang web Thương mại điện tử. Chúng cho phép người dùng nhanh chóng tạo và kiểm soát nội dung, đồng thời có thể được sử dụng để làm những việc như:
▪	Thêm khối động hoặc thông tin trên sidebar.
▪	Thêm banners trên các trang CMS.
▪	Thêm custom menu.
▪	Thêm giao diện người dùng.
Bất kỳ trang web nào cũng cần nhiều chức năng để chạy trơn tru và thu hút nhiều khách truy cập hơn, và tạo ra trải nghiệm người dùng hấp dẫn là điều bắt buộc trong Thương mại điện tử. Đó là lúc các custom widget trong Magento 2 phát huy tác dụng của nó.
Cách tạo custom widget trong Magento 2
Bây giờ, chúng ta sẽ tìm hiểu cách tạo custom widget cho Magento 2. Các custom widget cung cấp cách tốt nhất để thêm và chỉnh sửa nội dung bên trong các khối hoặc trang CMS, vì chúng có thể được điều chỉnh để phù hợp với yêu cầu của bạn.
Đầu tiên để tạo một custom widget chúng ta cần phải tạo một module. Tôi sẽ tạo một module mới với tên là ViMagento_Widget.
ViMagento/Widget/etc/module.xml
 
 
<?xml version="1.0"?>
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Module/etc/module.xsd">
    <module name="ViMagento_Widget" setup_version="1.0.0">
        <sequence>
            <module name="Magento_Catalog"/>
        </sequence>
    </module>
</config>
 
ViMagento/Widget/registration.php
 

 
<?php
\Magento\Framework\Component\ComponentRegistrar::register(
    \Magento\Framework\Component\ComponentRegistrar::MODULE,
    'ViMagento_Widget',
    __DIR__
);
 
Tiếp theo các bạn chạy câu lệnh php bin/magento setup:upgrade để cài đặt module.
Để tạo custom widget bạn cần tạo file widget.xml bên trong thư mục etc trong module của bạn.
ViMagento/Widget/etc/widget.xml
 	 
<?xml version="1.0" ?>
<widgets xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Widget:etc/widget.xsd">
    <widget class="ViMagento\Widget\Block\Sample" id="vimagento_widget_sample">
        <label>Button</label>
        <description>Thêm button</description>
        <parameters>
            <parameter name="title" sort_order="10" visible="true" xsi:type="text" required="true">
                <label>Tiêu đề</label>
            </parameter>
            <parameter name="color" sort_order="20" visible="true" xsi:type="text" required="true">
                <label>Màu sắc</label>
            </parameter>
            <parameter name="width" sort_order="30" visible="true" xsi:type="text" required="true">
                <label>Chiều rộng</label>
            </parameter>
            <parameter name="height" sort_order="40" visible="true" xsi:type="text" required="true">
                <label>Chiều dài</label>
            </parameter>
        </parameters>
    </widget>
</widgets>
 
 
	 
ViMagento/Widget/Block/Sample.php
 
 


	 
<?php
 
namespace ViMagento\Widget\Block;
 
use Magento\Framework\View\Element\Template;
use Magento\Widget\Block\BlockInterface;
 
class Sample extends Template implements BlockInterface
{
    protected $_template = "widget/sample.phtml";
}
 
 
	 
ViMagento/Widget/view/frontend/templates/widget/sample.phtml
 
 



	 
<button id="sample">
    <?= $block->getData('title') ?>
</button>
 
<style>
    #sample {
        border-radius: 5px;
        width: <?= $block->getData('width') ?>;
        height: <?= $block->getData('height') ?>;
        color: <?= $block->getData('color') ?>;
    }
</style>
 
Ở đây mình chỉ làm một ví dụ cơ bản là thêm một button thôi nhé. Trong thực tế các bạn có thể làm được những tính năng hay ho nhờ widget.
Sau đó các bạn hãy xóa cache bằng câu lệnh php bin/magento cache:clean để áp dụng những thay đổi mà bạn vừa thực hiện.
Cách sử dụng widget trong Magento 2
Bạn có thể thêm widget vừa tạo vào bất cứ trang nào bạn thích. Đầu tiên bạn vào CONTENT > WIDGET
 Cách sử dụng widget trong Magento 2
Sau đó các bạn sẽ được điều hướng đến trang quản lý widget, các bạn nhấn vào button Add Widget.
 Cách sử dụng widget trong Magento 2
Sau đó ở tab Settings các bạn chọn Type là widget bạn muốn chọn, ở đây tôi sẽ chọn widget Button tôi vừa tạo ở trên.
 Cách sử dụng widget trong Magento 2
Các bạn chọn theme sẽ áp dụng widget ở mục Design Theme.
 Cách sử dụng widget trong Magento 2
Ở tab Storefront Properties các bạn điền đầy đủ thông tin như bên dưới:
 Cách sử dụng widget trong Magento 2
Ở mục Layout Updates các bạn có thể chọn được trang và vị trí cụ thể sẽ hiển thị widget của bạn.
 Cách sử dụng widget trong Magento 2
Tiếp theo ở tab Widget Options các bạn thêm các thông số chúng ta đã thêm vào wiget ở trên:
 Cách sử dụng widget trong Magento 2
Cuối cùng các bạn ra ngoài frontend sẽ thấy được button mình đã thêm. Ở trên mình chỉ định widget được hiển thị ở toàn bộ trang và sẽ xuất hiện ở vị trí After Page Header.
 Cách sử dụng widget trong Magento 2
Kết luận
Vừa rồi mình vừa hướng dẫn các bạn cơ bản về widget cũng như cách tạo một custom widget trong Magento 2. Hy vọng bài viết có thể hữu ích với mọi người. Thanks.
 
Truy vấn SQL trong Magento 2
bởi Admin 23/09/2020 1 Bình luận 102 xem
Việc sử dụng Model và Collection của Magento cung cấp một cách tuyệt vời để truy cập và sửa đổi dữ liệu. Sử dụng các phương thức được đặt tên trong Magento 2 đã loại bỏ đi công việc viết mã SQL thuần phức tạp. Điều đó có vẻ như là một điều tuyệt vời nhưng đôi khi, trong một vài trường hợp bạn không thể sử dụng model hoặc collection cho một nhiệm vụ khó nhằn mà xếp giao cho bạn. Thì bạn có thể thay thế bằng các câu truy vấn SQl trực tiếp trong class của bạn.
Khởi tạo đối tượng ResourceConnection
Trong constructor nơi bạn muốn thực hiện truy vấn, hãy khởi tạo class ResourceConnection hoặc bạn cũng có thể khởi tạo thông qua Object Manager.
 
protected $resourceConnection;
    
public function __construct(
    \Magento\Framework\App\ResourceConnection $resourceConnection
)
{
    $this->resourceConnection = $resourceConnection;
}
 
Tạo truy vấn SQL
Nói là truy vấn SQL nhưng thực ra đa số các hàm SQL đã được Magento hỗ trợ. Ví dụ:
 	 
$connection = $this->resourceConnection->getConnection();
$tableName = $this->resourceConnection->getTableName('vimagento_table');
$sql = $connection->select()->from(array('vi' => $tableName), array('*'));
 
Ở trên các bạn lưu ý rằng table chúng ta nên lấy từ hàm getTableName phòng trường hợp nếu bạn có cấu hình table prefix thì hàm này sẽ tự động thêm prefix vào trước tên table cho bạn. Câu lệnh trên tương ứng với mã SQL sau:
SELECT vi.* FROM vimagento_table as vi
Câu lệnh SQL mình tự viết tay nên chưa chắc đã đúng nhé.
Điều kiện where
 
	 
$sql->where('status = ?', 1);
 
Điều kiện OR
 
	 
$sql->orWhere('status = ?', 4);
 
hoặc bạn cũng có thể viết như thế này cũng được:
 
	 
$sql->where(new \Zend_Db_Expr("(name like '%vimagento%' OR store like '%le van long%')"));
 
Sắp xếp (order by)
 
	 
$sql->order('name ASC');
 
Giới hạn (limit)
 
	 
$sql->limit(5);
 
Group by
 
	 
$sql->group('id');
 
Chắc chắn là còn một số hàm nữa, nhưng hiện tại mình chưa tổng hợp được và mình sẽ update sau nhé.
Lấy dữ liệu từ truy vấn
Lấy tất cả dữ liệu từ câu truy vấn:
 
	 
$data = $connection->fetchAll($sql);
 
Lấy tất cả dữ liệu từ câu truy vấn dưới dạng một mảng kết hợp:
 
	 
$data = $connection->fetchAssoc($sql);
 
Lấy column đầu tiên của tất cả dòng dữ liệu và trả về một mảng
 
	 
$data = $connection->fetchCol($sql);
 
Trả về tất cả các dòng dữ liệu từ câu truy vấn dưới dạng một mảng với key-value
 
	 
$data = $connection->fetchPairs($sql);
 
Lấy dòng đầu tiên từ kết quả của câu truy vấn:
 
	 
$data = $connection->fetchRow($sql);
 
Lấy column đầu tiên của dòng đầu tiên từ kết quả của câu truy vấn:
 
	 
$data = $connection->fetchOne($sql);
 
Các bạn có thể sử dụng $sql->__toString() để xem câu lệnh SQL như thế nào. Và đây là class đầy đủ của mình:
 
    protected $resourceConnection;
 
    public function __construct(
        \Magento\Framework\App\ResourceConnection $resourceConnection
    )
    {
        $this->resourceConnection = $resourceConnection;
    }
 
    public function execute()
    {
        $connection = $this->resourceConnection->getConnection();
        $tableName = $this->resourceConnection->getTableName('vimagento_table');
        $sql = $connection->select()->from(array('vi' => $tableName), array('*'));
        $sql->where('status = ?', 1);
        $sql->where(new \Zend_Db_Expr("(name like '%vimagento%' OR store like '%le van long%')"));
        $sql->order('name ASC');
        $sql->group('id');
        $data = $connection->fetchAll($sql);
    }
 
Kết luận
Vừa rồi tôi đã hướng dẫn các bạn cách sử dụng truy vấn SQL trong Magento 2. Các bạn có thể xem thêm bài viết bên dưới để biết thêm về cách join các table với nhau trong Magento 2. Thanks.
Bài viết: Cách sử dụng join trong Magento 2

